<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Docker</title>
      <link href="/2025/10/19/Docker/"/>
      <url>/2025/10/19/Docker/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><h2 id="命令树："><a href="#命令树：" class="headerlink" title="命令树："></a>命令树：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">Docker 命令树</span><br><span class="line">│</span><br><span class="line">├── 镜像管理 (Images)</span><br><span class="line">│   ├── docker search [镜像名]           <span class="comment"># 从仓库搜索镜像</span></span><br><span class="line">│   ├── docker pull [镜像名]:[标签]      <span class="comment"># 拉取镜像</span></span><br><span class="line">│   ├── docker images                    <span class="comment"># 列出本地镜像</span></span><br><span class="line">│   ├── docker rmi [镜像ID/名]          <span class="comment"># 删除镜像</span></span><br><span class="line">│   ├── docker build -t [镜像名] [路径]  <span class="comment"># 构建镜像</span></span><br><span class="line">│   ├── docker tag [旧名] [新名]        <span class="comment"># 给镜像打新标签</span></span><br><span class="line">│   └── docker save -o [文件.tar] [镜像] <span class="comment"># 导出镜像</span></span><br><span class="line">│</span><br><span class="line">├── 容器生命周期 (Container Lifecycle)</span><br><span class="line">│   ├── docker run [选项] [镜像] [命令]  <span class="comment"># 创建并启动容器</span></span><br><span class="line">│   │   ├── -d                          <span class="comment"># 后台运行 (守护进程)</span></span><br><span class="line">│   │   ├── -it                         <span class="comment"># 交互式终端 (-i 交互式 -t 伪终端)</span></span><br><span class="line">│   │   ├── --name [容器名]             <span class="comment"># 指定容器名称</span></span><br><span class="line">│   │   ├── -p [主机端口]:[容器端口]     <span class="comment"># 端口映射</span></span><br><span class="line">│   │   └── -v [主机路径]:[容器路径]     <span class="comment"># 数据卷挂载</span></span><br><span class="line">│   │</span><br><span class="line">│   ├── docker start [容器]             <span class="comment"># 启动已停止的容器</span></span><br><span class="line">│   ├── docker stop [容器]              <span class="comment"># 停止运行中的容器 (SIGTERM)</span></span><br><span class="line">│   ├── docker restart [容器]           <span class="comment"># 重启容器</span></span><br><span class="line">│   ├── docker <span class="built_in">rm</span> [容器]                <span class="comment"># 删除已停止的容器</span></span><br><span class="line">│   │   └── -f                          <span class="comment"># 强制删除 (包括运行中的)</span></span><br><span class="line">│   ├── docker pause/unpause [容器]     <span class="comment"># 暂停/恢复容器进程</span></span><br><span class="line">│   └── docker create [选项] [镜像]      <span class="comment"># 只创建不启动容器</span></span><br><span class="line">│</span><br><span class="line">├── 容器查询与操作 (Container Inspection &amp; Operations)</span><br><span class="line">│   ├── docker ps                       <span class="comment"># 查看运行中的容器</span></span><br><span class="line">│   │   └── -a                         <span class="comment"># 查看所有容器（包括已停止）</span></span><br><span class="line">│   ├── docker logs [容器]              <span class="comment"># 查看容器日志</span></span><br><span class="line">│   │   └── -f                         <span class="comment"># 实时跟踪日志</span></span><br><span class="line">│   ├── docker <span class="built_in">exec</span> [选项] [容器] [命令] <span class="comment"># 在运行中的容器内执行命令</span></span><br><span class="line">│   │   └── -it                        <span class="comment"># 交互式模式 (常用：docker exec -it bash)</span></span><br><span class="line">│   ├── docker inspect [容器/镜像]      <span class="comment"># 查看详细信息（JSON格式）</span></span><br><span class="line">│   ├── docker stats [容器]             <span class="comment"># 实时查看容器资源使用情况</span></span><br><span class="line">│   └── docker top [容器]               <span class="comment"># 查看容器内运行的进程</span></span><br><span class="line">│</span><br><span class="line">├── 数据卷管理 (Volumes)</span><br><span class="line">│   ├── docker volume <span class="built_in">ls</span>                <span class="comment"># 列出数据卷</span></span><br><span class="line">│   ├── docker volume create [卷名]     <span class="comment"># 创建数据卷</span></span><br><span class="line">│   ├── docker volume inspect [卷名]    <span class="comment"># 查看数据卷详情</span></span><br><span class="line">│   ├── docker volume <span class="built_in">rm</span> [卷名]        <span class="comment"># 删除数据卷</span></span><br><span class="line">│   └── docker volume prune            <span class="comment"># 清理未被使用的数据卷</span></span><br><span class="line">│</span><br><span class="line">├── 网络管理 (Networks)</span><br><span class="line">│   ├── docker network <span class="built_in">ls</span>              <span class="comment"># 列出网络</span></span><br><span class="line">│   ├── docker network create [网络名]  <span class="comment"># 创建网络</span></span><br><span class="line">│   ├── docker network inspect [网络名] <span class="comment"># 查看网络详情（如连接的容器）</span></span><br><span class="line">│   ├── docker network connect [网络] [容器] <span class="comment"># 将容器连接到网络</span></span><br><span class="line">│   ├── docker network disconnect [网络] [容器] <span class="comment"># 将容器从网络断开</span></span><br><span class="line">│   └── docker network <span class="built_in">rm</span> [网络名]      <span class="comment"># 删除网络</span></span><br><span class="line">│</span><br><span class="line">├── Docker Compose (容器编排)</span><br><span class="line">│   ├── docker compose up              <span class="comment"># 创建并启动所有服务</span></span><br><span class="line">│   │   ├── -d                         <span class="comment"># 后台运行</span></span><br><span class="line">│   │   └── --build                    <span class="comment"># 启动前重新构建镜像</span></span><br><span class="line">│   ├── docker compose down            <span class="comment"># 停止并删除所有容器、网络</span></span><br><span class="line">│   ├── docker compose ps              <span class="comment"># 列出 compose 项目中的容器</span></span><br><span class="line">│   ├── docker compose logs [服务名]    <span class="comment"># 查看服务的日志</span></span><br><span class="line">│   │   └── -f                         <span class="comment"># 实时跟踪日志</span></span><br><span class="line">│   ├── docker compose <span class="built_in">exec</span> [服务名] [命令] <span class="comment"># 在服务容器中执行命令</span></span><br><span class="line">│   ├── docker compose stop            <span class="comment"># 停止服务，不删除容器</span></span><br><span class="line">│   ├── docker compose start           <span class="comment"># 启动已停止的服务</span></span><br><span class="line">│   ├── docker compose restart         <span class="comment"># 重启服务</span></span><br><span class="line">│   ├── docker compose build           <span class="comment"># 构建或重新构建服务镜像</span></span><br><span class="line">│   └── docker compose pull            <span class="comment"># 拉取服务依赖的镜像</span></span><br><span class="line">│</span><br><span class="line">└── 系统清理与信息 (System &amp; Cleanup)</span><br><span class="line">    ├── docker system <span class="built_in">df</span>               <span class="comment"># 查看磁盘使用情况（镜像、容器、卷）</span></span><br><span class="line">    ├── docker system prune            <span class="comment"># 清理所有未使用的资源</span></span><br><span class="line">    │   ├── -a                         <span class="comment"># 同时清理未使用的镜像</span></span><br><span class="line">    │   └── --volumes                  <span class="comment"># 同时清理未使用的数据卷（谨慎！）</span></span><br><span class="line">    └── docker version                 <span class="comment"># 显示 Docker 版本信息</span></span><br><span class="line">    └── docker info                    <span class="comment"># 显示系统范围的详细信息</span></span><br></pre></td></tr></table></figure><p>Docker基础命令关系：</p><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog_imgimage-20251019191540957.png" alt="image-20251019191540957"></p><h2 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h2><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog_imgimage-20251019191619185.png" alt="image-20251019191619185"></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Docker </tag>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatisPlus</title>
      <link href="/2025/10/18/MyBatisPlus_Stream%E6%B5%81_Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2025/10/18/MyBatisPlus_Stream%E6%B5%81_Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="MybatisPlus"><a href="#MybatisPlus" class="headerlink" title="MybatisPlus"></a>MybatisPlus</h1><h2 id="MP引入"><a href="#MP引入" class="headerlink" title="MP引入"></a>MP引入</h2><p>Mp的使用：</p><p>1.mapper层：继承BasMapper接口</p><p>2.service层：service接口实现IService接口，service实现类继承IServiceImpl实现类</p><p>Mp将实体类和数据库表明对应的约定：</p><ul><li>MybatisPlus会把PO实体的类名驼峰转下划线作为表名</li><li>MybatisPlus会把PO实体的所有变量名驼峰转下划线作为表的字段名，并根据变量类型推断字段类型</li><li>MybatisPlus会把名为id的字段作为主键</li></ul><p>常见注解：</p><p>@TableName 当实体类名称和数据库名称不一致时，使用该注解可以指定实体类对应的数据库表名</p><p>@TableId 一个作用是指定id，另一个作用是规定id的增长逻辑，没有指定默认是雪花算法：</p><table><thead><tr><th align="left"><strong>值</strong></th><th align="left"><strong>描述</strong></th></tr></thead><tbody><tr><td align="left">AUTO</td><td align="left">数据库 ID 自增</td></tr><tr><td align="left">NONE</td><td align="left">无状态，该类型为未设置主键类型（注解里等于跟随全局，全局里约等于 INPUT）</td></tr><tr><td align="left">INPUT</td><td align="left">insert 前自行 set 主键值</td></tr><tr><td align="left">ASSIGN_ID</td><td align="left">分配 ID(主键类型为 Number(Long 和 Integer)或 String)(since 3.3.0),使用接口IdentifierGenerator的方法nextId(默认实现类为DefaultIdentifierGenerator雪花算法)</td></tr><tr><td align="left">ASSIGN_UUID</td><td align="left">分配 UUID,主键类型为 String(since 3.3.0),使用接口IdentifierGenerator的方法nextUUID(默认 default 方法)</td></tr></tbody></table><p>@TableField 指定字段名，当类中某个属性并不在表中的时候，通过 exist 参数设置为 false <strong>来排除在外</strong>,注意必须这么做，不然会报错</p><h2 id="MP核心功能"><a href="#MP核心功能" class="headerlink" title="MP核心功能"></a>MP核心功能</h2><h3 id="条件构造器"><a href="#条件构造器" class="headerlink" title="条件构造器"></a>条件构造器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">AbstractWrapper</span><br><span class="line">    ├── QueryWrapper (查询条件封装)</span><br><span class="line">    ├── UpdateWrapper (更新条件封装)</span><br><span class="line">    └── LambdaWrapper</span><br><span class="line">        ├── LambdaQueryWrapper (Lambda语法查询)</span><br><span class="line">        └── LambdaUpdateWrapper (Lambda语法更新)</span><br></pre></td></tr></table></figure><ul><li><strong>链式调用</strong>：支持链式编程，代码更简洁</li><li><strong>Lambda支持</strong>：避免字段名硬编码，编译时检查</li><li><strong>防SQL注入</strong>：自动处理参数，防止SQL注入</li><li><strong>多条件组合</strong>：支持AND、OR等复杂逻辑组合</li></ul><h4 id="Query-Wrapper"><a href="#Query-Wrapper" class="headerlink" title="Query Wrapper"></a>Query Wrapper</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">testQueryWrapper</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//构造查询条件，传入泛型</span></span><br><span class="line">    QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;User&gt;()</span><br><span class="line">            .select(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;username&quot;</span>, <span class="string">&quot;info&quot;</span>, <span class="string">&quot;balance&quot;</span>)</span><br><span class="line">            .like(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;o&quot;</span>)</span><br><span class="line">            .ge(<span class="string">&quot;balance&quot;</span>, <span class="number">1000</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这里什么也不用干，因为selectList(wrapper)也是MP定义好的，是mapper层继承自BaseMapper获得的方法</span></span><br><span class="line">    List&lt;User&gt; userList = userMapper.selectList(wrapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="UpdateWrapper"><a href="#UpdateWrapper" class="headerlink" title="UpdateWrapper"></a>UpdateWrapper</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">testUpdateWrapper</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这句代码利用 Java 9 的 List.of() 工厂方法创建了一个包含 1L、2L 和 4L 这三个 Long 类型元素的不可变列表 ids</span></span><br><span class="line">    List&lt;Long&gt; ids = List.of(<span class="number">1L</span>,<span class="number">2L</span>,<span class="number">3L</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">Integer</span> <span class="variable">fangzhuru</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//构造更新条件</span></span><br><span class="line">    UpdateWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">UpdateWrapper</span>()</span><br><span class="line">        <span class="comment">//set(&quot;balance&quot;, 100)会将余额直接覆盖为 100，而不是在现有值基础上增加 100</span></span><br><span class="line">        .setSql(<span class="string">&quot;balance = balance - &#123;0&#125;&quot;</span>,fangzhuru)  <span class="comment">//setSql直接拼接set语句  &#123;0&#125;,&#123;1&#125;...是MP的占位符</span></span><br><span class="line">        .in(<span class="string">&quot;id&quot;</span>,ids);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//第一个参数 null 表示不使用实体对象的字段进行更新，而是完全依赖于 UpdateWrapper 中设置的条件和 setSql 语句</span></span><br><span class="line">    userMapper.update(<span class="literal">null</span>,wrapper);</span><br><span class="line">    <span class="comment">//如果这里没有用setSql，而是用简单的更新一个balance为user对象中现成的属性值的话，第一个参数就传入User，如：</span></span><br><span class="line">   userMapper.update(User,<span class="keyword">new</span> <span class="title class_">UpdateWrapper</span>&lt;User&gt;().in(<span class="string">&quot;id&quot;</span>,ids));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="LambdaQueryWrapper"><a href="#LambdaQueryWrapper" class="headerlink" title="LambdaQueryWrapper"></a>LambdaQueryWrapper</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//利用lambda表达式将quarymapper改造如下：</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testLambdaQueryWrapper</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.构建条件 WHERE username LIKE &quot;%o%&quot; AND balance &gt;= 1000</span></span><br><span class="line">    QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    wrapper.lambda()</span><br><span class="line">            .select(User::getId, User::getUsername, User::getInfo, User::getBalance)</span><br><span class="line">            .like(User::getUsername, <span class="string">&quot;o&quot;</span>)</span><br><span class="line">            .ge(User::getBalance, <span class="number">1000</span>);</span><br><span class="line">    <span class="comment">// 2.查询</span></span><br><span class="line">    List&lt;User&gt; users = userMapper.selectList(wrapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义Sql"><a href="#自定义Sql" class="headerlink" title="自定义Sql"></a>自定义Sql</h3><p>上面的案例中的Update那里的setSql方法实际上是在service层写了Sql语句，这是不符合规范的</p><p>但是，我们的<strong>目的是使用IService中的好用条件语句</strong>，所以我们可以这么做：</p><p>把条件语句封装到wrapper中，然后<strong>传递</strong>下去：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//service层：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testUpdateWrapper</span><span class="params">()</span>&#123;</span><br><span class="line">    List&lt;Long&gt; ids = List.of(<span class="number">1L</span>,<span class="number">2L</span>,<span class="number">3L</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//封装一个查询wrapper</span></span><br><span class="line">    QueryWrapper&lt;User&gt; QueryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span></span><br><span class="line">        .in(<span class="string">&quot;id&quot;</span>,ids);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//调用mapper层我们自己的自定义方法</span></span><br><span class="line">    List&lt;User&gt; userList = userMapper.deductBalanceByIds(<span class="number">200</span>,wrapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mapper层</span></span><br><span class="line"><span class="comment">//我们的自定义方法</span></span><br><span class="line"><span class="meta">@Update(&quot;update user set balance = balance - #&#123;money&#125; $&#123;ew.customWrapperSegment&#125;&quot;)</span> <span class="comment">//刀乐符及以后的语法硬性约定</span></span><br><span class="line">List&lt;User&gt; <span class="title function_">deductBalanceByIds</span><span class="params">(<span class="meta">@Param(&quot;money&quot;)</span>Integer money, <span class="meta">@Param(&quot;ew&quot;)</span> QueryWrapper&lt;User&gt; QueryWrapper)</span>; <span class="comment">//ew 硬性约定</span></span><br></pre></td></tr></table></figure><h4 id="多表联查"><a href="#多表联查" class="headerlink" title="多表联查"></a>多表联查</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设有用户表和地址表，我们要查用户id在一定范围内，且地址在某一处的用户</span></span><br><span class="line"><span class="comment">//service层</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testJoinWrapper</span><span class="params">()</span>&#123;</span><br><span class="line">    List&lt;Long&gt; ids = List.of(<span class="number">1L</span>,<span class="number">2L</span>,<span class="number">3L</span>); </span><br><span class="line">QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>()</span><br><span class="line">        .in(<span class="string">&quot;u.id&quot;</span>,ids);</span><br><span class="line">    .eq(<span class="string">&quot;a.city&quot;</span>,<span class="string">&quot;北京&quot;</span>);</span><br><span class="line">    List&lt;User&gt; userlist = userMapper.getUsersByIdAndAddress(wrapper);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//mapper层</span></span><br><span class="line"><span class="meta">@Select(&quot;Select u.* from user u Left join address a on a.user_id = u.id $&#123;ew.customWrapperSegment&#125;&quot;)</span></span><br><span class="line">List&lt;User&gt; <span class="title function_">getUsersByIdAndAddress</span> <span class="params">(<span class="meta">@Param(&quot;ew&quot;)</span>QueryWrapper&lt;User&gt; QueryWrapper)</span>;</span><br></pre></td></tr></table></figure><h3 id="Service接口"><a href="#Service接口" class="headerlink" title="Service接口"></a>Service接口</h3><p>service接口可以让很多简单的单表curd，直接在controller里就能完成</p><h4 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h4><p>直接看例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//未使用Lambda</span></span><br><span class="line"><span class="keyword">public</span> List&lt;UserVO&gt; <span class="title function_">queryUsers</span><span class="params">(UserQuery query)</span>&#123;</span><br><span class="line">    <span class="comment">// 1.组织条件</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> query.getName();</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">status</span> <span class="operator">=</span> query.getStatus();</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">minBalance</span> <span class="operator">=</span> query.getMinBalance();</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">maxBalance</span> <span class="operator">=</span> query.getMaxBalance();</span><br><span class="line">    LambdaQueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;User&gt;().lambda()</span><br><span class="line">            .like(username != <span class="literal">null</span>, User::getUsername, username)</span><br><span class="line">            .eq(status != <span class="literal">null</span>, User::getStatus, status)</span><br><span class="line">            .ge(minBalance != <span class="literal">null</span>, User::getBalance, minBalance)</span><br><span class="line">            .le(maxBalance != <span class="literal">null</span>, User::getBalance, maxBalance);</span><br><span class="line">    <span class="comment">// 2.查询用户</span></span><br><span class="line">    List&lt;User&gt; users = userService.list(wrapper);</span><br><span class="line">    <span class="comment">// 3.处理vo</span></span><br><span class="line">    <span class="keyword">return</span> BeanUtil.copyToList(users, UserVO.class);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"> <span class="comment">//使用Lambda</span></span><br><span class="line"><span class="keyword">public</span> List&lt;UserVO&gt; <span class="title function_">queryUsers</span><span class="params">(UserQuery query)</span>&#123;</span><br><span class="line">    <span class="comment">// 1.组织条件</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> query.getName();</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">status</span> <span class="operator">=</span> query.getStatus();</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">minBalance</span> <span class="operator">=</span> query.getMinBalance();</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">maxBalance</span> <span class="operator">=</span> query.getMaxBalance();</span><br><span class="line">    <span class="comment">// 2.查询用户</span></span><br><span class="line">    List&lt;User&gt; users = userService.lambdaQuery()</span><br><span class="line">            .like(username != <span class="literal">null</span>, User::getUsername, username)</span><br><span class="line">            .eq(status != <span class="literal">null</span>, User::getStatus, status)</span><br><span class="line">            .ge(minBalance != <span class="literal">null</span>, User::getBalance, minBalance)</span><br><span class="line">            .le(maxBalance != <span class="literal">null</span>, User::getBalance, maxBalance)</span><br><span class="line">            .list();</span><br><span class="line">    <span class="comment">// 3.处理vo</span></span><br><span class="line">    <span class="keyword">return</span> BeanUtil.copyToList(users, UserVO.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子可以看出，lambda省略了自定义wrapper和调用service查询接口传入wrapper的过程</p><p>直接用IService接口中的lambdaQuery方法，最后一个.list()把返回值也获得了</p><p>得到结果的一步不仅可以用<code>list()</code>，可选的方法有：</p><ul><li><code>.one()</code>：最多1个结果</li><li><code>.list()</code>：返回集合结果</li><li><code>.count()</code>：返回计数结果</li></ul><p>MybatisPlus会根据链式编程的最后一个方法来判断最终的返回结果</p><h3 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a>批处理</h3><p>在jdbc的url后面添加参数<code>&amp;rewriteBatchedStatements=true</code></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://127.0.0.1:3306/mp?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;serverTimezone=Asia/Shanghai&amp;rewriteBatchedStatements=true</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">MySQL123</span></span><br></pre></td></tr></table></figure><h2 id="扩展功能"><a href="#扩展功能" class="headerlink" title="扩展功能"></a>扩展功能</h2><h3 id="静态工具"><a href="#静态工具" class="headerlink" title="静态工具"></a>静态工具</h3><p>service之间如果相互调用，就可能出现问题（也可以通过@Lazy注解解决）</p><p>MybatisPlus提供一个静态工具类：Db，其中的一些静态方法与 IService 中方法签名基本一致</p><p>相比于使用IService接口中的方法，使用Db中的方法不同之处就在于，要多传入一个参数：目标实体对象的类的字节码，因为静态方法不知道你要用哪个类来和数据库映射</p><h3 id="逻辑删除"><a href="#逻辑删除" class="headerlink" title="逻辑删除"></a>逻辑删除</h3><p>对于一些比较重要的数据，我们往往会采用逻辑删除的方案，即：</p><ul><li>在表中添加一个字段标记数据是否被删除</li><li>当删除数据时把标记置为true</li><li>查询时过滤掉标记为true的数据</li><li><strong>注意</strong>，只有MybatisPlus生成的SQL语句才支持自动的逻辑删除，自定义SQL需要自己手动处理逻辑删除</li></ul><p>在application.yml中加入以下配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">logic-delete-field:</span> <span class="string">deleted</span> <span class="comment"># 全局逻辑删除的实体字段名(since 3.3.0,配置后可以忽略不配置步骤2)</span></span><br><span class="line">      <span class="attr">logic-delete-value:</span> <span class="number">1</span> <span class="comment"># 逻辑已删除值(默认为 1)</span></span><br><span class="line">      <span class="attr">logic-not-delete-value:</span> <span class="number">0</span> <span class="comment"># 逻辑未删除值(默认为 0)</span></span><br></pre></td></tr></table></figure><h3 id="通用枚举"><a href="#通用枚举" class="headerlink" title="通用枚举"></a>通用枚举</h3><p>定义一个枚举：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.mp.enums;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.EnumValue;</span><br><span class="line"><span class="keyword">import</span> lombok.Getter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">UserStatus</span> &#123;</span><br><span class="line">    NORMAL(<span class="number">1</span>, <span class="string">&quot;正常&quot;</span>),</span><br><span class="line">    FREEZE(<span class="number">2</span>, <span class="string">&quot;冻结&quot;</span>)</span><br><span class="line">    ;</span><br><span class="line">    <span class="meta">@EnumValue</span> <span class="comment">//使用这个注解告诉MP用int value字段和数据库匹配</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> value;</span><br><span class="line">    <span class="meta">@JsonValue</span> <span class="comment">//使用这个注解，就可以让VO对象在json序列化的时候，使用这个String desc字段</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String desc;</span><br><span class="line"></span><br><span class="line">    UserStatus(<span class="type">int</span> value, String desc) &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">        <span class="built_in">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以把用户类中的status字段的类型由Integer改为 UserStatus ，更加直观</p><p>那么如何让MP能把数据库中的实际类型为整数的status和枚举类型对上？</p><p>第一步：在枚举类型中使用注解：@EnumValue，标注的属性是实际和数据库相匹配的属性</p><p>第二部，配置枚举处理器，依旧添加application.yml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="attr">default-enum-type-handler:</span> <span class="string">com.baomidou.mybatisplus.core.handlers.MybatisEnumTypeHandler</span></span><br></pre></td></tr></table></figure><p>同时，我们也可以把返回值VO中的status字段也改成枚举类型，那么在实际返回的时候，如何指定json序列化时，使用的实际属性？</p><p>使用 @JsonValue 注解，（这个注解是springmvc的，不是MP的）</p><h3 id="JSON类型处理器"><a href="#JSON类型处理器" class="headerlink" title="JSON类型处理器"></a>JSON类型处理器</h3><p>假设现在user表中有一个info字段，是json类型，user中却是String类型，那拆分数据就会很麻烦</p><p>MP提供了json类型处理器：</p><p>第一步，我们自己定义一个实体类UserInfo，属性和json字段相对应</p><p>第二步，把user类中的info字段改为UserInfo类型的，并加上注解 <strong>@TableField(typeHandler &#x3D; JacksonTypeHandler.class)</strong></p><p>第三步，在user类上加一个注解，声明自动映射 @TableName(value &#x3D; “user”, autoResultMap &#x3D; true)</p><h2 id="插件功能"><a href="#插件功能" class="headerlink" title="插件功能"></a>插件功能</h2><h3 id="分页插件"><a href="#分页插件" class="headerlink" title="分页插件"></a>分页插件</h3><p>自定义一个配置类，配置分页插件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.mp.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.DbType;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化核心插件</span></span><br><span class="line">        <span class="type">MybatisPlusInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">        <span class="comment">// 添加分页插件</span></span><br><span class="line">        interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">PaginationInnerInterceptor</span>(DbType.MYSQL));</span><br><span class="line">        <span class="keyword">return</span> interceptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个过程相当于有两层，注入了一个MP的拦截器总对象，这个总对象还可以add小对象，这里就是add了一个分页插件对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">pageNo</span> <span class="operator">=</span> <span class="number">1</span>, pageSize = <span class="number">5</span>;</span><br><span class="line"><span class="comment">// 分页参数</span></span><br><span class="line">Page&lt;User&gt; page = Page.of(pageNo, pageSize);  </span><br><span class="line"><span class="comment">// 排序参数, 通过OrderItem来指定</span></span><br><span class="line">page.addOrder(<span class="keyword">new</span> <span class="title class_">OrderItem</span>(<span class="string">&quot;balance&quot;</span>, <span class="literal">false</span>));</span><br><span class="line"></span><br><span class="line">userService.page(page);  <span class="comment">//page方法直接修改参数对象</span></span><br></pre></td></tr></table></figure><h3 id="通用分页实体"><a href="#通用分页实体" class="headerlink" title="通用分页实体"></a>通用分页实体</h3><p>pageQuery：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.mp.domain.query;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.metadata.OrderItem;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.plugins.pagination.Page;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PageQuery</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer pageNo;</span><br><span class="line">    <span class="keyword">private</span> Integer pageSize;</span><br><span class="line">    <span class="keyword">private</span> String sortBy;</span><br><span class="line">    <span class="keyword">private</span> Boolean isAsc;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt;  Page&lt;T&gt; <span class="title function_">toMpPage</span><span class="params">(OrderItem ... orders)</span>&#123;</span><br><span class="line">        <span class="comment">// 1.分页条件</span></span><br><span class="line">        Page&lt;T&gt; p = Page.of(pageNo, pageSize);</span><br><span class="line">        <span class="comment">// 2.排序条件</span></span><br><span class="line">        <span class="comment">// 2.1.先看前端有没有传排序字段</span></span><br><span class="line">        <span class="keyword">if</span> (sortBy != <span class="literal">null</span>) &#123;</span><br><span class="line">            p.addOrder(<span class="keyword">new</span> <span class="title class_">OrderItem</span>(sortBy, isAsc));</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.2.再看有没有手动指定排序字段</span></span><br><span class="line">        <span class="keyword">if</span>(orders != <span class="literal">null</span>)&#123;</span><br><span class="line">            p.addOrder(orders);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; Page&lt;T&gt; <span class="title function_">toMpPage</span><span class="params">(String defaultSortBy, <span class="type">boolean</span> isAsc)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.toMpPage(<span class="keyword">new</span> <span class="title class_">OrderItem</span>(defaultSortBy, isAsc));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; Page&lt;T&gt; <span class="title function_">toMpPageDefaultSortByCreateTimeDesc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> toMpPage(<span class="string">&quot;create_time&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; Page&lt;T&gt; <span class="title function_">toMpPageDefaultSortByUpdateTimeDesc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> toMpPage(<span class="string">&quot;update_time&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>pageDTO：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.mp.domain.dto;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.hutool.core.bean.BeanUtil;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.plugins.pagination.Page;</span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PageDTO</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> Long total;</span><br><span class="line">    <span class="keyword">private</span> Long pages;</span><br><span class="line">    <span class="keyword">private</span> List&lt;V&gt; list;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回空分页结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> p MybatisPlus的分页结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;V&gt; 目标VO类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;P&gt; 原始PO类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> VO的分页对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;V, P&gt; PageDTO&lt;V&gt; <span class="title function_">empty</span><span class="params">(Page&lt;P&gt; p)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PageDTO</span>&lt;&gt;(p.getTotal(), p.getPages(), Collections.emptyList());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将MybatisPlus分页结果转为 VO分页结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> p MybatisPlus的分页结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> voClass 目标VO类型的字节码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;V&gt; 目标VO类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;P&gt; 原始PO类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> VO的分页对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;V, P&gt; PageDTO&lt;V&gt; <span class="title function_">of</span><span class="params">(Page&lt;P&gt; p, Class&lt;V&gt; voClass)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.非空校验</span></span><br><span class="line">        List&lt;P&gt; records = p.getRecords();</span><br><span class="line">        <span class="keyword">if</span> (records == <span class="literal">null</span> || records.size() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 无数据，返回空结果</span></span><br><span class="line">            <span class="keyword">return</span> empty(p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.数据转换</span></span><br><span class="line">        List&lt;V&gt; vos = BeanUtil.copyToList(records, voClass);</span><br><span class="line">        <span class="comment">// 3.封装返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PageDTO</span>&lt;&gt;(p.getTotal(), p.getPages(), vos);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将MybatisPlus分页结果转为 VO分页结果，允许用户自定义PO到VO的转换方式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> p MybatisPlus的分页结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> convertor PO到VO的转换函数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;V&gt; 目标VO类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;P&gt; 原始PO类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> VO的分页对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;V, P&gt; PageDTO&lt;V&gt; <span class="title function_">of</span><span class="params">(Page&lt;P&gt; p, Function&lt;P, V&gt; convertor)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.非空校验</span></span><br><span class="line">        List&lt;P&gt; records = p.getRecords();</span><br><span class="line">        <span class="keyword">if</span> (records == <span class="literal">null</span> || records.size() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 无数据，返回空结果</span></span><br><span class="line">            <span class="keyword">return</span> empty(p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.数据转换</span></span><br><span class="line">        List&lt;V&gt; vos = records.stream().map(convertor).collect(Collectors.toList());</span><br><span class="line">        <span class="comment">// 3.封装返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PageDTO</span>&lt;&gt;(p.getTotal(), p.getPages(), vos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>业务层便可简化为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> PageDTO&lt;UserVO&gt; <span class="title function_">queryUserByPage</span><span class="params">(PageQuery query)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.构建条件</span></span><br><span class="line">    Page&lt;User&gt; page = query.toMpPageDefaultSortByCreateTimeDesc();</span><br><span class="line">    <span class="comment">// 2.查询</span></span><br><span class="line">    page(page);</span><br><span class="line">    <span class="comment">// 3.封装返回</span></span><br><span class="line">    <span class="keyword">return</span> PageDTO.of(page, UserVO.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义最后到vo的转换过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> PageDTO&lt;UserVO&gt; <span class="title function_">queryUserByPage</span><span class="params">(PageQuery query)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.构建条件</span></span><br><span class="line">    Page&lt;User&gt; page = query.toMpPageDefaultSortByCreateTimeDesc();</span><br><span class="line">    <span class="comment">// 2.查询</span></span><br><span class="line">    page(page);</span><br><span class="line">    <span class="comment">// 3.封装返回</span></span><br><span class="line">    <span class="keyword">return</span> PageDTO.of(page, user -&gt; &#123;</span><br><span class="line">        <span class="comment">// 拷贝属性到VO</span></span><br><span class="line">        <span class="type">UserVO</span> <span class="variable">vo</span> <span class="operator">=</span> BeanUtil.copyProperties(user, UserVO.class);</span><br><span class="line">        <span class="comment">// 用户名脱敏</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> vo.getUsername();</span><br><span class="line">        vo.setUsername(username.substring(<span class="number">0</span>, username.length() - <span class="number">2</span>) + <span class="string">&quot;**&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> vo;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流"></a>Stream流</h1><h1 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h1>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 微服务 </tag>
            
            <tag> MybatisPlus </tag>
            
            <tag> Stream流 </tag>
            
            <tag> Lambda表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GORM</title>
      <link href="/2025/09/15/GORM/"/>
      <url>/2025/09/15/GORM/</url>
      
        <content type="html"><![CDATA[<h1 id="GORM"><a href="#GORM" class="headerlink" title="GORM"></a>GORM</h1><h2 id="快速使用"><a href="#快速使用" class="headerlink" title="快速使用"></a>快速使用</h2><p>导包</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;gorm.io/driver/mysql&quot;</span></span><br><span class="line">  <span class="string">&quot;gorm.io/gorm&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="模型相关"><a href="#模型相关" class="headerlink" title="模型相关"></a>模型相关</h3><p>一言以蔽之，GORM中，使用模型<strong>所实现的效果</strong>，就相当于 Java Mybatis 中，自动把对象中的属性变成 数据库字段 &#x2F;把数据库字段变成属性</p><h4 id="名称相关"><a href="#名称相关" class="headerlink" title="名称相关"></a>名称相关</h4><ol><li>属性名 &#x2F; 字段名</li></ol><p>GORM中也实现了 结构体字段驼峰命名 &lt;——&gt; 数据库字段 小写+下划线 命名的相互转化</p><p>如果结构体中的命名和数据库字段命名不只是这种差异，则默认无法映射</p><p>在Java中，对于这样的字段我们使用@Param注解，而在go中，我们为结构体参数配置Tag：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CreateTime <span class="type">int64</span> <span class="string">`gorm:&quot;column:createtime&quot;`</span> <span class="comment">//必须把column加上</span></span><br></pre></td></tr></table></figure><p>而go的Tag还不止这一个作用，因为gorm还可以创建表，所以后面还可以跟建表属性</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gorm:<span class="string">&quot;column:id; PRIMARY_KEY&quot;</span></span><br></pre></td></tr></table></figure><p>此外，有的时候结构体和数据库并不是完全一样的，这时候就可以借助权限控制：（虽然不用默认也不报错）</p><table><thead><tr><th><code>&lt;-</code></th><th>允许字段被写入（默认值：<code>create,update</code>）</th><th><code>gorm:&quot;&lt;-:create&quot;</code>（仅允许创建时写入）</th></tr></thead><tbody><tr><td><code>&lt;-:create</code></td><td><strong>只写</strong>（仅在创建时允许写入）</td><td><code>Password string gorm:&quot;&lt;-:create&quot;</code></td></tr><tr><td><code>&lt;-:update</code></td><td><strong>只写</strong>（仅在更新时允许写入）</td><td><code>Token string gorm:&quot;&lt;-:update&quot;</code></td></tr><tr><td><code>&lt;-:false</code></td><td><strong>禁止写入</strong>（完全不可修改）</td><td><code>CreatedAt time.Time gorm:&quot;&lt;-:false&quot;</code></td></tr><tr><td><code>-&gt;</code></td><td>允许字段被读取（默认值：<code>true</code>）</td><td><code>gorm:&quot;-&gt;:false&quot;</code>（禁止读取）</td></tr><tr><td><code>-&gt;:false</code></td><td><strong>只写字段</strong>（可存入数据库，但查询时不返回）</td><td><code>Secret string gorm:&quot;-&gt;:false&quot;</code></td></tr><tr><td><code>-</code></td><td><strong>完全忽略</strong>（不参与读写和迁移）</td><td><code>TempField string gorm:&quot;-&quot;</code></td></tr></tbody></table><h4 id="自带时间更新"><a href="#自带时间更新" class="headerlink" title="自带时间更新"></a>自带时间更新</h4><p>GORM 自带一个结构体长这样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gorm.Model 的定义</span></span><br><span class="line"><span class="keyword">type</span> Model <span class="keyword">struct</span> &#123;</span><br><span class="line">  ID        <span class="type">uint</span>           <span class="string">`gorm:&quot;primaryKey&quot;`</span></span><br><span class="line">  CreatedAt time.Time</span><br><span class="line">  UpdatedAt time.Time</span><br><span class="line">  DeletedAt gorm.DeletedAt <span class="string">`gorm:&quot;index&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们想使用的话直接把他嵌入我们自己的结构体即可</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  gorm.Model <span class="comment">// 嵌入gorm.Model的字段</span></span><br><span class="line">  Name <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GORM 约定使用 CreatedAt、UpdatedAt 追踪创建&#x2F;更新时间。如果定义了这种字段，GORM 在创建、更新时会自动填充当前时间，要使用不同名称的字段，可以用tag自己指定配置 autoCreateTime、autoUpdateTime 标签</p><h2 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h2><h3 id="DSN格式："><a href="#DSN格式：" class="headerlink" title="DSN格式："></a>DSN格式：</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  charset=utf8 客户端字符集为utf8</span></span><br><span class="line"><span class="comment">//  parseTime=true 支持把数据库datetime和date类型转换为golang的time.Time类型</span></span><br><span class="line"><span class="comment">//  loc=Local 使用系统本地时区</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//开发的时候经常需要设置数据库连接超时参数，gorm是通过dsn的timeout参数配置，例如，设置10秒后连接超时，timeout=10s</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// readTimeout - 读超时时间，0代表不限制，writeTimeout - 写超时时间，0代表不限制</span></span><br><span class="line"></span><br><span class="line">root:<span class="number">123456</span>@tcp(localhost:<span class="number">3306</span>)/tizi365?charset=utf8&amp;parseTime=True&amp;loc=Local&amp;timeout=<span class="number">10</span>s&amp;readTimeout=<span class="number">30</span>s&amp;writeTimeout=<span class="number">60</span>s</span><br><span class="line"></span><br><span class="line"><span class="comment">//完整链接示意：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;gorm.io/driver/mysql&quot;</span></span><br><span class="line">  <span class="string">&quot;gorm.io/gorm&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    <span class="comment">//配置MySQL连接参数</span></span><br><span class="line">username := <span class="string">&quot;root&quot;</span>  <span class="comment">//账号</span></span><br><span class="line">password := <span class="string">&quot;123456&quot;</span> <span class="comment">//密码</span></span><br><span class="line">host := <span class="string">&quot;127.0.0.1&quot;</span> <span class="comment">//数据库地址，可以是Ip或者域名</span></span><br><span class="line">port := <span class="number">3306</span> <span class="comment">//数据库端口</span></span><br><span class="line">Dbname := <span class="string">&quot;tizi365&quot;</span> <span class="comment">//数据库名</span></span><br><span class="line">timeout := <span class="string">&quot;10s&quot;</span> <span class="comment">//连接超时，10秒</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//拼接下dsn参数, dsn格式可以参考上面的语法，这里使用Sprintf动态拼接dsn参数，因为一般数据库连接参数，我们都是保存在配置文件里面，需要从配置文件加载参数，然后拼接dsn。</span></span><br><span class="line">dsn := fmt.Sprintf(<span class="string">&quot;%s:%s@tcp(%s:%d)/%s?charset=utf8&amp;parseTime=True&amp;loc=Local&amp;timeout=%s&quot;</span>, username, password, host, port, Dbname, timeout)</span><br><span class="line"><span class="comment">//连接MYSQL, 获得DB类型实例，用于后面的数据库读写操作。</span></span><br><span class="line">db, err := gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;连接数据库失败, error=&quot;</span> + err.Error())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//延时关闭数据库连接</span></span><br><span class="line"><span class="keyword">defer</span> db.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="debug"><a href="#debug" class="headerlink" title="debug"></a>debug</h3><p>直接在语句中加上.Debug() 即可：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result := db.Debug().Where(<span class="string">&quot;username = ?&quot;</span>, <span class="string">&quot;edwardNygma&quot;</span>).First(&amp;u)</span><br></pre></td></tr></table></figure><h3 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个工具包，用来管理gorm数据库连接池的初始化工作。</span></span><br><span class="line"><span class="keyword">package</span> tools</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义全局的db对象，我们执行数据库操作主要通过他实现，这个很像routor 那个返回值，也是指针类型</span></span><br><span class="line"><span class="keyword">var</span> _db *gorm.DB</span><br><span class="line"></span><br><span class="line"><span class="comment">//包初始化函数，golang特性，每个包初始化的时候会自动执行init函数，这里用来初始化gorm。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ...忽略dsn配置，请参考上面例子...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 声明err变量，下面不能使用:=赋值运算符，否则_db变量会当成局部变量，导致外部无法访问_db变量</span></span><br><span class="line">    <span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line">    <span class="comment">//连接MYSQL, 获得DB类型实例，用于后面的数据库读写操作。</span></span><br><span class="line">    _db, err = gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;&#125;) <span class="comment">//open函数返回一个db实例的指针</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;连接数据库失败, error=&quot;</span> + err.Error())</span><br><span class="line">&#125;</span><br><span class="line">     </span><br><span class="line">    sqlDB, _ := _db.DB()</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置数据库连接池参数</span></span><br><span class="line">    sqlDB.SetMaxOpenConns(<span class="number">100</span>)   <span class="comment">//设置数据库连接池最大连接数</span></span><br><span class="line">    sqlDB.SetMaxIdleConns(<span class="number">20</span>)   <span class="comment">//连接池最大允许的空闲连接数，如果没有sql任务需要执行的连接数大于20，超过的连接会被连接池关闭。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取gorm db对象，其他包需要执行数据库查询的时候，只要通过tools.getDB()获取db对象即可。</span></span><br><span class="line"><span class="comment">//不用担心协程并发使用同样的db对象会共用同一个连接，db对象在调用他的方法的时候会从数据库连接池中获取新的连接</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetDB</span><span class="params">()</span></span> *gorm.DB &#123;</span><br><span class="line"><span class="keyword">return</span> _db</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>难以理解的地方</strong>：</p><ol><li><p>ConnPool 是一个接口，同时作为gorm的一个字段</p></li><li><p>*sql.DB 类型实现了 gorm.ConnPool 接口的所有方法</p></li><li><p>.DB()  方法：</p></li></ol>   <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> DB() (*sql.DB, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> db.ConnPool.(*sql.DB) <span class="comment">// 类型断言</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   实际上就是 *<em>通过类型断言从接口字段中提取出具体的  <em>sql.DB 实例</em></em></p><ol start="4"><li><p>因为 sqlDB和 _db.ConnPool指向同一个 *sql.DB 实例，所以通过  sqlDB 修改参数会影响  _db  的所有后续操作</p><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog_imgimage-20250915225753827.png" alt="image-20250915225753827"></p></li></ol><p>使用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="comment">//导入tools包</span></span><br><span class="line"><span class="keyword">import</span> tools</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//获取DB</span></span><br><span class="line">    db := tools.GetDB()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//执行数据库查询操作</span></span><br><span class="line">    u := User&#123;&#125;</span><br><span class="line"><span class="comment">//自动生成sql： SELECT * FROM `users`  WHERE (username = &#x27;tizi365&#x27;) LIMIT 1</span></span><br><span class="line">db.Where(<span class="string">&quot;username = ?&quot;</span>, <span class="string">&quot;tizi365&quot;</span>).First(&amp;u)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>附：<strong>Go 的方法集规则</strong></p><table><thead><tr><th align="center"><strong>接收者类型</strong></th><th align="center"><strong>可调用的方法</strong></th></tr></thead><tbody><tr><td align="center"><code>T</code>（值类型）</td><td align="center">所有 <code>func (t T) Method()</code> 的方法</td></tr><tr><td align="center"><code>*T</code>（指针）</td><td align="center">所有 <code>func (t T) Method()</code> <strong>和</strong> <code>func (t *T) Method()</code> 的方法</td></tr></tbody></table><p><strong>使用连接池技术后，千万不要使用完db后调用db.Close关闭数据库连接，这样会导致整个数据库连接池关闭，导致连接池没有可用的连接</strong></p><h2 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h2><h3 id="单条数据"><a href="#单条数据" class="headerlink" title="单条数据"></a>单条数据</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个用户，并初始化数据</span></span><br><span class="line">u := User&#123;</span><br><span class="line">Username:<span class="string">&quot;tizi365&quot;</span>,</span><br><span class="line">Password:<span class="string">&quot;123456&quot;</span>,</span><br><span class="line">CreateTime:time.Now().Unix(),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入一条用户数据</span></span><br><span class="line"><span class="comment">//下面代码会自动生成SQL语句：INSERT INTO `users` (`username`,`password`,`createtime`) VALUES (&#x27;tizi365&#x27;,&#x27;123456&#x27;,&#x27;1540824823&#x27;)</span></span><br><span class="line"></span><br><span class="line">db.Create(&amp;u)</span><br><span class="line"></span><br><span class="line"><span class="comment">//一般项目中我们会类似下面的写法，通过Error对象检测，插入数据有没有成功，如果没有错误那就是数据写入成功了。</span></span><br><span class="line"><span class="keyword">if</span> err := db.Create(&amp;u).Error; err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;插入失败&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">//gorm 2.0版本以后的，默认会自动返回主键Id值</span></span><br><span class="line">u.ID           <span class="comment">// 返回主键id，默认主键名为ID，也可以通过gorm标签定义</span></span><br><span class="line">u.Error        <span class="comment">// 返回 error</span></span><br><span class="line">u.RowsAffected <span class="comment">// 返回插入记录的条数</span></span><br></pre></td></tr></table></figure><p>如果gorm设置了数据库连接池，那么每次执行数据库查询的时候都会从数据库连接池申请一个数据库连接，那么上述代码必须使用数据库事务，确保插入数据和查询自增id两条sql语句是在同一个数据库连接下执行，否则在高并发场景下，可能会查询不到自增id，或者查询到错误的id</p><h3 id="批量数据"><a href="#批量数据" class="headerlink" title="批量数据"></a>批量数据</h3><p><strong>如果要批量插入数据的话，直接定义切片，依旧传递引用即可，也可以分批插入</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">users := []User&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        Username:   <span class="string">&quot;user1&quot;</span>,</span><br><span class="line">        Password:   <span class="string">&quot;pwd1&quot;</span>,</span><br><span class="line">        CreateTime: time.Now().Unix(),</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        Username:   <span class="string">&quot;user2&quot;</span>,</span><br><span class="line">        Password:   <span class="string">&quot;pwd2&quot;</span>,</span><br><span class="line">        CreateTime: time.Now().Unix(),</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 可以继续添加更多...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 批量插入数据（推荐传递切片指针，保持与单条插入风格一致）</span></span><br><span class="line"><span class="comment">// 技术上允许直接传值（users），但统一传指针(&amp;users)更符合GORM惯例</span></span><br><span class="line">result := db.Create(&amp;users) </span><br><span class="line"></span><br><span class="line"><span class="comment">// 大批量数据建议分批插入（每批100条）</span></span><br><span class="line"><span class="comment">// 注意：CreateInBatches同样支持传值或指针，此处省略&amp;仅为演示两种写法</span></span><br><span class="line">batchSize := <span class="number">100</span></span><br><span class="line">err := db.CreateInBatches(users, batchSize).Error </span><br></pre></td></tr></table></figure><h2 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h2><ol><li>gorm查询数据本质上就是提供一组函数，帮我们快速拼接sql语句，尽量减少编写sql语句的工作量。</li><li>gorm查询结果我们一般都是保存到结构体(struct)变量，所以在执行查询操作之前需要根据自己想要查询的数据定义结构体类型</li><li>gorm库是协程安全的，gorm提供的函数可以并发的在多个协程安全的执行</li></ol><p>gorm查询主要由以下几个部分的函数组成，这些函数可以串起来组合sql语句，使用起来类似编写sql语句的习惯：</p><h3 id="1-query"><a href="#1-query" class="headerlink" title="1.query"></a>1.query</h3><p>执行查询的函数，gorm提供下面几个查询函数：</p><h5 id="Take-——-查询一条记录"><a href="#Take-——-查询一条记录" class="headerlink" title="Take ——&gt; 查询一条记录"></a><strong>Take</strong> ——&gt; 查询一条记录</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义接收查询结果的结构体变量</span></span><br><span class="line">food := Food&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等价于：SELECT * FROM `foods`   LIMIT 1  </span></span><br><span class="line">db.Take(&amp;food)</span><br></pre></td></tr></table></figure><h5 id="First-Last-——-查询一条记录，根据主键ID排序-正序-，返回第一条-最后一条记录"><a href="#First-Last-——-查询一条记录，根据主键ID排序-正序-，返回第一条-最后一条记录" class="headerlink" title="**First **&#x2F; Last ——&gt; 查询一条记录，根据主键ID排序(正序)，返回第一条&#x2F;最后一条记录"></a>**First **&#x2F; Last ——&gt; 查询一条记录，根据主键ID排序(<strong>正序</strong>)，返回第一条&#x2F;最后一条记录</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等价于：SELECT * FROM `foods`   ORDER BY `foods`.`id` ASC LIMIT 1    </span></span><br><span class="line">db.First(&amp;food)</span><br><span class="line"></span><br><span class="line"><span class="comment">//等价于：SELECT * FROM `foods`   ORDER BY `foods`.`id` DESC LIMIT 1    </span></span><br><span class="line">db.Last(&amp;food)</span><br></pre></td></tr></table></figure><h5 id="Find-——-查询多条记录，Find函数返回的是一个数组"><a href="#Find-——-查询多条记录，Find函数返回的是一个数组" class="headerlink" title="Find ——&gt; 查询多条记录，Find函数返回的是一个数组"></a><strong>Find</strong> ——&gt; 查询多条记录，Find函数返回的是一个数组</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等价于：SELECT * FROM `foods`</span></span><br><span class="line">db.Find(&amp;foods)</span><br></pre></td></tr></table></figure><h5 id="Pluck-——-查询一列值"><a href="#Pluck-——-查询一列值" class="headerlink" title="Pluck ——&gt; 查询一列值"></a><strong>Pluck</strong> ——&gt; 查询一列值</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//商品标题数组</span></span><br><span class="line"><span class="keyword">var</span> titles []<span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回所有商品标题</span></span><br><span class="line"><span class="comment">//等价于：SELECT title FROM `foods`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//   1. Model(&amp;Food&#123;&#125;) 通过模型结构体确定表名（foods表）</span></span><br><span class="line"><span class="comment">//   2. Pluck() 将查询结果映射到非结构体变量（如基础类型切片）</span></span><br><span class="line"><span class="comment">//   3. 必须传递 &amp;titles 指针，否则无法回写查询结果</span></span><br><span class="line">db.Model(&amp;Food&#123;&#125;).Pluck(<span class="string">&quot;title&quot;</span>, &amp;titles)</span><br></pre></td></tr></table></figure><h3 id="有关错误处理"><a href="#有关错误处理" class="headerlink" title="有关错误处理"></a>有关错误处理</h3><p>查询不到数据，我们不一定会当成错误处理，有可能数据确实没有，所以要把它（ErrRecordNotFound）分出来</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">err := db.Take(&amp;food).Error</span><br><span class="line"><span class="keyword">if</span> errors.Is(err, gorm.ErrRecordNotFound) &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;查询不到数据&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">//如果err不等于record not found错误，又不等于nil，那说明sql执行失败了。</span></span><br><span class="line">fmt.Println(<span class="string">&quot;查询失败&quot;</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="where"><a href="#where" class="headerlink" title="where"></a>where</h3><p>db.Where(query interface{}, args …interface{})</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等价于: SELECT * FROM `foods`  WHERE (id = &#x27;10&#x27;) LIMIT 1</span></span><br><span class="line"><span class="comment">//这里问号(?), 在执行的时候会被10替代</span></span><br><span class="line">db.Where(<span class="string">&quot;id = ?&quot;</span>, <span class="number">10</span>).Take(&amp;food)</span><br><span class="line"></span><br><span class="line"><span class="comment">// in 语句 </span></span><br><span class="line"><span class="comment">//等价于: SELECT * FROM `foods`  WHERE (id in (&#x27;1&#x27;,&#x27;2&#x27;,&#x27;5&#x27;,&#x27;6&#x27;)) LIMIT 1 </span></span><br><span class="line"><span class="comment">//args参数传递的是数组</span></span><br><span class="line">db.Where(<span class="string">&quot;id in (?)&quot;</span>, []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>&#125;).Take(&amp;food)</span><br><span class="line"></span><br><span class="line"><span class="comment">//等价于: SELECT * FROM `foods`  WHERE (create_time &gt;= &#x27;2018-11-06 00:00:00&#x27; and create_time &lt;= &#x27;2018-11-06 23:59:59&#x27;)</span></span><br><span class="line"><span class="comment">//这里使用了两个问号(?)占位符，后面传递了两个参数替换两个问号。</span></span><br><span class="line">db.Where(<span class="string">&quot;create_time &gt;= ? and create_time &lt;= ?&quot;</span>, <span class="string">&quot;2018-11-06 00:00:00&quot;</span>, <span class="string">&quot;2018-11-06 23:59:59&quot;</span>).Find(&amp;foods)</span><br><span class="line"></span><br><span class="line"><span class="comment">//like语句</span></span><br><span class="line"><span class="comment">//等价于: SELECT * FROM `foods`  WHERE (title like &#x27;%可乐%&#x27;)</span></span><br><span class="line">db.Where(<span class="string">&quot;title like ?&quot;</span>, <span class="string">&quot;%可乐%&quot;</span>).Find(&amp;foods)</span><br><span class="line"></span><br><span class="line"><span class="comment">//复杂查询：</span></span><br><span class="line"><span class="comment">// 使用 :name 作为命名参数</span></span><br><span class="line"><span class="comment">//参数顺序无关，可复用变量</span></span><br><span class="line">db.Where(<span class="string">&quot;id = :id OR name = :name&quot;</span>, </span><br><span class="line">    <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">        <span class="string">&quot;id&quot;</span>:   <span class="number">10</span>,</span><br><span class="line">        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;可乐&quot;</span>,</span><br><span class="line">    &#125;).Find(&amp;foods)</span><br></pre></td></tr></table></figure><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等价于: SELECT id,title FROM `foods`  WHERE `foods`.`id` = &#x27;1&#x27; AND ((id = &#x27;1&#x27;)) LIMIT 1  </span></span><br><span class="line">db.Select(<span class="string">&quot;id,title&quot;</span>).Where(<span class="string">&quot;id = ?&quot;</span>, <span class="number">1</span>).Take(&amp;food)</span><br><span class="line"></span><br><span class="line"><span class="comment">//这种写法是直接往Select函数传递数组，数组元素代表需要选择的字段名</span></span><br><span class="line">db.Select([]<span class="type">string</span>&#123;<span class="string">&quot;id&quot;</span>, <span class="string">&quot;title&quot;</span>&#125;).Where(<span class="string">&quot;id = ?&quot;</span>, <span class="number">1</span>).Take(&amp;food)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//可以直接书写聚合语句</span></span><br><span class="line"><span class="comment">//等价于: SELECT count(*) as total FROM `foods`</span></span><br><span class="line">total := []<span class="type">int</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Model函数，用于指定绑定的模型，这里生成了一个Food&#123;&#125;变量。目的是从模型变量里面提取表名，Pluck函数我们没有直接传递绑定表名的结构体变量，gorm库不知道表名是什么，所以这里需要指定表名</span></span><br><span class="line"><span class="comment">//Pluck函数，主要用于查询一列值</span></span><br><span class="line">db.Model(&amp;Food&#123;&#125;).Select(<span class="string">&quot;count(*) as total&quot;</span>).Pluck(<span class="string">&quot;total&quot;</span>, &amp;total)</span><br><span class="line"></span><br><span class="line">fmt.Println(total[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><h3 id="order"><a href="#order" class="headerlink" title="order"></a>order</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等价于: SELECT * FROM `foods`  WHERE (create_time &gt;= &#x27;2018-11-06 00:00:00&#x27;) ORDER BY create_time desc</span></span><br><span class="line">db.Where(<span class="string">&quot;create_time &gt;= ?&quot;</span>, <span class="string">&quot;2018-11-06 00:00:00&quot;</span>).Order(<span class="string">&quot;create_time desc&quot;</span>).Find(&amp;foods)</span><br></pre></td></tr></table></figure><h3 id="limit-offset"><a href="#limit-offset" class="headerlink" title="limit &#x2F; offset"></a>limit &#x2F; offset</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等价于: SELECT * FROM `foods` ORDER BY create_time desc LIMIT 10 OFFSET 0 </span></span><br><span class="line">db.Order(<span class="string">&quot;create_time desc&quot;</span>).Limit(<span class="number">10</span>).Offset(<span class="number">0</span>).Find(&amp;foods)</span><br></pre></td></tr></table></figure><h3 id="count"><a href="#count" class="headerlink" title="count"></a>count</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> total <span class="type">int64</span> = <span class="number">0</span></span><br><span class="line"><span class="comment">//等价于: SELECT count(*) FROM `foods` </span></span><br><span class="line"><span class="comment">//这里也需要通过model设置模型，让gorm可以提取模型对应的表名</span></span><br><span class="line">db.Model(Food&#123;&#125;).Count(&amp;total)</span><br><span class="line">fmt.Println(total)</span><br></pre></td></tr></table></figure><h3 id="group-by-通常结合-自己新定义一个结构体-scan"><a href="#group-by-通常结合-自己新定义一个结构体-scan" class="headerlink" title="group by ( 通常结合 自己新定义一个结构体+scan() )"></a>group by ( 通常结合 自己新定义一个结构体+scan() )</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/统计每个商品分类下面有多少个商品</span><br><span class="line"><span class="comment">//定一个Result结构体类型，用来保存查询结果</span></span><br><span class="line"><span class="keyword">type</span> Result <span class="keyword">struct</span> &#123;</span><br><span class="line">    Type  <span class="type">int</span></span><br><span class="line">    Total <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> results []Result</span><br><span class="line"><span class="comment">//等价于: SELECT type, count(*) as  total FROM `foods` GROUP BY type HAVING (total &gt; 0)</span></span><br><span class="line">db.Model(Food&#123;&#125;).Select(<span class="string">&quot;type, count(*) as  total&quot;</span>).Group(<span class="string">&quot;type&quot;</span>).Having(<span class="string">&quot;total &gt; 0&quot;</span>).Scan(&amp;results)</span><br><span class="line"></span><br><span class="line"><span class="comment">//scan类似Find都是用于执行查询语句，然后把查询结果赋值给结构体变量，区别在于scan不会从传递进来的结构体变量提取表名.</span></span><br><span class="line"><span class="comment">//这里因为我们重新定义了一个结构体用于保存结果，但是这个结构体并没有绑定foods表，所以这里只能使用scan查询函数。</span></span><br></pre></td></tr></table></figure><h3 id="直接执行sql语句"><a href="#直接执行sql语句" class="headerlink" title="直接执行sql语句"></a>直接执行sql语句</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sql := <span class="string">&quot;SELECT type, count(*) as  total FROM `foods` where create_time &gt; ? GROUP BY type HAVING (total &gt; 0)&quot;</span></span><br><span class="line"><span class="comment">//因为sql语句使用了一个问号(?)作为绑定参数, 所以需要传递一个绑定参数(Raw第二个参数).</span></span><br><span class="line"><span class="comment">//Raw函数支持绑定多个参数</span></span><br><span class="line">db.Raw(sql, <span class="string">&quot;2018-11-06 00:00:00&quot;</span>).Scan(&amp;results) <span class="comment">//依旧scan</span></span><br></pre></td></tr></table></figure><h2 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h2><h3 id="save-先拿出来，改字段，再塞回去"><a href="#save-先拿出来，改字段，再塞回去" class="headerlink" title="save 先拿出来，改字段，再塞回去"></a>save 先拿出来，改字段，再塞回去</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等价于: SELECT * FROM `foods`  WHERE (id = &#x27;2&#x27;) LIMIT 1</span></span><br><span class="line">db.Where(<span class="string">&quot;id = ?&quot;</span>, <span class="number">2</span>).Take(&amp;food)</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改food模型的值</span></span><br><span class="line">food.Price = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//等价于: UPDATE `foods` SET `title` = &#x27;可乐&#x27;, `type` = &#x27;0&#x27;, `price` = &#x27;100&#x27;, `stock` = &#x27;26&#x27;, `create_time` = &#x27;2018-11-06 11:12:04&#x27;  WHERE `foods`.`id` = &#x27;2&#x27;</span></span><br><span class="line">db.Save(&amp;food)</span><br></pre></td></tr></table></figure><h3 id="update-直接改"><a href="#update-直接改" class="headerlink" title="update 直接改"></a>update 直接改</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//更新food模型对应的表记录</span></span><br><span class="line"><span class="comment">//等价于: UPDATE `foods` SET `price` = &#x27;25&#x27;  WHERE `foods`.`id` = &#x27;2&#x27;</span></span><br><span class="line">db.Model(&amp;food).Update(<span class="string">&quot;price&quot;</span>, <span class="number">25</span>)</span><br><span class="line"><span class="comment">//通过food模型的主键id的值作为where条件，更新price字段值。 (food里面有id字段)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//上面的例子只是更新一条记录，如果我们要更全部记录怎么办？</span></span><br><span class="line"><span class="comment">//等价于: UPDATE `foods` SET `price` = &#x27;25&#x27;</span></span><br><span class="line">db.Model(&amp;Food&#123;&#125;).Update(<span class="string">&quot;price&quot;</span>, <span class="number">25</span>)</span><br><span class="line"><span class="comment">//注意这里的Model参数，使用的是Food&#123;&#125;，新生成一个空白的模型变量，没有绑定任何记录。</span></span><br><span class="line"><span class="comment">//因为Food&#123;&#125;的id为空，gorm库就不会以id作为条件，where语句就是空的</span></span><br><span class="line"><span class="comment">//根据自定义条件更新记录，而不是根据主键id</span></span><br><span class="line"><span class="comment">//等价于: UPDATE `foods` SET `price` = &#x27;25&#x27;  WHERE (create_time &gt; &#x27;2018-11-06 20:00:00&#x27;) </span></span><br><span class="line">db.Model(&amp;Food&#123;&#125;).Where(<span class="string">&quot;create_time &gt; ?&quot;</span>, <span class="string">&quot;2018-11-06 20:00:00&quot;</span>).Update(<span class="string">&quot;price&quot;</span>, <span class="number">25</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//改多个字段：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过结构体变量设置更新字段</span></span><br><span class="line">updataFood := Food&#123;</span><br><span class="line">Price:<span class="number">120</span>,</span><br><span class="line">Title:<span class="string">&quot;柠檬雪碧&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据food模型更新数据库记录</span></span><br><span class="line"><span class="comment">//等价于: UPDATE `foods` SET `price` = &#x27;120&#x27;, `title` = &#x27;柠檬雪碧&#x27;  WHERE `foods`.`id` = &#x27;2&#x27;</span></span><br><span class="line"><span class="comment">//Updates会忽略掉updataFood结构体变量的零值字段, 所以生成的sql语句只有price和title字段。</span></span><br><span class="line">db.Model(&amp;food).Updates(&amp;updataFood)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//根据自定义条件更新记录，而不是根据模型id</span></span><br><span class="line">updataFood := Food&#123;</span><br><span class="line">Stock:<span class="number">120</span>,</span><br><span class="line">Title:<span class="string">&quot;柠檬雪碧&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置Where条件，Model参数绑定一个空的模型变量</span></span><br><span class="line"><span class="comment">//等价于: UPDATE `foods` SET `stock` = &#x27;120&#x27;, `title` = &#x27;柠檬雪碧&#x27;  WHERE (price &gt; &#x27;10&#x27;) </span></span><br><span class="line">db.Model(&amp;Food&#123;&#125;).Where(<span class="string">&quot;price &gt; ?&quot;</span>, <span class="number">10</span>).Updates(&amp;updataFood)</span><br></pre></td></tr></table></figure><p>总结model的作用：</p><h4 id="场景1：通过模型实例更新（带ID条件）"><a href="#场景1：通过模型实例更新（带ID条件）" class="headerlink" title="场景1：通过模型实例更新（带ID条件）"></a><strong>场景1：通过模型实例更新（带ID条件）</strong></h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">food := Food&#123;ID: <span class="number">2</span>&#125; <span class="comment">// 包含ID的模型实例</span></span><br><span class="line">updataFood := Food&#123;</span><br><span class="line">    Price: <span class="number">120</span>,</span><br><span class="line">    Title: <span class="string">&quot;柠檬雪碧&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">db.Model(&amp;food).Updates(&amp;updataFood)</span><br></pre></td></tr></table></figure><p><strong>生成SQL</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> `foods` <span class="keyword">SET</span> `price`<span class="operator">=</span><span class="number">120</span>, `title`<span class="operator">=</span><span class="string">&#x27;柠檬雪碧&#x27;</span> <span class="keyword">WHERE</span> `id`<span class="operator">=</span><span class="number">2</span></span><br></pre></td></tr></table></figure><p><strong>关键点</strong>：</p><ul><li><code>Model(&amp;food)</code> 中的 <code>food</code> <strong>必须包含主键字段</strong>（如ID），否则可能全表更新</li><li><code>Updates()</code> 自动忽略结构体零值字段（如 <code>0</code>&#x2F;<code>&quot;&quot;</code>&#x2F;<code>false</code>）</li><li><strong>风险</strong>：若 <code>food</code> 未设置ID，会导致全表更新（危险！）</li></ul><h4 id="场景2：自定义条件更新（空模型-WHERE）"><a href="#场景2：自定义条件更新（空模型-WHERE）" class="headerlink" title="场景2：自定义条件更新（空模型+WHERE）"></a><strong>场景2：自定义条件更新（空模型+WHERE）</strong></h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.Model(&amp;Food&#123;&#125;).Where(<span class="string">&quot;price &gt; ?&quot;</span>, <span class="number">10</span>).Updates(Food&#123;</span><br><span class="line">    Stock: <span class="number">120</span>,</span><br><span class="line">    Title: <span class="string">&quot;柠檬雪碧&quot;</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>生成SQL</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> `foods` <span class="keyword">SET</span> `stock`<span class="operator">=</span><span class="number">120</span>, `title`<span class="operator">=</span><span class="string">&#x27;柠檬雪碧&#x27;</span> <span class="keyword">WHERE</span> price <span class="operator">&gt;</span> <span class="number">10</span></span><br></pre></td></tr></table></figure><p><strong>关键点</strong>：</p><ul><li><code>&amp;Food&#123;&#125;</code> 是空模型实例，仅用于提取表名</li><li><strong>安全机制</strong>：必须配合 <code>Where()</code> 使用，避免全表更新</li><li>仍会忽略零值字段（如 <code>Stock: 0</code> 不会被更新）</li></ul><h4 id="场景3：强制更新零值（使用map）"><a href="#场景3：强制更新零值（使用map）" class="headerlink" title="场景3：强制更新零值（使用map）"></a><strong>场景3：强制更新零值（使用map）</strong></h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data := <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">    <span class="string">&quot;stock&quot;</span>: <span class="number">0</span>,  <span class="comment">// 零值会被更新</span></span><br><span class="line">    <span class="string">&quot;price&quot;</span>: <span class="number">35</span>,</span><br><span class="line">&#125;</span><br><span class="line">db.Model(&amp;Food&#123;&#125;).Where(<span class="string">&quot;id = ?&quot;</span>, <span class="number">2</span>).Updates(data)</span><br></pre></td></tr></table></figure><p><strong>生成SQL</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> `foods` <span class="keyword">SET</span> `price`<span class="operator">=</span><span class="number">35</span>, `stock`<span class="operator">=</span><span class="number">0</span> <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">2</span></span><br></pre></td></tr></table></figure><p><strong>优势</strong>：</p><ul><li>通过 <code>map</code> 强制更新所有字段（包括零值）</li><li>更灵活的数据结构（支持混合类型字段）</li><li>避免结构体零值忽略问题</li></ul><h2 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">food := Food&#123;&#125;</span><br><span class="line"><span class="comment">//先查询一条记录, 保存在模型变量food</span></span><br><span class="line"><span class="comment">//等价于: SELECT * FROM `foods`  WHERE (id = &#x27;2&#x27;) LIMIT 1</span></span><br><span class="line">db.Where(<span class="string">&quot;id = ?&quot;</span>, <span class="number">2</span>).Take(&amp;food)</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除food对应的记录，通过主键Id标识记录</span></span><br><span class="line"><span class="comment">//等价于： DELETE from `foods` where id=2;</span></span><br><span class="line">db.Delete(&amp;food)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//等价于：DELETE from `foods` where (`type` = 5);</span></span><br><span class="line">db.Where(<span class="string">&quot;type = ?&quot;</span>, <span class="number">5</span>).Delete(&amp;Food&#123;&#125;)</span><br><span class="line"><span class="comment">//这里Delete函数需要传递一个空的模型变量指针，主要用于获取模型变量绑定的表名。 不能传递一个非空的模型变量，否则就变成删除指定的模型数据，自动在where语句加上类似id = 2这样的主键约束条件</span></span><br></pre></td></tr></table></figure><h2 id="事务处理"><a href="#事务处理" class="headerlink" title="事务处理"></a>事务处理</h2><h3 id="自动事务"><a href="#自动事务" class="headerlink" title="自动事务"></a>自动事务</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">db.Transaction(<span class="function"><span class="keyword">func</span><span class="params">(tx *gorm.DB)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">  <span class="comment">// 在事务中执行一些 db 操作（从这里开始，应该使用 &#x27;tx&#x27; 而不是 &#x27;db&#x27;）</span></span><br><span class="line">  <span class="keyword">if</span> err := tx.Create(&amp;Animal&#123;Name: <span class="string">&quot;Giraffe&quot;</span>&#125;).Error; err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// 返回任何错误都会回滚事务</span></span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> err := tx.Create(&amp;Animal&#123;Name: <span class="string">&quot;Lion&quot;</span>&#125;).Error; err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回 nil 提交事务</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="手动事务"><a href="#手动事务" class="headerlink" title="手动事务"></a>手动事务</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开启事务</span></span><br><span class="line">tx := db.Begin()</span><br><span class="line"></span><br><span class="line"><span class="comment">//在事务中执行数据库操作，使用的是tx变量，不是db。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//库存减一</span></span><br><span class="line"><span class="comment">//等价于: UPDATE `foods` SET `stock` = stock - 1  WHERE `foods`.`id` = &#x27;2&#x27; and stock &gt; 0</span></span><br><span class="line"><span class="comment">//RowsAffected用于返回sql执行后影响的行数</span></span><br><span class="line">rowsAffected := tx.Model(&amp;food).Where(<span class="string">&quot;stock &gt; 0&quot;</span>).Update(<span class="string">&quot;stock&quot;</span>, gorm.Expr(<span class="string">&quot;stock - 1&quot;</span>)).RowsAffected</span><br><span class="line"><span class="keyword">if</span> rowsAffected == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="comment">//如果更新库存操作，返回影响行数为0，说明没有库存了，结束下单流程</span></span><br><span class="line">    <span class="comment">//这里回滚作用不大，因为前面没成功执行什么数据库更新操作，也没什么数据需要回滚。</span></span><br><span class="line">    <span class="comment">//这里就是举个例子，事务中可以执行多个sql语句，错误了可以回滚事务</span></span><br><span class="line">    tx.Rollback()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">err := tx.Create(保存订单).Error</span><br><span class="line"></span><br><span class="line"><span class="comment">//保存订单失败，则回滚事务</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    tx.Rollback()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    tx.Commit()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="关联查询"><a href="#关联查询" class="headerlink" title="关联查询"></a>关联查询</h2><p>一对一可以分为 <strong><code>Belongs To</code></strong> 和 <strong><code>Has One</code></strong></p><h3 id="Belongs-To"><a href="#Belongs-To" class="headerlink" title="Belongs  To"></a>Belongs  To</h3><p>顾名思义，意为 “属于” </p><p>使用场景：当<strong>子表必须关联父表</strong>，当子表没有父表，子表就没有意义（如 <code>Comment</code>必须属于 <code>Post</code>）</p><p>定义类似：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  gorm.Model</span><br><span class="line">  Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Profile <span class="keyword">struct</span> &#123;</span><br><span class="line">  gorm.Model</span><br><span class="line">  Name   <span class="type">string</span></span><br><span class="line">  UserID <span class="type">uint</span>  <span class="comment">// 外键存储在 Profile 表</span></span><br><span class="line">  User   User <span class="string">`gorm:&quot;foreignKey:UserID&quot;`</span>  <span class="comment">// Profile 属于 User ，且必须含有此属性（grom会默认使用User 的id字段）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Has-One"><a href="#Has-One" class="headerlink" title="Has One"></a>Has One</h3><p>拥有，和属于不同的是，has one是父表拥有子表，但也可以不拥有，因为这时候父表也是有意义的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  gorm.Model</span><br><span class="line">  Name    <span class="type">string</span></span><br><span class="line">  Profile Profile <span class="string">`gorm:&quot;foreignKey:UserID&quot;`</span>  <span class="comment">// User 拥有一个 Profile</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Profile <span class="keyword">struct</span> &#123;</span><br><span class="line">  gorm.Model</span><br><span class="line">  Name   <span class="type">string</span></span><br><span class="line">  UserID <span class="type">uint</span>  <span class="comment">// 外键仍然在 Profile 表，但关系方向不同</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li><p>无论是 belongs to 还是 has one，外键都在子表</p></li><li><p>belongs to 子表含有父表结构体 ，has one 父表含有子表结构体</p></li><li><p>tag是打在结构体上的</p></li><li><p>使用场景：当表a可以包含表b，且b不一定要有一个a的时候，可以用has one，如果b必须关联a，那就要用belongs to</p></li></ol><h3 id="关联外键"><a href="#关联外键" class="headerlink" title="关联外键"></a>关联外键</h3><p><strong>什么时候需要自定义外键？</strong></p><ul><li>当想用<strong>非ID字段</strong>（如 <code>UUID</code>、<code>Email</code>、<code>Refer</code>）作为关联依据时。</li><li>当数据库设计<strong>不允许使用默认外键命名</strong>时。</li><li>当需要<strong>更灵活的关联逻辑</strong>时</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//belongs to</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  gorm.Model</span><br><span class="line">  Refer <span class="type">string</span> <span class="comment">// 自定义关联外键</span></span><br><span class="line">  Name  <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Profile <span class="keyword">struct</span> &#123;</span><br><span class="line">  gorm.Model</span><br><span class="line">  Name      <span class="type">string</span></span><br><span class="line">  User      User <span class="string">`gorm:&quot;foreignKey:UserRefer;references:Refer&quot;`</span> <span class="comment">// 使用 Refer 作为关联外键</span></span><br><span class="line">  UserRefer <span class="type">string</span> <span class="comment">// 外键字段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//has one</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  gorm.Model</span><br><span class="line">  Refer <span class="type">string</span> <span class="comment">// 自定义关联外键</span></span><br><span class="line">  Name  <span class="type">string</span></span><br><span class="line">  Profile Profile <span class="string">`gorm:&quot;foreignKey:UserRefer;references:Refer&quot;`</span> <span class="comment">// 使用 Refer 作为关联外键</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Profile <span class="keyword">struct</span> &#123;</span><br><span class="line">  gorm.Model</span><br><span class="line">  Name      <span class="type">string</span></span><br><span class="line">  UserRefer <span class="type">string</span> <span class="comment">// 外键字段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查询举例"><a href="#查询举例" class="headerlink" title="查询举例"></a>查询举例</h3><ul><li>想根据子表字段查询父表中的数据，只要父表，子表定义好了外键，就能像查一张表一样，直接查询</li><li>想要根据父表字段查询子表数据，就要model传入空父表指针，调用Association指定子表子段，然后再调用quary方法</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">user := User&#123;&#125;</span><br><span class="line"><span class="comment">// 查询用户数据</span></span><br><span class="line"><span class="comment">//自动生成sql： SELECT * FROM `users`  WHERE (username = &#x27;tizi365&#x27;) LIMIT 1</span></span><br><span class="line">db.Where(<span class="string">&quot;username = ?&quot;</span>, <span class="string">&quot;tizi365&quot;</span>).First(&amp;user)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> card CreditCard</span><br><span class="line"><span class="comment">////自动生成SQL： SELECT * FROM credit_cards WHERE user_id = 123; // 123 自动从user的ID读取</span></span><br><span class="line"><span class="comment">// 关联查询的结果会填充到card变量</span></span><br><span class="line">db.Model(&amp;user).Association(<span class="string">&quot;CreditCard&quot;</span>).Find(&amp;card)</span><br></pre></td></tr></table></figure><h2 id="Migrate建表-操作表"><a href="#Migrate建表-操作表" class="headerlink" title="Migrate建表&#x2F;操作表"></a>Migrate建表&#x2F;操作表</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据User结构体，自动创建表结构.</span></span><br><span class="line">db.AutoMigrate(&amp;User&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一次创建User、Product、Order三个结构体对应的表结构</span></span><br><span class="line">db.AutoMigrate(&amp;User&#123;&#125;, &amp;Product&#123;&#125;, &amp;Order&#123;&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检测User结构体对应的表是否存在</span></span><br><span class="line">db.Migrator().HasTable(&amp;User&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检测表名users是否存在</span></span><br><span class="line">db.Migrator().HasTable(<span class="string">&quot;users&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据User结构体建表</span></span><br><span class="line">db.Migrator().CreateTable(&amp;User&#123;&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除User结构体对应的表</span></span><br><span class="line">db.Migrator().DropTable(&amp;User&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除表名为users的表</span></span><br><span class="line">db.Migrator().DropTable(<span class="string">&quot;users&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除User结构体对应表中的description字段</span></span><br><span class="line">db.Migrator().DropColumn(&amp;User&#123;&#125;, <span class="string">&quot;Name&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> mySql </tag>
            
            <tag> GORM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>苍穹day2-3</title>
      <link href="/2025/09/15/%E8%8B%8D%E7%A9%B9day2-3/"/>
      <url>/2025/09/15/%E8%8B%8D%E7%A9%B9day2-3/</url>
      
        <content type="html"><![CDATA[<h1 id="苍穹Day2-3"><a href="#苍穹Day2-3" class="headerlink" title="苍穹Day2-3"></a>苍穹Day2-3</h1><h2 id="swagger"><a href="#swagger" class="headerlink" title="swagger"></a>swagger</h2><p>在controller接口方法上加上注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ApiOperation(&quot;接口名&quot;)</span></span><br></pre></td></tr></table></figure><h2 id="公共字段自动填充-——AOP-反射-注解-枚举"><a href="#公共字段自动填充-——AOP-反射-注解-枚举" class="headerlink" title="公共字段自动填充 ——AOP 反射 注解 枚举"></a>公共字段自动填充 ——AOP 反射 注解 枚举</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sky.aspect;</span><br><span class="line"><span class="keyword">import</span> com.sky.annotation.AutoFill;</span><br><span class="line"><span class="keyword">import</span> com.sky.context.BaseContext;</span><br><span class="line"><span class="keyword">import</span> com.sky.enums.UpdateOrInsert;</span><br><span class="line"><span class="keyword">import</span> com.sky.interceptor.JwtTokenAdminInterceptor;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.JoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Before;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Pointcut;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.reflect.MethodSignature;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Parameter;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AutoFillAspect</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> JwtTokenAdminInterceptor jwtTokenAdminInterceptor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AutoFillAspect</span><span class="params">(JwtTokenAdminInterceptor jwtTokenAdminInterceptor)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.jwtTokenAdminInterceptor = jwtTokenAdminInterceptor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//抽取（可以不抽取，但以后的切入点就要写完整）</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.sky.mapper.*.*(..)) &amp;&amp; @annotation(com.sky.annotation.AutoFill)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pointCut</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义通知的具体内容</span></span><br><span class="line">    <span class="meta">@Before(&quot;pointCut()&quot;)</span>  <span class="comment">//抽取之后就能在定义切入点的时候直接这么写</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">(JoinPoint joinPoint)</span>&#123;  <span class="comment">//这里是关键，传入一个连接点对象，这个连接点对象蕴含了被拦截方法的信息</span></span><br><span class="line">        <span class="comment">//要获取这个方法的类型</span></span><br><span class="line"></span><br><span class="line">        <span class="type">MethodSignature</span> <span class="variable">signature</span> <span class="operator">=</span> (MethodSignature) joinPoint.getSignature();<span class="comment">//获取方法签名,直接用子接口接收</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> signature.getMethod(); <span class="comment">//获得具体的方法对象</span></span><br><span class="line">        <span class="type">AutoFill</span> <span class="variable">annotation</span> <span class="operator">=</span> method.getAnnotation(AutoFill.class); <span class="comment">//通过方法对象得到方法的注解</span></span><br><span class="line">        <span class="keyword">if</span>(annotation == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> method.getName();</span><br><span class="line">            log.warn(<span class="string">&quot;    &quot;</span> +name + <span class="string">&quot;方法上没有这个注解&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">UpdateOrInsert</span> <span class="variable">updateOrInsert</span> <span class="operator">=</span> annotation.updateOrInsert(); <span class="comment">//通过注解的枚举得到方法的类型</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//要获取这个方法的参数,也要通过joinpoint获得</span></span><br><span class="line">        Object[] args = joinPoint.getArgs();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> args[<span class="number">0</span>]; <span class="comment">//约定第一个参数为传入的对象</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(updateOrInsert == UpdateOrInsert.INSERT)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">Method</span> <span class="variable">method1</span> <span class="operator">=</span> object.getClass().getDeclaredMethod(<span class="string">&quot;setCreateTime&quot;</span>, LocalDateTime.class);</span><br><span class="line">                <span class="type">Method</span> <span class="variable">method2</span> <span class="operator">=</span> object.getClass().getDeclaredMethod(<span class="string">&quot;setUpdateTime&quot;</span>,LocalDateTime.class);</span><br><span class="line">                <span class="type">Method</span> <span class="variable">method3</span> <span class="operator">=</span> object.getClass().getDeclaredMethod(<span class="string">&quot;setCreateUser&quot;</span>,Long.class);</span><br><span class="line">                <span class="type">Method</span> <span class="variable">method4</span> <span class="operator">=</span> object.getClass().getDeclaredMethod(<span class="string">&quot;setUpdateUser&quot;</span>,Long.class);</span><br><span class="line"></span><br><span class="line">                method1.invoke(object,LocalDateTime.now());</span><br><span class="line">                method2.invoke(object,LocalDateTime.now());</span><br><span class="line">                method3.invoke(object, BaseContext.getCurrentId()); <span class="comment">//LocalThread</span></span><br><span class="line">                method4.invoke(object,BaseContext.getCurrentId());</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">Method</span> <span class="variable">method2</span> <span class="operator">=</span> object.getClass().getDeclaredMethod(<span class="string">&quot;setUpdateTime&quot;</span>,LocalDateTime.class);</span><br><span class="line">                <span class="type">Method</span> <span class="variable">method4</span> <span class="operator">=</span> object.getClass().getDeclaredMethod(<span class="string">&quot;setUpdateUser&quot;</span>,Long.class);</span><br><span class="line">                method2.invoke(object,LocalDateTime.now());</span><br><span class="line">                method4.invoke(object,BaseContext.getCurrentId());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AOP </tag>
            
            <tag> Java </tag>
            
            <tag> 苍穹外卖 </tag>
            
            <tag> 反射 </tag>
            
            <tag> 注解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AOP</title>
      <link href="/2025/09/14/AOP/"/>
      <url>/2025/09/14/AOP/</url>
      
        <content type="html"><![CDATA[<h2 id="AOP基础"><a href="#AOP基础" class="headerlink" title="AOP基础"></a>AOP基础</h2><p>SpringAOP实现步骤</p><p>导入依赖：在 pom.xml 文件中导入 AOP 的依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在类名上加@Aspect注解</p><p>在方法名上加具体AOP方法注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span> <span class="comment">//当前类为切面类</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RecordTimeAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;execution(* com.itheima.service.impl.DeptServiceImpl.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">recordTime</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">//记录方法执行开始时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//执行原始方法</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> pjp.proceed();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//记录方法执行结束时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算方法执行耗时</span></span><br><span class="line">        log.info(<span class="string">&quot;方法执行耗时: &#123;&#125;毫秒&quot;</span>,end-begin);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心概念：</p><ul><li><strong>连接点：JoinPoint</strong>，可以被AOP控制的方法（类上加了@Aspect注解，里面的方法就都是）</li><li><strong>通知：Advice</strong>，指哪些重复的逻辑，也就是共性功能（方法体内容）</li><li><strong>切入点：PointCut</strong>，匹配连接点的条件，通知仅会在切入点方法执行时被应用 （也就是具体的AOP方法注解）</li><li><strong>切面：Aspect</strong>，描述通知与切入点的对应关系（通知+切入点，即注解+方法）</li><li><strong>目标对象：Target</strong>，通知所应用的对象</li></ul><h2 id="AOP进阶"><a href="#AOP进阶" class="headerlink" title="AOP进阶"></a>AOP进阶</h2><h3 id="五种类型："><a href="#五种类型：" class="headerlink" title="五种类型："></a>五种类型：</h3><table><thead><tr><th><strong>Spring AOP 通知类型</strong></th><th></th></tr></thead><tbody><tr><td>@Around</td><td>环绕通知，此注解标注的通知方法在目标方法前、后都被执行</td></tr><tr><td>@Before</td><td>前置通知，此注解标注的通知方法在目标方法前被执行</td></tr><tr><td>@After</td><td>后置通知，此注解标注的通知方法在目标方法后被执行，无论是否有异常都会执行</td></tr><tr><td>@AfterReturning</td><td>返回后通知，此注解标注的通知方法在目标方法后被执行，有异常不会执行</td></tr><tr><td>@AfterThrowing</td><td>异常后通知，此注解标注的通知方法发生异常后执行</td></tr></tbody></table><h3 id="抽取："><a href="#抽取：" class="headerlink" title="抽取："></a>抽取：</h3><p>给一个函数加上@Pointcut注解，就可以在后面复用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.itheima.service.*.*(..))&quot;)</span>    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后面用的时候：</span></span><br><span class="line"><span class="meta">@Before(&quot;pt()&quot;)</span></span><br><span class="line"><span class="meta">@Around(&quot;pt()&quot;)</span></span><br></pre></td></tr></table></figure><p>当切入点方法使用 private 修饰时，仅能在当前切面类中引用该表达式， 当外部其他切面类中也要引用当前类中的切入点表达式，就需要 public, 别的类用pt的时候，需要传递全类名+方法，如 com.dhrjava.aspect.myAspect.pt()</p><h3 id="通知顺序"><a href="#通知顺序" class="headerlink" title="通知顺序"></a>通知顺序</h3><ul><li>目标方法前的通知方法：字母排名靠前的先执行</li><li>目标方法后的通知方法：字母排名靠前的后执行</li></ul><p>想改的话，使用Spring提供的 @Order 注解</p><h3 id="切入点表达式"><a href="#切入点表达式" class="headerlink" title="切入点表达式"></a>切入点表达式</h3><h4 id="execution-……-：根据方法的签名来匹配"><a href="#execution-……-：根据方法的签名来匹配" class="headerlink" title="execution(……)：根据方法的签名来匹配"></a>execution(……)：根据方法的签名来匹配</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution(访问修饰符?  返回值  包名.类名.?方法名(方法参数) <span class="keyword">throws</span> 异常?)</span><br></pre></td></tr></table></figure><ol><li>其中带<code>?</code>的表示可以省略的部分</li></ol><ul><li>访问修饰符：可省略（比如: public、protected）</li><li>包名.类名： 可省略</li><li>throws 异常：可省略（注意是方法上声明抛出的异常，不是实际抛出的异常）</li></ul><ol start="2"><li>可以使用通配符描述切入点</li></ol><ul><li><code>*</code> ：单个独立的任意符号，可以通配任意返回值、包名、类名、方法名、任意类型的一个参数，也可以通配包、类、方法名的一部分</li><li><code>..</code> ：多个连续的任意符号，可以通配任意层级的包，或任意类型、任意个数的参数</li></ul><ol start="3"><li>根据业务需要，可以使用 且（&amp;&amp;）、或（||）、非（!） 来组合比较复杂的切入点表达式</li></ol><h4 id="annotation-……-：根据注解匹配"><a href="#annotation-……-：根据注解匹配" class="headerlink" title="@annotation(……) ：根据注解匹配"></a>@annotation(……) ：根据注解匹配</h4><ol><li>自定义一个注解</li><li>在方法上加上这个注解</li><li>在切入点中找这个注解：@Before(“@annotation(com.itheima.anno.LogOperation)”)</li><li>依旧可以使用逻辑表达式</li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AOP </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThreadLocal</title>
      <link href="/2025/09/14/ThreadLocal/"/>
      <url>/2025/09/14/ThreadLocal/</url>
      
        <content type="html"><![CDATA[<ul><li><h3 id="ThreadLocal-深度解析"><a href="#ThreadLocal-深度解析" class="headerlink" title="ThreadLocal 深度解析"></a><strong>ThreadLocal 深度解析</strong></h3><h4 id="1-核心概念"><a href="#1-核心概念" class="headerlink" title="1. 核心概念"></a><strong>1. 核心概念</strong></h4><ul><li><strong>作用</strong>：为每个线程提供独立的变量副本，解决多线程并发访问共享变量的冲突问题。</li><li><strong>本质</strong>：线程级别的全局变量（线程隔离的全局存储）。</li></ul><h4 id="2-底层原理"><a href="#2-底层原理" class="headerlink" title="2. 底层原理"></a><strong>2. 底层原理</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocal</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">// 关键：每个Thread对象内部维护一个ThreadLocalMap</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> t.threadLocals; <span class="comment">// 获取线程专属的Map</span></span><br><span class="line">        map.set(<span class="built_in">this</span>, value); <span class="comment">// 以ThreadLocal实例为key存储值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>存储结构：<ul><li>每个 <code>Thread</code> 对象内部有一个 <code>ThreadLocalMap</code>（类似HashMap但更简单）。</li><li>Key：<code>ThreadLocal</code> 实例（弱引用），Value：线程的变量副本。</li></ul></li></ul><h4 id="3-使用场景"><a href="#3-使用场景" class="headerlink" title="3. 使用场景"></a><strong>3. 使用场景</strong></h4><table><thead><tr><th>场景</th><th>说明</th></tr></thead><tbody><tr><td><strong>数据库连接管理</strong></td><td>每个线程维护独立的Connection（如Spring的<code>TransactionSynchronizationManager</code>）</td></tr><tr><td><strong>用户会话信息</strong></td><td>在Web应用中存储当前请求的用户信息（如Spring Security的<code>SecurityContextHolder</code>）</td></tr><tr><td><strong>日期格式化工具</strong></td><td>避免<code>SimpleDateFormat</code>线程不安全问题</td></tr></tbody></table><h4 id="4-使用示例"><a href="#4-使用示例" class="headerlink" title="4. 使用示例"></a><strong>4. 使用示例</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 定义ThreadLocal变量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;User&gt; currentUser = ThreadLocal.withInitial(() -&gt; <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 设置当前线程的值</span></span><br><span class="line">currentUser.set(user); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 获取当前线程的值</span></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> currentUser.get();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 使用后必须清理！防止内存泄漏</span></span><br><span class="line">currentUser.remove(); </span><br></pre></td></tr></table></figure><hr><h4 id="5-内存泄漏问题"><a href="#5-内存泄漏问题" class="headerlink" title="5. 内存泄漏问题"></a><strong>5. 内存泄漏问题</strong></h4><ul><li><p>原因：</p><ul><li><code>ThreadLocalMap</code> 的 Key 是弱引用，但 Value 是强引用。</li><li>线程池中线程长期存活时，Value 可能无法被回收。</li></ul></li><li><p>解决方案：</p><ul><li><p>每次使用后调用 <code>remove()</code> 清理。</p></li><li><p>使用 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">try-finally</span><br></pre></td></tr></table></figure><p> 确保清理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    currentUser.set(user);</span><br><span class="line">    <span class="comment">// 业务逻辑...</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    currentUser.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="6-与synchronized对比"><a href="#6-与synchronized对比" class="headerlink" title="6. 与synchronized对比"></a><strong>6. 与synchronized对比</strong></h4><table><thead><tr><th>特性</th><th>ThreadLocal</th><th>synchronized</th></tr></thead><tbody><tr><td><strong>作用范围</strong></td><td>线程隔离</td><td>线程互斥</td></tr><tr><td><strong>性能开销</strong></td><td>无锁，更快</td><td>有锁竞争，可能阻塞</td></tr><tr><td><strong>适用场景</strong></td><td>线程间数据隔离</td><td>线程间同步控制</td></tr></tbody></table><h4 id="7-相关问题"><a href="#7-相关问题" class="headerlink" title="7.相关问题"></a>7.<strong>相关问题</strong></h4><ul><li><strong>Q1：ThreadLocal如何实现线程隔离？</strong><br> A：每个Thread内部维护独立的ThreadLocalMap，以ThreadLocal实例为Key存储值。</li><li><strong>Q2：为什么Key用弱引用？</strong><br> A：防止ThreadLocal对象无法被回收（但仍需手动<code>remove()</code>避免Value泄漏）。</li><li><strong>Q3：Spring如何用ThreadLocal管理事务？</strong><br> A：<code>TransactionSynchronizationManager</code> 用ThreadLocal保存当前线程的数据库连接。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot原理</title>
      <link href="/2025/09/14/SpringBoot%E5%8E%9F%E7%90%86/"/>
      <url>/2025/09/14/SpringBoot%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="配置优先级"><a href="#配置优先级" class="headerlink" title="配置优先级"></a>配置优先级</h2><p><strong>五种配置方式</strong></p><ol><li>application.properties</li><li>application.yml</li><li>application.yaml</li><li>Java系统属性配置  -Dkey&#x3D;value</li><li>命令行参数： –key&#x3D;value</li></ol><p>优先级：命令行参数 &gt;  系统属性参数 &gt; properties参数 &gt; yml参数 &gt; yaml参数</p><p>启动jar包时指定Java系统属性配置和命令行参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Dserver.port=9000 -jar XXXXX.jar --server.port=10010</span><br></pre></td></tr></table></figure><h2 id="Bean的管理"><a href="#Bean的管理" class="headerlink" title="Bean的管理"></a>Bean的管理</h2><h3 id="1-Bean的作用域配置"><a href="#1-Bean的作用域配置" class="headerlink" title="1. Bean的作用域配置"></a>1. Bean的作用域配置</h3><table><thead><tr><th>作用域</th><th>说明</th></tr></thead><tbody><tr><td>singleton</td><td>容器内同名称的bean只有一个实例（单例）（默认）</td></tr><tr><td>prototype</td><td>每次使用该bean时会创建新的实例（非单例）</td></tr><tr><td>request</td><td>每个请求范围内会创建新的实例（web环境中，了解）</td></tr><tr><td>session</td><td>每个会话范围内会创建新的实例（web环境中，了解）</td></tr><tr><td>application</td><td>每个应用范围内会创建新的实例（web环境中，了解）</td></tr></tbody></table><ul><li>IOC容器中的bean默认使用的作用域：singleton (单例)</li><li>实际开发当中，绝大部分的Bean是单例的，也就是说绝大部分Bean不需要配置scope属性</li><li>默认singleton的bean，在容器启动时被创建，可以使用@Lazy注解来延迟初始化(延迟到第一次使用时)</li></ul><h3 id="2-管理第三方Bean对象"><a href="#2-管理第三方Bean对象" class="headerlink" title="2.管理第三方Bean对象"></a>2.管理第三方Bean对象</h3><p>第三方Bean注入的两种方式：（使用第二种）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式1：启动类声明</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ThirdPartyBean <span class="title function_">bean</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式2：专用配置类</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThirdPartyConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ThirdPartyBean <span class="title function_">bean</span><span class="params">(Dependency dep)</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>通过<code>@Bean</code>注解的name 或 value属性可以声明bean的名称，如果不指定，默认bean的名称就是方法名。</strong></li><li><strong>如果第三方bean需要依赖其他bean对象，直接在bean定义方法中设置形参即可，容器会根据类型自动装配。</strong></li></ul><h2 id="SpringBoot工作原理"><a href="#SpringBoot工作原理" class="headerlink" title="SpringBoot工作原理"></a>SpringBoot工作原理</h2><p>管理第三方Bean对象的时候，如果说这个包，它不在SpringBoot启动类同级目录或其子包下，那么如果不配置componScan注解，就扫描不到，但是一般不建议给第三方包配置这个扫描注解</p><p>第三方包的Bean管理常用方案：</p><ol><li>在启动类中，@Import(普通类.class)</li><li>在启动类中，@Import(配置类.class)</li><li>在启动类中，@Import(ImportSelector接口实现类) 接口实现类重写selectImports()方法</li></ol><p>上面三种方法的共同点，就是要对启动类进行操作，其实再封装一下，就只需要在启动类中加固定的注解就好了</p><p>自定义一个En接口，在接口上加上面三种注解中的一种，在启动类中直接加这个自定义注解就行了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Import(MyImportSelector.class)</span><span class="comment">//指定要导入哪些bean对象或配置类  </span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableHeaderConfig &#123; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h3><p>第一层： SpringBoot启动类上的注解：@SpringBootApplication</p><p>​这个注解中有三个元注解：</p><ul><li>@SpringBootConfiguration</li><li>@EnableAutoConfiguration</li><li>@ComponentScan</li></ul><p>第二层：</p><p>​1. 首先看 @SpringBootConfiguration 注解，这个注解中包含：（第三层）@Configuration 注解 也就是<strong>配置类</strong>注解，这也是 启动类能直接注入Bean对象的原因</p><p>​2. 然后是 @EnableAutoConfiguration 注解，这个注解包含 （第三层）@Import 注解，导入了 <strong>ImportSelector接口实现类</strong>，重写了<strong>selectImports()<strong>方法 ，在方法中调用 <strong>getAutoConfigurationEntry()</strong> 方法 ，此方法再调用</strong>getCandidateConfigurations()</strong> 方法获取在配置文件中配置的所有自动配置类的集合</p><p>​最底层 getCandidateConfigurations 方法的功能：获取所有基于 </p><p>​ META-INF&#x2F;spring&#x2F;org.springframework.boot.autoconfigure.AutoConfiguration.imports 文件中配置类的集合</p><p>​3. @ComponentScan 这个不必说，就是启动类能够扫描当前目录及子目录中注解的功能</p><p>状态注解：在自动配置类声明bean的时候，除了在方法上加了一个@Bean注解以外，还会经常用到一个注解，就是以Conditional开头的这一类的注解。以Conditional开头的这些注解都是条件装配的注解</p><ul><li>@ConditionalOnClass：判断环境中有对应字节码文件，才注册bean到IOC容器。</li><li>@ConditionalOnMissingBean：判断环境中没有对应的bean(类型或名称)，才注册bean到IOC容器。</li><li>@ConditionalOnProperty：判断配置文件中有对应属性和值，才注册bean到IOC容器。</li></ul><h3 id="自定义starter"><a href="#自定义starter" class="headerlink" title="自定义starter"></a>自定义starter</h3><p><strong>目标</strong>：封装阿里云 OSS SDK，实现开箱即用的 Starter，用户只需引入依赖即可自动注入 <code>AliyunOSSOperator</code>。</p><h4 id="1-创建-Starter-模块（依赖管理）"><a href="#1-创建-Starter-模块（依赖管理）" class="headerlink" title="1. 创建 Starter 模块（依赖管理）"></a><strong>1. 创建 Starter 模块（依赖管理）</strong></h4><p><strong>模块名</strong>：<code>aliyun-oss-spring-boot-starter</code><br> ​<strong>作用</strong>​：统一管理依赖，用户只需引入此 Starter。<br> ​<strong>关键步骤</strong>​：</p><ol><li><p><strong>初始化 Maven 项目</strong></p><ul><li>选择 Spring Boot 版本（如 3.2.8），不勾选任何依赖。</li><li>删除无关文件（如 <code>src/main/java</code>），仅保留 <code>pom.xml</code>。</li></ul></li><li><p><strong>配置 <code>pom.xml</code></strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 引入 autoconfigure 模块 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.aliyun.oss<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aliyun-oss-spring-boot-autoconfigure<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="2-创建-Autoconfigure-模块（核心逻辑）"><a href="#2-创建-Autoconfigure-模块（核心逻辑）" class="headerlink" title="2. 创建 Autoconfigure 模块（核心逻辑）"></a><strong>2. 创建 Autoconfigure 模块（核心逻辑）</strong></h4><p><strong>模块名</strong>：<code>aliyun-oss-spring-boot-autoconfigure</code><br> ​<strong>作用</strong>​：实现自动配置逻辑，定义 Bean 和配置文件。</p><h5 id="2-1-准备代码"><a href="#2-1-准备代码" class="headerlink" title="2.1 准备代码"></a><strong>2.1 准备代码</strong></h5><ol><li><p><strong>拷贝原有工具类</strong></p><ul><li>将 <code>AliyunOSSOperator</code>（OSS 操作工具类）和 <code>AliyunOSSProperties</code>（配置类）复制到本模块。</li><li>移除 <code>@Component</code>、<code>@Autowired</code>（因为 Starter 需手动管理 Bean）。</li></ul></li><li><h5 id="改造-AliyunOSSOperator"><a href="#改造-AliyunOSSOperator" class="headerlink" title="改造 AliyunOSSOperator"></a><strong>改造 <code>AliyunOSSOperator</code></strong></h5><ul><li><p>添加构造函数，接收 AliyunOSSProperties</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AliyunOSSOperator</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AliyunOSSProperties properties;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 必须提供构造函数（Spring 依赖注入用）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AliyunOSSOperator</span><span class="params">(AliyunOSSProperties properties)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.properties = properties;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 其他方法（upload/listFiles/deleteFile等）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><h5 id="改造-AliyunOSSProperties"><a href="#改造-AliyunOSSProperties" class="headerlink" title="改造 AliyunOSSProperties"></a><strong>改造 <code>AliyunOSSProperties</code></strong></h5><ul><li><p>添加  @ConfigurationProperties  绑定配置文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;aliyun.oss&quot;)</span> <span class="comment">// 绑定 yml 配置</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AliyunOSSProperties</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String endpoint;</span><br><span class="line">    <span class="keyword">private</span> String accessKeyId;</span><br><span class="line">    <span class="keyword">private</span> String accessKeySecret;</span><br><span class="line">    <span class="keyword">private</span> String bucketName;</span><br><span class="line">    <span class="comment">// getters/setters...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h5 id="2-2-定义自动配置类（相比于原来的类新增的，一个配置类）"><a href="#2-2-定义自动配置类（相比于原来的类新增的，一个配置类）" class="headerlink" title="2.2 定义自动配置类（相比于原来的类新增的，一个配置类）"></a><strong>2.2 定义自动配置类</strong>（相比于原来的类新增的，一个配置类）</h5><ol><li><h5 id="创建-AliyunOSSAutoConfiguration"><a href="#创建-AliyunOSSAutoConfiguration" class="headerlink" title="创建 AliyunOSSAutoConfiguration"></a><strong>创建 <code>AliyunOSSAutoConfiguration</code></strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(AliyunOSSProperties.class)</span> <span class="comment">// 启用配置绑定</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AliyunOSSAutoConfiguration</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> AliyunOSSOperator <span class="title function_">aliyunOSSOperator</span><span class="params">(AliyunOSSProperties properties)</span> &#123;</span><br><span class="line">        <span class="comment">// 通过构造函数注入配置</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AliyunOSSOperator</span>(properties);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h5 id="注册自动配置类"><a href="#注册自动配置类" class="headerlink" title="注册自动配置类"></a><strong>注册自动配置类</strong></h5><p>resources&#x2F;META-INF&#x2F;spring&#x2F; 下创建文件：</p><ul><li>文件名：org.springframework.boot.autoconfigure.AutoConfiguration.imports</li><li>内容 ：com.aliyun.oss.AliyunOSSAutoConfiguration</li></ul></li></ol><h5 id="2-3-配置依赖"><a href="#2-3-配置依赖" class="headerlink" title="2.3 配置依赖"></a><strong>2.3 配置依赖</strong></h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Spring Boot 基础依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 阿里云 OSS SDK --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.aliyun.oss<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aliyun-sdk-oss<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.17.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- Lombok（可选） --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="3-用户使用-Starter"><a href="#3-用户使用-Starter" class="headerlink" title="3. 用户使用 Starter"></a><strong>3. 用户使用 Starter</strong></h4><h5 id="3-1-引入依赖"><a href="#3-1-引入依赖" class="headerlink" title="3.1 引入依赖"></a><strong>3.1 引入依赖</strong></h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.aliyun.oss<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aliyun-oss-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="3-2-配置参数（application-yml）"><a href="#3-2-配置参数（application-yml）" class="headerlink" title="3.2 配置参数（application.yml）"></a><strong>3.2 配置参数（<code>application.yml</code>）</strong></h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">aliyun:</span></span><br><span class="line">  <span class="attr">oss:</span></span><br><span class="line">    <span class="attr">endpoint:</span> <span class="string">https://oss-cn-hangzhou.aliyuncs.com</span></span><br><span class="line">    <span class="attr">accessKeyId:</span> <span class="string">your-key-id</span></span><br><span class="line">    <span class="attr">accessKeySecret:</span> <span class="string">your-key-secret</span></span><br><span class="line">    <span class="attr">bucketName:</span> <span class="string">your-bucket</span></span><br></pre></td></tr></table></figure><h5 id="3-3-直接注入使用"><a href="#3-3-直接注入使用" class="headerlink" title="3.3 直接注入使用"></a><strong>3.3 直接注入使用</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AliyunOSSOperator ossOperator; <span class="comment">// 自动注入</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">uploadFile</span><span class="params">()</span> &#123;</span><br><span class="line">        ossOperator.upload(...); <span class="comment">// 直接调用方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="关键问题解答"><a href="#关键问题解答" class="headerlink" title="关键问题解答"></a>关键问题解答</h4><h5 id="1-为什么需要构造函数？"><a href="#1-为什么需要构造函数？" class="headerlink" title="1. 为什么需要构造函数？"></a><strong>1. 为什么需要构造函数？</strong></h5><ul><li><strong>原因</strong>：Spring 无法通过 <code>@Component</code> 自动实例化第三方类，需手动在 <code>@Bean</code> 方法中构造对象。</li><li><strong>解决</strong>：在 <code>AliyunOSSOperator</code> 中显式定义构造函数，供 <code>AliyunOSSAutoConfiguration</code> 调用。</li></ul><h5 id="2-配置如何生效？"><a href="#2-配置如何生效？" class="headerlink" title="2. 配置如何生效？"></a><strong>2. 配置如何生效？</strong></h5><ul><li><code>@EnableConfigurationProperties</code> 将 <code>AliyunOSSProperties</code> 注册为 Bean。</li><li><code>application.yml</code> 中的配置通过 <code>@ConfigurationProperties</code> 绑定到 <code>AliyunOSSProperties</code> 对象。</li></ul><h5 id="3-自动配置触发条件"><a href="#3-自动配置触发条件" class="headerlink" title="3. 自动配置触发条件"></a><strong>3. 自动配置触发条件</strong></h5><ul><li><code>AutoConfiguration.imports</code> 文件告诉 Spring Boot 启动时加载 <code>AliyunOSSAutoConfiguration</code>。</li><li>用户无需手动 <code>@Import</code> 或扫描包。</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h4><ol><li>对于二者的 pom.xml :</li></ol><table><thead><tr><th align="center">模块</th><th align="center">Starter（依赖入口）</th><th align="center">Autoconfigure（实现逻辑）</th></tr></thead><tbody><tr><td align="center"><strong>依赖内容</strong></td><td align="center">只依赖 <code>autoconfigure</code> 模块</td><td align="center">依赖具体功能包（如阿里云SDK）</td></tr><tr><td align="center"><strong>文件内容</strong></td><td align="center">仅保留 <code>pom.xml</code></td><td align="center">保留 <code>src/</code> + <code>pom.xml</code></td></tr><tr><td align="center"><strong>必须修改项</strong></td><td align="center">添加对 <code>autoconfigure</code> 的依赖</td><td align="center">添加阿里云OSS SDK等具体依赖</td></tr></tbody></table><ol start="2"><li><p>最难理解的地方：</p><p> **<code>AliyunOSSProperties</code>**：</p><ul><li>通过 <code>@EnableConfigurationProperties</code> 直接在配置类中注册为 Bean</li></ul><p> **<code>AliyunOSSOperator</code>**：</p><ul><li>通过构造函数<strong>接收容器中的 <code>AliyunOSSProperties</code> Bean</strong>。</li><li><strong>无需手动创建或注入</strong>，完全由 Spring 管理。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中的会话，过滤与拦截</title>
      <link href="/2025/09/13/Java%E4%B8%AD%E7%9A%84%E4%BC%9A%E8%AF%9D%EF%BC%8C%E8%BF%87%E6%BB%A4%E4%B8%8E%E6%8B%A6%E6%88%AA/"/>
      <url>/2025/09/13/Java%E4%B8%AD%E7%9A%84%E4%BC%9A%E8%AF%9D%EF%BC%8C%E8%BF%87%E6%BB%A4%E4%B8%8E%E6%8B%A6%E6%88%AA/</url>
      
        <content type="html"><![CDATA[<h2 id="会话技术"><a href="#会话技术" class="headerlink" title="会话技术"></a>会话技术</h2><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p><strong>Cookie技术有三个自动：</strong></p><ul><li>服务器会 <strong>自动</strong> 的将 cookie 响应给浏览器。</li><li>浏览器接收到响应回来的数据之后，会 <strong>自动</strong> 的将 cookie 存储在浏览器本地。</li><li>在后续的请求当中，浏览器会 <strong>自动</strong> 的将 cookie 携带到服务器端。</li></ul><h3 id="Cookie的使用："><a href="#Cookie的使用：" class="headerlink" title="Cookie的使用："></a>Cookie的使用：</h3><ol><li><p>设置Cookie 服务端 ——&gt; 浏览器 </p><p>关键： 形参包含 HttpServletResponse</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CookieController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 设置 Cookie</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/setCookie&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">setCookie</span><span class="params">(HttpServletResponse response)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个 Cookie 对象</span></span><br><span class="line">        <span class="type">Cookie</span> <span class="variable">cookie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;user_token&quot;</span>, <span class="string">&quot;abc123&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 可选：配置 Cookie 属性</span></span><br><span class="line">        cookie.setPath(<span class="string">&quot;/&quot;</span>);               <span class="comment">// 作用路径（默认当前路径）</span></span><br><span class="line">        cookie.setMaxAge(<span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span>);    <span class="comment">// 有效期 1 天（单位：秒）</span></span><br><span class="line">        cookie.setHttpOnly(<span class="literal">true</span>);          <span class="comment">// 禁止 JS 访问（防 XSS）</span></span><br><span class="line">        cookie.setSecure(<span class="literal">false</span>);           <span class="comment">// 非 HTTPS 时设为 false（本地测试用）</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将 Cookie 添加到响应中</span></span><br><span class="line">        response.addCookie(cookie);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Cookie 设置成功！&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>读取&#x2F;删除Cookie 浏览器——&gt;服务端</p><p>依旧使用 HttpServletRequest：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/readCookie2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">readCookie2</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">    Cookie[] cookies = request.getCookies();</span><br><span class="line">    <span class="keyword">if</span> (cookies != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Cookie cookie : cookies) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;user_token&quot;</span>.equals(cookie.getName())) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;获取到的 Cookie 值: &quot;</span> + cookie.getValue();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Cookie 不存在或已过期！&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 删除 Cookie</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/deleteCookie&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">deleteCookie</span><span class="params">(HttpServletResponse response)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个同名的空 Cookie，并设置 MaxAge=0</span></span><br><span class="line">    <span class="type">Cookie</span> <span class="variable">cookie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;user_token&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    cookie.setPath(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">    cookie.setMaxAge(<span class="number">0</span>);  <span class="comment">// 立即过期</span></span><br><span class="line">        </span><br><span class="line">    response.addCookie(cookie);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Cookie 已删除！&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><ol><li><p>设置Session数据</p><p>HttpServletRequest</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SessionController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/setSession&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">setSession</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取当前 Session（如果不存在则自动创建）</span></span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 向 Session 中存储数据</span></span><br><span class="line">        session.setAttribute(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;Alice&quot;</span>);  </span><br><span class="line">        session.setAttribute(<span class="string">&quot;role&quot;</span>, <span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Session 数据已设置！&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>读取Session数据</p><p>依旧HttpServletRequest，读写不同之处仅为 getAttribute 和 setAttribute</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/getSession&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getSession</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">    <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession(<span class="literal">false</span>); <span class="comment">// 如果不存在，返回 null</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (session == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Session 不存在或已过期！&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> (String) session.getAttribute(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">role</span> <span class="operator">=</span> (String) session.getAttribute(<span class="string">&quot;role&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> String.format(<span class="string">&quot;Session 数据: user=%s, role=%s&quot;</span>, user, role);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/invalidateSession&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">invalidateSession</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">    <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession(<span class="literal">false</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (session != <span class="literal">null</span>) &#123;</span><br><span class="line">        session.invalidate(); <span class="comment">// 立即销毁 Session </span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Session 已销毁！&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Session 不存在！&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="令牌"><a href="#令牌" class="headerlink" title="令牌"></a>令牌</h2><h3 id="三部分组成"><a href="#三部分组成" class="headerlink" title="三部分组成"></a>三部分组成</h3><ul><li>第一部分：Header(头）， 记录令牌类型、签名算法等。 例如：{“alg”:”HS256”,”type”:”JWT”}</li><li>第二部分：Payload(有效载荷），携带一些自定义信息、默认信息等。 例如：{“id”:”1”,”username”:”Tom”}</li><li>第三部分：Signature(签名），防止Token被篡改、确保安全性。将header、payload，并加入指定秘钥，通过指定签名算法计算而来。</li></ul><h3 id="自定义JWT获取-解析类"><a href="#自定义JWT获取-解析类" class="headerlink" title="自定义JWT获取&#x2F;解析类"></a>自定义JWT获取&#x2F;解析类</h3><p>加密JWT的四个链式调用步骤：</p><ol><li>Jwts.builder().signWith(加密算法，人为给出加密字符串)</li><li>​                      .addClaims(传入要加密的map集合)</li><li>​                      .setExpiration(Date对象，规定过期时间)</li><li>​                      .compact(); 最终打包</li></ol><p>解密的四步链式调用：</p><ol><li><p>Jwts.parser()</p></li><li><p>​       .setSigningKey(加密时指定的加密字符串)</p></li><li><p>​       .parseClaimsJws(加密后的字符串)</p></li><li><p>​       .getBody()</p><p>——&gt; 用map接收</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtUtils</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">signKey</span> <span class="operator">=</span> <span class="string">&quot;SVRIRUlNQQ==&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Long</span> <span class="variable">expire</span> <span class="operator">=</span> <span class="number">43200000L</span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment">//生成JWT令牌</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">generateJwt</span><span class="params">(Map&lt;String,Object&gt; claims)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">jwt</span> <span class="operator">=</span> Jwts.builder()</span><br><span class="line">                .addClaims(claims)</span><br><span class="line">                .signWith(SignatureAlgorithm.HS256, signKey)</span><br><span class="line">                .setExpiration(<span class="keyword">new</span> <span class="title class_">Date</span>(System.currentTimeMillis() + expire))</span><br><span class="line">                .compact();</span><br><span class="line">        <span class="keyword">return</span> jwt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//解析JWT令牌</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Claims <span class="title function_">parseJWT</span><span class="params">(String jwt)</span>&#123;</span><br><span class="line">        <span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> Jwts.parser()</span><br><span class="line">                .setSigningKey(signKey)</span><br><span class="line">                .parseClaimsJws(jwt)</span><br><span class="line">                .getBody();</span><br><span class="line">        <span class="keyword">return</span> claims;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><p><strong>Filter表示过滤器，是 JavaWeb三大组件(Servlet、Filter、Listener)之一</strong>，也是现在web开发中唯一有一个还在用的</p><h3 id="Filter的使用："><a href="#Filter的使用：" class="headerlink" title="Filter的使用："></a>Filter的使用：</h3><ul><li>第1步，定义过滤器 ：1.定义一个类，实现 Filter 接口，并重写其所有方法。</li><li>第2步，配置过滤器：Filter类上加 @WebFilter 注解，配置拦截资源的路径。引导类上加 @ServletComponentScan 开启Servlet组件支持</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebFilter(urlPatterns = &quot;/*&quot;)</span>  <span class="comment">//2.1配置拦截路径</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;  <span class="comment">//1.定义类，实现接口并重写方法</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//初始化方法, web服务器启动, 创建Filter实例时调用, 只调用一次</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;init ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拦截到请求时,调用该方法,可以调用多次</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;拦截到了请求...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//销毁方法, web服务器关闭时调用, 只调用一次</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;destroy ... &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//。。。。。。。遥远的SpringBoot启动类中。。。:</span></span><br><span class="line"><span class="meta">@ServletComponentScan</span> <span class="comment">//2.2开启对Servlet组件的支持</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TliasManagementApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(TliasManagementApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog_imgimage-20250913154225970.png" alt="image-20250913154225970" style="zoom: 67%;" /><p>具体实现：</p><p>核心有三点：</p><ol><li>把参数中的 ServletRequest 和 ServletRequest 强转成HttpServletRequest 和 HttpServletResponse，从request中获取路径信息，token信息</li><li>放行调用chain.doFilter方法，参数是request和response，这俩本来就是要传的，所以相当于放行了</li><li>chain.deFilter放行以后，会等相关所有方法都执行完，在回到他的下一条语句进行执行</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@WebFilter(urlPatterns = &quot;/*&quot;)</span>  <span class="comment">//规定拦截路径</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TokenFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest req, ServletRequest resp, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> (HttpServletRequest) req;  <span class="comment">//依旧HttpServletRequest</span></span><br><span class="line">        <span class="type">HttpServletResponse</span> <span class="variable">response</span> <span class="operator">=</span> (HttpServletResponse) resp;</span><br><span class="line">        <span class="comment">//1. 获取请求url。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> request.getRequestURL().toString();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 判断请求url中是否包含login，如果包含，说明是登录操作，放行。</span></span><br><span class="line">        <span class="keyword">if</span>(url.contains(<span class="string">&quot;login&quot;</span>))&#123; <span class="comment">//登录请求</span></span><br><span class="line">            log.info(<span class="string">&quot;登录请求 , 直接放行&quot;</span>);</span><br><span class="line">            chain.doFilter(request, response);  <span class="comment">//放行</span></span><br><span class="line">            log.info(<span class="string">&quot;登陆后的语句&quot;</span>);<span class="comment">//这个也会执行完</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 获取请求头中的令牌（token）。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">jwt</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;token&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 判断令牌是否存在，如果不存在，返回错误结果（未登录）。</span></span><br><span class="line">        <span class="keyword">if</span>(!StringUtils.hasLength(jwt))&#123; <span class="comment">//jwt为空</span></span><br><span class="line">            log.info(<span class="string">&quot;获取到jwt令牌为空, 返回错误结果&quot;</span>);</span><br><span class="line">            response.setStatus(HttpStatus.SC_UNAUTHORIZED);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5. 解析token，如果解析失败，返回错误结果（未登录）。</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            JwtUtils.parseJWT(jwt);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            log.info(<span class="string">&quot;解析令牌失败, 返回错误结果&quot;</span>);</span><br><span class="line">            response.setStatus(HttpStatus.SC_UNAUTHORIZED);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6. 放行。</span></span><br><span class="line">        log.info(<span class="string">&quot;令牌合法, 放行&quot;</span>);</span><br><span class="line">        chain.doFilter(request , response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>拦截路径</th><th>urlPatterns值</th><th>含义</th></tr></thead><tbody><tr><td>拦截具体路径</td><td>&#x2F;login</td><td>只有访问 &#x2F;login 路径时，才会被拦截</td></tr><tr><td>目录拦截</td><td>&#x2F;emps&#x2F;*</td><td>访问&#x2F;emps下的所有资源，都会被拦截</td></tr><tr><td>拦截所有</td><td>&#x2F;*</td><td>访问所有资源，都会被拦截</td></tr></tbody></table><h3 id="过滤器链"><a href="#过滤器链" class="headerlink" title="过滤器链"></a>过滤器链</h3><p>过滤器链上过滤器的执行顺序：注解配置的Filter，优先级是按照过滤器类名（字符串）的自然排序。 比如：</p><p>AbcFilter DemoFilter</p><p>这两个过滤器来说，AbcFilter 会先执行，DemoFilter会后执行，访问完web资源之后，还会回到过滤器当中来执行过滤器放行后的逻辑，而在执行放行后的逻辑的时候，<strong>顺序是反着的</strong></p><h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><p><strong>拦截器是SpringBoot提供的</strong></p><h3 id="使用拦截器"><a href="#使用拦截器" class="headerlink" title="使用拦截器"></a>使用拦截器</h3><ol><li><p>定义拦截器  ——&gt;  实现HandlerInterceptor接口，并重写其所有方法</p></li><li><p>使用拦截器  ——&gt; 创建一个配置类实现 WebMvcConfigurer 接口，并重写 addInterceptors 方法</p><p>在方法中，将拦截器对象通过 addInterceptor 方法 传入 registry ，链式调用 addPathPatterns 方法指定拦截路径</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义拦截器</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="comment">//目标资源方法执行前执行。 返回true：放行    返回false：不放行</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//1. 获取请求url。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> request.getRequestURL().toString();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 判断请求url中是否包含login，如果包含，说明是登录操作，放行。</span></span><br><span class="line">        <span class="keyword">if</span>(url.contains(<span class="string">&quot;login&quot;</span>))&#123; <span class="comment">//登录请求</span></span><br><span class="line">            log.info(<span class="string">&quot;登录请求 , 直接放行&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 获取请求头中的令牌（token）。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">jwt</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;token&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 判断令牌是否存在，如果不存在，返回错误结果（未登录）。</span></span><br><span class="line">        <span class="keyword">if</span>(!StringUtils.hasLength(jwt))&#123; <span class="comment">//jwt为空</span></span><br><span class="line">            log.info(<span class="string">&quot;获取到jwt令牌为空, 返回错误结果&quot;</span>);</span><br><span class="line">            response.setStatus(HttpStatus.SC_UNAUTHORIZED);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5. 解析token，如果解析失败，返回错误结果（未登录）。</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            JwtUtils.parseJWT(jwt);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            log.info(<span class="string">&quot;解析令牌失败, 返回错误结果&quot;</span>);</span><br><span class="line">            response.setStatus(HttpStatus.SC_UNAUTHORIZED);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6. 放行。</span></span><br><span class="line">        log.info(<span class="string">&quot;令牌合法, 放行&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>  <span class="comment">//加注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自定义的拦截器对象</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DemoInterceptor demoInterceptor;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">       <span class="comment">//注册自定义拦截器对象</span></span><br><span class="line">        registry.addInterceptor(demoInterceptor).addPathPatterns(<span class="string">&quot;/**&quot;</span>);<span class="comment">//设置拦截器拦截的请求路径（ /** 表示拦截所有请求）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拦截路径自定义：通过 addPathPatterns 和 excludePathPatterns 方法</p><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog_imgimage-20250913160713870.png" alt="image-20250913160713870"></p><p>拦截器拦截路径：</p><table><thead><tr><th>拦截路径</th><th>含义</th><th>举例</th></tr></thead><tbody><tr><td>&#x2F;*</td><td>一级路径</td><td>能匹配&#x2F;depts，&#x2F;emps，&#x2F;login，不能匹配 &#x2F;depts&#x2F;1</td></tr><tr><td>&#x2F;**</td><td>任意级路径</td><td>能匹配&#x2F;depts，&#x2F;depts&#x2F;1，&#x2F;depts&#x2F;1&#x2F;2</td></tr><tr><td>&#x2F;depts&#x2F;*</td><td>&#x2F;depts下的一级路径</td><td>能匹配&#x2F;depts&#x2F;1，不能匹配&#x2F;depts&#x2F;1&#x2F;2，&#x2F;depts</td></tr><tr><td>&#x2F;depts&#x2F;**</td><td>&#x2F;depts下的任意级路径</td><td>能匹配&#x2F;depts，&#x2F;depts&#x2F;1，&#x2F;depts&#x2F;1&#x2F;2，不能匹配&#x2F;emps&#x2F;1</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog_imgimage-20250913160828177.png" alt="image-20250913160828177"></p><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog_imgimage-20250913161009177.png" alt="image-20250913161009177"></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go多态和Java多态异同点</title>
      <link href="/2025/09/10/Go%E5%92%8CJava%E5%8F%8D%E5%B0%84%E5%BC%82%E5%90%8C%E7%82%B9%20/"/>
      <url>/2025/09/10/Go%E5%92%8CJava%E5%8F%8D%E5%B0%84%E5%BC%82%E5%90%8C%E7%82%B9%20/</url>
      
        <content type="html"><![CDATA[<h2 id="Java反射："><a href="#Java反射：" class="headerlink" title="Java反射："></a>Java反射：</h2><p>万物皆对象，无论是类，方法，还是属性都有自己的对象类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//==========获取class对象============----------------------------</span></span><br><span class="line"><span class="comment">//通过全限定名/类名</span></span><br><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;com.dhrjava.refelctTestClass&quot;</span>);</span><br><span class="line">Class&lt;?&gt; clazz = String.class;</span><br><span class="line"><span class="comment">//通过已初始化对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line">Class&lt;?&gt; clazz = str.getClass();</span><br><span class="line"><span class="comment">//=========现在已经有了clazz对象=======-----------------------------</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//===========创建实例=================----------------------------</span></span><br><span class="line"><span class="comment">//通过 Constructor</span></span><br><span class="line">Constructor&lt;?&gt; constructor = clazz.getDeclaredConstructor();</span><br><span class="line"><span class="type">Object</span> <span class="variable">obj2</span> <span class="operator">=</span> constructor.newInstance();</span><br><span class="line"><span class="comment">//带参数</span></span><br><span class="line">Constructor&lt;?&gt; paramConstructor = clazz.getDeclaredConstructor(String.class);</span><br><span class="line"><span class="type">Object</span> <span class="variable">obj3</span> <span class="operator">=</span> paramConstructor.newInstance(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="comment">//==========实例创建完成===============------------------------------</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//==========获取字段并修改值==================-----------------------</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;name&quot;</span>); <span class="comment">//传入要改的字段</span></span><br><span class="line">filed.setAccessible(<span class="literal">true</span>);<span class="comment">//啥都能改，突破限制</span></span><br><span class="line">field.set(obj,<span class="string">&quot;Alice&quot;</span>);<span class="comment">//第一个参数传入实例对象，第二个参数传入更改后的内容，无需传入要改什么，因为要改什么由field对象已经获取</span></span><br><span class="line"><span class="comment">//=======================================---------------------------</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//==========方法调用===================------------------------------</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;sayHello&quot;</span>, String.class,Integer.class);</span><br><span class="line">method.setAccessible(<span class="literal">true</span>); <span class="comment">// 允许调用私有方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用方法</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(obj, <span class="string">&quot;Alice&quot;</span>,<span class="number">18</span>); <span class="comment">// obj 是目标对象，后面是参数</span></span><br><span class="line"><span class="comment">//调用静态方法</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">staticMethod</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;staticMethodTest&quot;</span>,String.class,Book.class);</span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> (String )staticMethod.invoke(<span class="literal">null</span>,<span class="string">&quot;二班&quot;</span>,javaBook); <span class="comment">//如果有返回值，需要强制转换，因为invoke返回值是object类型的</span></span><br></pre></td></tr></table></figure><h2 id="Golang反射："><a href="#Golang反射：" class="headerlink" title="Golang反射："></a>Golang反射：</h2><p>golang的特点是扁平化，他的反射不是像java那样，所有继承自object类，看起来层次分明，而是通过指针和万能接口在平面上操作</p><p>在 Go 中，反射主要通过两个核心类型实现：</p><ul><li><code>reflect.Type</code>：表示类型信息</li><li><code>reflect.Value</code>：表示值信息</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ========== 定义示例结构体 ==============</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">Name    <span class="type">string</span> <span class="string">`json:&quot;name&quot; validate:&quot;required&quot;`</span></span><br><span class="line">Age     <span class="type">int</span>    <span class="string">`json:&quot;age&quot;`</span></span><br><span class="line">Address <span class="type">string</span> <span class="string">`json:&quot;address,omitempty&quot;`</span></span><br><span class="line">private <span class="type">string</span> <span class="comment">// 小写开头的私有字段</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构体方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span></span> UpdateName(newName <span class="type">string</span>) &#123;</span><br><span class="line">p.Name = newName</span><br><span class="line">fmt.Printf(<span class="string">&quot;姓名已更新为: %s\n&quot;</span>, newName)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span></span> Greet() <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;你好，我是%s，今年%d岁&quot;</span>, p.Name, p.Age)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//===============================================</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ========== 2. 反射基础：获取类型和值信息 ========</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">basicReflection</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 示例变量</span></span><br><span class="line">str := <span class="string">&quot;Hello, Reflection!&quot;</span></span><br><span class="line">num := <span class="number">42</span></span><br><span class="line">person := Person&#123;Name: <span class="string">&quot;张三&quot;</span>, Age: <span class="number">30</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (1) 获取类型信息</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;字符串类型: %v\n&quot;</span>, reflect.TypeOf(str))</span><br><span class="line">fmt.Printf(<span class="string">&quot;整数类型: %v\n&quot;</span>, reflect.TypeOf(num))</span><br><span class="line">fmt.Printf(<span class="string">&quot;结构体类型: %v\n&quot;</span>, reflect.TypeOf(person))</span><br><span class="line"></span><br><span class="line"><span class="comment">// (2) 获取值信息</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;字符串值: %v\n&quot;</span>, reflect.ValueOf(str))</span><br><span class="line">fmt.Printf(<span class="string">&quot;整数值: %v\n&quot;</span>, reflect.ValueOf(num))</span><br><span class="line">fmt.Printf(<span class="string">&quot;结构体值: %v\n&quot;</span>, reflect.ValueOf(person))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//==================================================</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ========== 3. 反射操作结构体 =====================</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">structReflection</span><span class="params">(input <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">val := reflect.ValueOf(input)</span><br><span class="line">typ := reflect.TypeOf(input)</span><br><span class="line"><span class="comment">// 检查是否是指针</span></span><br><span class="line"><span class="keyword">if</span> val.Kind() == reflect.Ptr &#123;</span><br><span class="line">val = val.Elem() <span class="comment">// 获取指针指向的值</span></span><br><span class="line">typ = typ.Elem()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查是否是结构体</span></span><br><span class="line"><span class="keyword">if</span> val.Kind() != reflect.Struct &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;输入的不是结构体&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (1) 读取结构体信息</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;结构体名称: %s\n&quot;</span>, typ.Name())</span><br><span class="line">fmt.Printf(<span class="string">&quot;字段数量: %d\n&quot;</span>, val.NumField())</span><br><span class="line"></span><br><span class="line"><span class="comment">// (2) 遍历字段</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; val.NumField(); i++ &#123;</span><br><span class="line">field := typ.Field(i)</span><br><span class="line">fieldVal := val.Field(i)</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;字段 %d: %s\n&quot;</span>, i, field.Name)</span><br><span class="line">fmt.Printf(<span class="string">&quot;  类型: %v\n&quot;</span>, field.Type)</span><br><span class="line">fmt.Printf(<span class="string">&quot;  标签: %v\n&quot;</span>, field.Tag)</span><br><span class="line">fmt.Printf(<span class="string">&quot;  值: %v\n&quot;</span>, fieldVal.Interface())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取json标签</span></span><br><span class="line"><span class="keyword">if</span> jsonTag := field.Tag.Get(<span class="string">&quot;json&quot;</span>); jsonTag != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;  json标签: %s\n&quot;</span>, jsonTag)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (3) 修改字段值</span></span><br><span class="line"><span class="keyword">if</span> val.CanAddr() &#123;</span><br><span class="line">nameField := val.FieldByName(<span class="string">&quot;Name&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> nameField.IsValid() &amp;&amp; nameField.CanSet() &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;修改前Name: %v\n&quot;</span>, nameField.Interface())</span><br><span class="line">nameField.SetString(<span class="string">&quot;李四&quot;</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;修改后Name: %v\n&quot;</span>, nameField.Interface())</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;无法修改Name字段&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试修改私有字段 (会失败)</span></span><br><span class="line">privateField := val.FieldByName(<span class="string">&quot;private&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> privateField.IsValid() &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;找到private字段&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> privateField.CanSet() &#123;</span><br><span class="line">privateField.SetString(<span class="string">&quot;尝试修改&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;无法修改private字段(因为是私有的)&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;值不可寻址，无法修改字段&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//=================================================</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ========== 4. 反射调用方法 ======================</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">methodReflection</span><span class="params">(input <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">val := reflect.ValueOf(input)</span><br><span class="line">typ := reflect.TypeOf(input)</span><br><span class="line"></span><br><span class="line"><span class="comment">// (1) 调用无参数方法</span></span><br><span class="line">myMethod := val.MethodByName(<span class="string">&quot;myMethod&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> myMethod.IsValid() &#123;</span><br><span class="line">results := greetMethod.Call(<span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(results) &gt; <span class="number">0</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;方法返回:&quot;</span>, results[<span class="number">0</span>].String())</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;未找到方法&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment">// (2) 调用带参数方法</span></span><br><span class="line">updateMethod := val.MethodByName(<span class="string">&quot;UpdateName&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> updateMethod.IsValid() &#123;</span><br><span class="line">args := []reflect.Value&#123;</span><br><span class="line">reflect.ValueOf(<span class="string">&quot;王五&quot;</span>),</span><br><span class="line">&#125;</span><br><span class="line">updateMethod.Call(args)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;未找到UpdateName方法&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//假设有两个参数</span></span><br><span class="line">    method := val.MethodByName(<span class="string">&quot;UpdateInfo&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> !method.IsValid() &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;未找到UpdateInfo方法&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    args := []reflect.Value&#123;</span><br><span class="line">        reflect.ValueOf(<span class="string">&quot;李四&quot;</span>),     <span class="comment">// 第一个参数：name</span></span><br><span class="line">        reflect.ValueOf(<span class="number">35</span>),       <span class="comment">// 第二个参数：age</span></span><br><span class="line">        reflect.ValueOf(<span class="string">&quot;上海&quot;</span>),     <span class="comment">// 第三个参数：address</span></span><br><span class="line">    &#125; <span class="comment">//通过reflect.ValueOf传参数值</span></span><br><span class="line">    results := method.Call(args)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="comment">// (3) 查看所有方法</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; typ.NumMethod(); i++ &#123;</span><br><span class="line">method := typ.Method(i)</span><br><span class="line">fmt.Printf(<span class="string">&quot;方法 %d: %s\n&quot;</span>, i, method.Name)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//==============================================</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ========== 5. 反射创建实例 ===================</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createInstance</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (1) 获取类型信息</span></span><br><span class="line">personType := reflect.TypeOf(Person&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// (2) 创建新实例</span></span><br><span class="line">newPersonVal := reflect.New(personType) <span class="comment">// 返回 *Person 的 Value</span></span><br><span class="line">newPerson := newPersonVal.Interface().(*Person)</span><br><span class="line">fmt.Printf(<span class="string">&quot;新实例默认值: %+v\n&quot;</span>, *newPerson)</span><br><span class="line"></span><br><span class="line"><span class="comment">// (3) 设置字段值</span></span><br><span class="line">elem := newPersonVal.Elem()</span><br><span class="line">nameField := elem.FieldByName(<span class="string">&quot;Name&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> nameField.CanSet() &#123;</span><br><span class="line">nameField.SetString(<span class="string">&quot;赵六&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">ageField := elem.FieldByName(<span class="string">&quot;Age&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> ageField.CanSet() &#123;</span><br><span class="line">ageField.SetInt(<span class="number">35</span>)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;设置后的实例: %+v\n&quot;</span>, *newPerson)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//==============================================</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ========== 6. 反射实际应用 ===================</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">practicalApplications</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// (1) 简易对象拷贝</span></span><br><span class="line">fmt.Println(<span class="string">&quot;\n--- 对象拷贝 ---&quot;</span>)</span><br><span class="line">src := Person&#123;Name: <span class="string">&quot;源对象&quot;</span>, Age: <span class="number">40</span>&#125;</span><br><span class="line"><span class="keyword">var</span> dst Person</span><br><span class="line"></span><br><span class="line">srcVal := reflect.ValueOf(&amp;src).Elem()</span><br><span class="line">dstVal := reflect.ValueOf(&amp;dst).Elem()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; srcVal.NumField(); i++ &#123;</span><br><span class="line">fieldName := srcVal.Type().Field(i).Name</span><br><span class="line">srcField := srcVal.FieldByName(fieldName)</span><br><span class="line">dstField := dstVal.FieldByName(fieldName)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> dstField.CanSet() &#123;</span><br><span class="line">dstField.Set(srcField)</span><br><span class="line">fmt.Printf(<span class="string">&quot;拷贝字段 %s: %v\n&quot;</span>, fieldName, srcField.Interface())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;拷贝结果: %+v\n&quot;</span>, dst)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 1. 反射基础</span></span><br><span class="line">basicReflection()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 结构体反射操作</span></span><br><span class="line">person := Person&#123;</span><br><span class="line">Name:    <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">Age:     <span class="number">30</span>,</span><br><span class="line">Address: <span class="string">&quot;北京&quot;</span>,</span><br><span class="line">private: <span class="string">&quot;私有数据&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">structReflection(&amp;person) <span class="comment">// 传入指针以便修改</span></span><br><span class="line">structReflection(person)  <span class="comment">// 传入值(仅查看)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 方法反射调用</span></span><br><span class="line">methodReflection(&amp;person)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 反射创建实例</span></span><br><span class="line">createInstance()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 反射实际应用</span></span><br><span class="line">practicalApplications()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*------------------------------</span></span><br><span class="line"><span class="comment">关键点总结</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">指针与非指针：</span></span><br><span class="line"><span class="comment">修改值需要传递指针</span></span><br><span class="line"><span class="comment">使用 Elem() 获取指针指向的值</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">可设置性检查：</span></span><br><span class="line"><span class="comment">修改前必须检查 CanSet()</span></span><br><span class="line"><span class="comment">私有字段无法通过反射修改</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">方法调用：</span></span><br><span class="line"><span class="comment">参数需要包装为 []reflect.Value</span></span><br><span class="line"><span class="comment">返回值也是 []reflect.Value</span></span><br><span class="line"><span class="comment">--------------------------------*/</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="综合对比"><a href="#综合对比" class="headerlink" title="综合对比"></a>综合对比</h2><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog_imgimage-20250912103742900.png" alt="image-20250912103742900"></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go和Java多线程</title>
      <link href="/2025/09/07/Go%E5%92%8CJava%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2025/09/07/Go%E5%92%8CJava%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-与-Go-并发编程对比"><a href="#Java-与-Go-并发编程对比" class="headerlink" title="Java 与 Go 并发编程对比"></a>Java 与 Go 并发编程对比</h1><h2 id="1-并发模型核心理念"><a href="#1-并发模型核心理念" class="headerlink" title="1 并发模型核心理念"></a>1 并发模型核心理念</h2><p>Java 和 Go 在并发编程上采用了截然不同的哲学和实现模型。</p><p><strong>Java</strong> 采用<strong>共享内存模型</strong>。其并发基于操作系统线程（内核线程），你编写的每个 <code>Thread</code> 都直接对应一个操作系统线程。多个线程共享进程内存空间，这使得数据共享直接，但也带来了复杂的<strong>同步问题</strong>。线程间通信主要通过读写共享变量，并使用锁（如 <code>synchronized</code>）或其他同步机制（如 <code>wait()/notify()</code>）来协调访问、避免数据竞争，Java 的线程是<strong>抢占式</strong>的，由操作系统内核进行调度，这可能导致调度开销较大，尤其是在线程数量很多时。</p><p><strong>Go</strong> 则推崇 <strong>“通过通信来共享内存”</strong> 而非“通过共享内存来通信”。其核心是 <strong>goroutine</strong>，这是一种由 Go 运行时管理的<strong>轻量级线程</strong>（协程）。大量 goroutine 可以在少量操作系统线程上高效复用。Go 运行时调度器采用 <strong>GPM 模型</strong>（Goroutine, Processor, Machine），在用户态进行协作式调度，调度开销极低。goroutine 间的通信首选**通道 (channel)**，它是一种类型安全的队列，用于在不同的 goroutine 之间安全地传递数据和同步执行。虽然 Go 也提供了传统的同步原语（如 <code>sync.Mutex</code>），但更鼓励使用 channel 来解耦并发操作。</p><table><thead><tr><th align="left">特性</th><th align="left">Java</th><th align="left">Go</th></tr></thead><tbody><tr><td align="left"><strong>并发单元</strong></td><td align="left">线程 (Thread), 重量级</td><td align="left">协程 (Goroutine), 轻量级</td></tr><tr><td align="left"><strong>创建方式</strong></td><td align="left">继承 <code>Thread</code> 类或实现 <code>Runnable</code>&#x2F;<code>Callable</code> 接口</td><td align="left"><code>go</code> 关键字</td></tr><tr><td align="left"><strong>调度机制</strong></td><td align="left">操作系统内核抢占式调度</td><td align="left">Go 运行时协作式调度 (GPM 模型)</td></tr><tr><td align="left"><strong>内存开销</strong></td><td align="left">较大 (默认约 1MB&#x2F;线程)</td><td align="left">极小 (初始约 2KB&#x2F;goroutine)</td></tr><tr><td align="left"><strong>通信机制</strong></td><td align="left">主要通过<strong>共享内存</strong>，使用锁同步 (<code>synchronized</code>, <code>Lock</code>)</td><td align="left">主要通过<strong>通道 (Channel)</strong></td></tr><tr><td align="left"><strong>设计哲学</strong></td><td align="left">通过共享内存进行通信</td><td align="left">通过通信来共享内存</td></tr><tr><td align="left"><strong>优势场景</strong></td><td align="left">CPU 密集型任务、复杂的企业级应用</td><td align="left">I&#x2F;O 密集型任务、高并发网络服务</td></tr></tbody></table><h2 id="2-并发单元的创建与管理"><a href="#2-并发单元的创建与管理" class="headerlink" title="2 并发单元的创建与管理"></a>2 并发单元的创建与管理</h2><h3 id="2-1-Java-线程创建与管理"><a href="#2-1-Java-线程创建与管理" class="headerlink" title="2.1 Java 线程创建与管理"></a>2.1 Java 线程创建与管理</h3><p>Java 中线程是相对重量级的资源，直接由操作系统调度。</p><ul><li><p><strong>创建方式</strong>：</p><p>继承 <code>Thread</code> 类，重写 run()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread running&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">MyThread</span>().start();</span><br></pre></td></tr></table></figure><p>实现 <code>Runnable</code> 接口（更推荐）：避免继承的局限性，更灵活。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Runnable running&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure><p>实现 <code>Callable</code> 接口：可以返回结果或抛出异常，通常与FutureTask和线程池结合使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Callable&lt;String&gt; task = () -&gt; &#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Task Done&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line">FutureTask&lt;String&gt; future = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(task);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(future).start();</span><br><span class="line">System.out.println(future.get()); <span class="comment">// 获取返回值</span></span><br></pre></td></tr></table></figure><p>**线程池 (ThreadPool)**：为减少频繁创建和销毁线程的开销，Java 提供了强大的线程池支持 (<code>java.util.concurrent.ExecutorService</code>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例：创建固定大小的线程池</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">4</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    executor.submit(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Task executed by &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">executor.shutdown();</span><br></pre></td></tr></table></figure><p><strong>核心参数</strong>：</p><ul><li><code>corePoolSize</code>: 核心线程数。</li><li><code>maximumPoolSize</code>: 最大线程数。</li><li><code>workQueue</code>: 任务队列（如 <code>ArrayBlockingQueue</code>, <code>LinkedBlockingQueue</code>）。</li><li><code>RejectedExecutionHandler</code>: 拒绝策略（如 <code>AbortPolicy</code> 抛出异常）。</li></ul></li></ul><h3 id="2-2-Go-Goroutine-创建与管理"><a href="#2-2-Go-Goroutine-创建与管理" class="headerlink" title="2.2 Go Goroutine 创建与管理"></a>2.2 Go Goroutine 创建与管理</h3><p>Goroutine 是 Go 的轻量级并发单元，由 Go 运行时调度，开销极小。</p><ul><li><p><strong>创建方式</strong>：使用 <code>go</code> 关键字后跟函数调用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Hello from Goroutine!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> sayHello() <span class="comment">// 启动一个 goroutine</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Hello from Main!&quot;</span>)</span><br><span class="line">    time.Sleep(time.Second) <span class="comment">// 防止主 goroutine 退出太快</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>等待 Goroutine 完成</strong>：常用 <code>sync.WaitGroup</code> 来同步。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>) <span class="comment">// 增加计数器</span></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(id <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done() <span class="comment">// 完成后计数器减1</span></span><br><span class="line">            fmt.Printf(<span class="string">&quot;Goroutine %d done\n&quot;</span>, id)</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wg.Wait() <span class="comment">// 阻塞直到所有 goroutine 完成</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;All goroutines finished.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-通信与同步机制"><a href="#3-通信与同步机制" class="headerlink" title="3 通信与同步机制"></a>3 通信与同步机制</h2><h3 id="3-1-Java-的共享内存与锁"><a href="#3-1-Java-的共享内存与锁" class="headerlink" title="3.1 Java 的共享内存与锁"></a>3.1 Java 的共享内存与锁</h3><p>Java 线程间通信主要通过共享内存，因此同步是关键。</p><ul><li><p><strong>synchronized 关键字</strong>：用于修饰方法或代码块，确保同一时间只有一个线程可以执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">    counter++; <span class="comment">// 同步方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123; <span class="comment">// 同步代码块</span></span><br><span class="line">        <span class="comment">// ... </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-2-Go-的-Channel-与-Select"><a href="#3-2-Go-的-Channel-与-Select" class="headerlink" title="3.2 Go 的 Channel 与 Select"></a>3.2 Go 的 Channel 与 Select</h3><p>Go 推荐通过 Channel 在 Goroutine 间进行通信和同步。</p><ul><li><p>**Channel (通道)**：是一种类型化的管道，用于在不同的 Goroutine 之间传递数据。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>) <span class="comment">// 创建一个传递 int 的无缓冲 channel</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        ch &lt;- <span class="number">42</span> <span class="comment">// 向 channel 发送数据</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    value := &lt;-ch <span class="comment">// 从 channel 接收数据</span></span><br><span class="line">    fmt.Println(value) <span class="comment">// 输出: 42</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>无缓冲 Channel</strong>：发送和接收会阻塞，直到另一方准备好，是强同步的。</li><li><strong>有缓冲 Channel</strong>：<code>make(chan int, size)</code>，只有在缓冲区满或空时才会阻塞。</li></ul></li><li><p><strong>Select 语句</strong>：用于同时处理多个 Channel，类似于 <code>switch</code> 但专为 Channel 设计。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> msg1 := &lt;-ch1:</span><br><span class="line">    fmt.Println(<span class="string">&quot;Received&quot;</span>, msg1)</span><br><span class="line"><span class="keyword">case</span> msg2 := &lt;-ch2:</span><br><span class="line">    fmt.Println(<span class="string">&quot;Received&quot;</span>, msg2)</span><br><span class="line"><span class="keyword">case</span> ch3 &lt;- <span class="number">3</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;Sent 3&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;No communication&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>传统的同步原语</strong>：Go 也在 <code>sync</code> 包中提供了 <code>Mutex</code>, <code>RWMutex</code>, <code>Once</code> 等，用于更复杂的场景或性能关键处。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> counter <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> mu sync.Mutex</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">increment</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> mu.Unlock() <span class="comment">// 使用 defer 确保解锁</span></span><br><span class="line">    counter++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="4-使用习惯与注意事项"><a href="#4-使用习惯与注意事项" class="headerlink" title="4 使用习惯与注意事项"></a>4 使用习惯与注意事项</h2><h3 id="4-1-Java-并发编程注意事项"><a href="#4-1-Java-并发编程注意事项" class="headerlink" title="4.1 Java 并发编程注意事项"></a>4.1 Java 并发编程注意事项</h3><ul><li><strong>线程安全</strong>：始终注意对共享资源的访问。优先使用线程安全集合（如 <code>ConcurrentHashMap</code>）。</li><li><strong>避免死锁</strong>：确保锁的获取顺序一致，考虑使用定时锁尝试（<code>tryLock</code>）。</li><li>性能考量<ul><li>线程创建和上下文切换开销大，<strong>务必使用线程池</strong>。</li><li>锁竞争会严重降低性能，尽量减少临界区范围。</li></ul></li><li><strong>复杂性问题</strong>：多线程代码难以编写、调试和维护。充分利用 <code>java.util.concurrent</code> 包中的高级工具（如 <code>CountDownLatch</code>, <code>CyclicBarrier</code>, <code>Semaphore</code>）。</li></ul><h3 id="4-2-Go-并发编程注意事项"><a href="#4-2-Go-并发编程注意事项" class="headerlink" title="4.2 Go 并发编程注意事项"></a>4.2 Go 并发编程注意事项</h3><ul><li><p>Channel 使用原则：</p><ul><li><strong>关闭 Channel</strong>：由发送方关闭 Channel，接收方可通过 <code>val, ok := &lt;-ch</code> 判断是否关闭。</li><li><strong>避免泄露</strong>：不使用的 Goroutine 要确保能正常结束，防止内存泄露。</li></ul></li><li><p>Goroutine 泄漏</p><p>：如果 Goroutine 启动后永远阻塞（如在一个再无人发送的 Channel 上等待），会导致泄漏。使用 context.Context 来实现取消和超时机制</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ctx, cancel := context.WithTimeout(context.Background(), <span class="number">2</span>*time.Second)</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(<span class="number">5</span> * time.Second): <span class="comment">//5秒超时</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Work done&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">    fmt.Println(<span class="string">&quot;Cancelled or timeout:&quot;</span>, ctx.Err()) <span class="comment">//两秒超时</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="context和After区别："><a href="#context和After区别：" class="headerlink" title="context和After区别："></a><strong>context和After区别</strong>：</h4><p>context是从开始创建的时候开始计时的，After是从调用的那一刻开始计时的</p><p>context可以手动cancel()取消</p><p>context父取消，子也会取消</p><h4 id="父子context："><a href="#父子context：" class="headerlink" title="父子context："></a><strong>父子context：</strong></h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 父 Context：3秒超时</span></span><br><span class="line">    parentCtx, cancel := context.WithTimeout(context.Background(), <span class="number">3</span>*time.Second)</span><br><span class="line">    <span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 子 Context：5秒超时（实际受父 Context 约束，最多3秒）</span></span><br><span class="line">    childCtx := context.WithTimeout(parentCtx, <span class="number">5</span>*time.Second)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动子任务</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">            fmt.Println(<span class="string">&quot;子任务被取消:&quot;</span>, ctx.Err()) <span class="comment">// 实际由父 Context 触发</span></span><br><span class="line">        <span class="keyword">case</span> &lt;-time.After(<span class="number">4</span> * time.Second):</span><br><span class="line">            fmt.Println(<span class="string">&quot;子任务完成&quot;</span>) <span class="comment">// 不会执行！</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;(childCtx)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待父 Context 超时</span></span><br><span class="line">    &lt;-parentCtx.Done()</span><br><span class="line">    fmt.Println(<span class="string">&quot;父任务超时&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">场景</th><th align="center">示例</th></tr></thead><tbody><tr><td align="center"><strong>微服务调用链</strong></td><td align="center">A 服务调用 B 服务时，传递父 Context 确保统一超时和取消。</td></tr><tr><td align="center"><strong>HTTP 请求嵌套</strong></td><td align="center">主请求设置超时，子请求（如数据库查询）继承该超时。</td></tr><tr><td align="center"><strong>跨 Goroutine 任务</strong></td><td align="center">主任务取消时，自动终止所有关联的子任务。</td></tr><tr><td align="center"><strong>链路追踪</strong></td><td align="center">在父 Context 中存储 TraceID，子 Context 自动继承。</td></tr></tbody></table></li><li><p>循环变量捕获：在循环中启动 Goroutine 时，务必将循环变量作为参数传入，否则所有 Goroutine 可能会共享同一个（最终）变量值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示范</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(i) <span class="comment">// 很可能全部打印5</span></span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确做法</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(id <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        fmt.Println(id)</span><br><span class="line">    &#125;(i) <span class="comment">// 将 i 作为参数传入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>不要过度使用 Goroutine</strong>：虽然轻量，但并非无限。控制并发数量（例如使用带缓冲的 Channel 作为信号量或 worker pool）。</p></li></ul><h2 id="5-性能特点与适用场景"><a href="#5-性能特点与适用场景" class="headerlink" title="5 性能特点与适用场景"></a>5 性能特点与适用场景</h2><table><thead><tr><th align="left">方面</th><th align="left">Java</th><th align="left">Go</th></tr></thead><tbody><tr><td align="left"><strong>启动速度</strong></td><td align="left">较慢（需 JVM 启动、类加载）</td><td align="left"><strong>极快</strong>（静态编译，直接运行）</td></tr><tr><td align="left"><strong>内存占用</strong></td><td align="left">较高（线程默认栈大小 ~1MB）</td><td align="left"><strong>极低</strong>（Goroutine 初始栈 ~2KB）</td></tr><tr><td align="left"><strong>高并发表现</strong></td><td align="left">线程数多时，创建、切换开销大，性能下降</td><td align="left"><strong>优势明显</strong>，可轻松创建数十万 Goroutine</td></tr><tr><td align="left"><strong>GC 影响</strong></td><td align="left">GC 技术成熟（G1, ZGC），但 Full GC 可能引发 STW</td><td align="left">GC 优化良好（并发 GC），STW 时间短</td></tr><tr><td align="left"><strong>典型应用场景</strong></td><td align="left">CPU 密集型计算、复杂业务逻辑的大型企业应用</td><td align="left"><strong>高并发网络服务</strong>、API 网关、微服务、分布式系统</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA基础</title>
      <link href="/2025/05/30/JAVA/"/>
      <url>/2025/05/30/JAVA/</url>
      
        <content type="html"><![CDATA[<h5 id="class-和-数组-在内存上的相似性"><a href="#class-和-数组-在内存上的相似性" class="headerlink" title="class 和 数组 在内存上的相似性"></a>class 和 数组 在内存上的相似性</h5><p>类和数组的 名 ，均保存的是地址值</p><p>即 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">myclass</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> num;</span><br><span class="line">string str;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span> a ,string s)</span></span><br><span class="line">&#123;</span><br><span class="line">a = a+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">...mian...()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">myclass</span> <span class="variable">class01</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">myclass</span>();</span><br><span class="line">    <span class="type">myclass</span> <span class="variable">class02</span> <span class="operator">=</span> class01;<span class="comment">//这一步把class01的地址值赋值给了class02，他们两个现在指向同一片内存空间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="成员变量和局部变量的区别"><a href="#成员变量和局部变量的区别" class="headerlink" title="成员变量和局部变量的区别"></a>成员变量和局部变量的区别</h5><ul><li><p>初始化值不同：</p><p>成员变量有初始值，局部变量没有</p></li><li><p>内存位置不同：</p><p>成员变量在堆中（本质是跟着对象走），局部变量在栈中（本质是跟着方法走）</p></li><li><p>生命周期不同：</p><p>成员变量跟着对象走，随着对象的产生而产生，随着对象的消亡而消亡</p><p>局部变量跟着方法走，随着方法的调用而产生，随着方法结束而消亡</p></li></ul><h5 id="this关键字——-区分成员变量和局部变量"><a href="#this关键字——-区分成员变量和局部变量" class="headerlink" title="this关键字——&gt;区分成员变量和局部变量"></a>this关键字——&gt;区分成员变量和局部变量</h5><ul><li>局部变量和成员变量重名时，遵循“就近原则”</li><li>如果就想用成员变量，那就用 this.变量名 来引用成员变量</li></ul><p>对象之间如何区分？</p><ul><li>哪个对象调用的方法，this就指向哪个对象</li></ul><h5 id="引用数据类型，要先new"><a href="#引用数据类型，要先new" class="headerlink" title="引用数据类型，要先new"></a>引用数据类型，要先new</h5><p>（什么是引用数据类型：除了基本数据类型，都是引用数据类型）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyData</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line">string s;</span><br><span class="line"><span class="keyword">static</span> <span class="type">float</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//========== 其他作用域=========</span></span><br><span class="line"></span><br><span class="line"><span class="type">string</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;666&quot;</span>;    <span class="comment">//正常赋值</span></span><br><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> string b.length; <span class="comment">//报错，空指针，根本原因是没有初始化string类型具体是什么，而直接操作他的成员变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//同理：</span></span><br><span class="line"></span><br><span class="line"><span class="type">MyData</span> <span class="variable">mydata</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyData</span>();</span><br><span class="line">mydata.a = <span class="number">1</span>;      <span class="comment">//正常，先new了一个对象，然后操作他的成员变量</span></span><br><span class="line"></span><br><span class="line">MyData mydata_error.a = <span class="number">2</span>; <span class="comment">//空指针，因为连mydata_error对象都还没创建，就直接操作他的成员变量</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//但是，static的变量可以直接通过 类名 访问，（不是对象名）</span></span><br><span class="line"></span><br><span class="line">MyData.c = <span class="string">&quot;我是静态变量&quot;</span>; <span class="comment">//正常</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="javabean在业务处理中的作用"><a href="#javabean在业务处理中的作用" class="headerlink" title="javabean在业务处理中的作用"></a>javabean在业务处理中的作用</h5><p><strong>javabean与表的对应关系</strong>：</p><p>类名——&gt;表名</p><p>各个实例化对象——&gt;每一行</p><p>成员变量——&gt;每一列的列头（也就是对应的参数）</p><ul><li>添加功能：</li></ul><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog_imgimage-20250403200744494.png" alt="image-20250403200744494"></p><ul><li>查询功能：<br><img src="C:\Users\EdwardNygma\AppData\Roaming\Typora\typora-user-images\image-20250403201600516.png" alt="image-20250403201600516"></li></ul><p>标准javabean生成快捷键：alt + insert</p><h5 id="java中，static的用法"><a href="#java中，static的用法" class="headerlink" title="java中，static的用法"></a>java中，static的用法</h5><p><strong>静态成员随着类的调用而产生，非静态成员随着对象的产生而产生</strong></p><p>因此注意四种辨析：</p><ul><li><p>在静态成员中能直接访问非静态成员吗：</p><p>不能，想在静态成员中访问非静态成员，要先new对象<br>eg：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args）&#123;</span></span><br><span class="line"><span class="params">        test01()</span>;   <span class="comment">//——————&gt;可行，静态调用静态</span></span><br><span class="line">        test02();   <span class="comment">//——————&gt;不可行，静态不能直接调用非静态，因为静态成员比非静态先产生</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//===正确调用：========        </span></span><br><span class="line">        <span class="type">Demo</span> <span class="variable">mydemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo</span>();</span><br><span class="line">        mydemo.test02();</span><br><span class="line">        <span class="comment">//====================</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span>&#123;</span><br><span class="line">        sout(<span class="string">&quot;我是静态成员&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span>&#123;</span><br><span class="line">        sout(<span class="string">&quot;我是非静态成员&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure></li><li><p>在非静态方法中能直接访问静态成员吗：</p><p>可以，同类下的话，直接调用即可，不同类的话，通过类名调用（也就是静态方法跟着类走，不跟着对象走）</p><p>当然，也可以不管是不是同类，直接类名调用</p></li><li><p>在静态方法中能直接调用静态成员吗：</p><p>可以，同上</p></li><li><p>在非静态方法中能直接调用非静态成员吗？</p><p>可以，同类下可以直接调用，也可以new对象调用，不同类下需要new对象调用</p><p>当然，也可以不管是否同类，都通过new对象调用</p></li></ul><p><strong>总结：</strong></p><p>1.不管在不在同一个类中,非静态成员都可以new对象调用</p><p>2.不管在不在同一个类中,静态成员都可以类名调用</p><h5 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h5><p>可变参数本质上是一个数组,用于传递类型已知但数量未知的数据类型</p><p>形式：</p><p>数据类型…变量名，如 int…nums  String…kids</p><p><strong>还有，可变参数必须位于传参的最后面位置</strong></p><h5 id="对象数组"><a href="#对象数组" class="headerlink" title="对象数组"></a>对象数组</h5><p>就是数组的元素是对象，类如</p><p>int数组：int[] arr_int &#x3D; new int[3]</p><p>Person数组： Person arr_person &#x3D; new Person[3]</p><h5 id="一些操作"><a href="#一些操作" class="headerlink" title="一些操作"></a>一些操作</h5><ul><li><p>先调用方法再生成：</p><p>alt+回车</p></li><li><p>将一段代码抽取到一个方法：</p><p>ctrl+alt+m</p></li></ul><h5 id="有关继承："><a href="#有关继承：" class="headerlink" title="有关继承："></a>有关继承：</h5><h6 id="子类可以继承什么"><a href="#子类可以继承什么" class="headerlink" title="子类可以继承什么"></a><strong>子类可以继承什么</strong></h6><p>  a.子类可以继承父类中私有和非私有成员,但是不能使用父类中私有成员</p><p>  b.构造方法不能继承</p><h6 id="成员变量和成员方法各自的访问特点（同样适用于多态）"><a href="#成员变量和成员方法各自的访问特点（同样适用于多态）" class="headerlink" title="成员变量和成员方法各自的访问特点（同样适用于多态）"></a><strong>成员变量和成员方法各自的访问特点</strong>（同样适用于多态）</h6><ul><li><p>成员变量：看等号左边，左边是谁就用谁的成员变量，比如如果等号左边是子类，且没有，再去找父类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">fu</span> &#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">zi</span> <span class="keyword">extends</span> <span class="title class_">fu</span>&#123;</span><br><span class="line">    <span class="type">int</span> num;  <span class="comment">//也叫num，两者重名</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">    <span class="type">fu</span> <span class="variable">fu_</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">fu</span>();</span><br><span class="line">    <span class="type">zi</span> <span class="variable">zi_</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">zi</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    sout(fu.num)  ——&gt;父类的num</span></span><br><span class="line"><span class="comment">    sout(zi.num)——&gt;子类的num</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//多态：</span></span><br><span class="line">    <span class="type">fu</span> <span class="variable">fu_2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">zi</span>();</span><br><span class="line"> <span class="comment">// sout(fu_2.num)——&gt;子类的num，因为继承中的成员变量看等号左边</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>成员方法：与成员变量相反，他看等号右边new的是谁，不做展示</p></li></ul><h6 id="方法的重写"><a href="#方法的重写" class="headerlink" title="方法的重写"></a><strong>方法的重写</strong></h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.概述:子类中有一个和父类方法名以及参数列表相同的方法</span><br><span class="line">2.前提:继承</span><br><span class="line">3.访问:看new的是谁,先调用谁中的,如果new的是子类,调用调用子类重写的方法,子类没有,找父类</span><br><span class="line">4.检测是否为重写方法:在该方法上写</span><br><span class="line">  @Override  </span><br></pre></td></tr></table></figure><p>注意事项：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>子类重写父类方法之后,权限必须要保证大于等于父类权限(权限指的是访问权限)</span><br><span class="line">  <span class="keyword">public</span> -&gt; <span class="keyword">protected</span> -&gt; 默认 -&gt; <span class="keyword">private</span></span><br><span class="line"><span class="number">2.</span>子类方法重写父类方法,方法名和参数列表要一样 <span class="comment">//和重载要求参数列表不同不一样，这个要求一样</span></span><br><span class="line"><span class="number">3.</span>私有方法不能被重写,构造方法不能被重写,静态方法不能被重写</span><br><span class="line"><span class="number">4.</span>子类重写父类方法之后,返回值类型应该是父类方法返回值类型的子类类型  <span class="comment">//意思就是，子类的返回值如果是一个类的话，那这个类必须是父类返回值的那个类的子类</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure><h6 id="super和this"><a href="#super和this" class="headerlink" title="super和this"></a><strong>super和this</strong></h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.注意:new子类对象时,会先初始化父类(先走父类无参构造方法)</span><br><span class="line">2.原因:</span><br><span class="line">  每个构造方法的第一行,默认都会有一个super(),不写jvm自动提供一个</span><br><span class="line">  super()代表的是父类无参构造  </span><br></pre></td></tr></table></figure><p>也就是说，子必有父，调用子类，如果不 <strong>显示使用super（有参）的话</strong> 父类一定会默认走一次无参构造</p><p>super的使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>概述:代表的是父类引用</span><br><span class="line"><span class="number">2.</span>作用:可以调用父类中的成员</span><br><span class="line"><span class="number">3.</span>使用:</span><br><span class="line">  a.调用父类构造方法-&gt; 在子类中的构造中写</span><br><span class="line">    <span class="built_in">super</span>() -&gt; 调用父类无参构造</span><br><span class="line">    <span class="built_in">super</span>(实参)  -&gt; 调用父类有参构造</span><br><span class="line">      </span><br><span class="line">  b.调用父类成员变量:</span><br><span class="line">    <span class="built_in">super</span>.成员变量名</span><br><span class="line">        </span><br><span class="line">  c.调用父类成员方法:</span><br><span class="line">    <span class="built_in">super</span>.成员方法名(实参)</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span><span class="built_in">this</span>概述:代表的是当前对象(哪个对象调用的<span class="built_in">this</span>所在的方法,<span class="built_in">this</span>就代表哪个对象)</span><br><span class="line"><span class="number">2.</span>作用:</span><br><span class="line">  a.区分重名的成员变量和局部变量</span><br><span class="line">  b.调用当前对象中的成员</span><br><span class="line"><span class="number">3.</span>使用:</span><br><span class="line">  a.调用当前对象的构造:在构造中写</span><br><span class="line">    <span class="built_in">this</span>():调用当前对象的无参构造</span><br><span class="line">    <span class="built_in">this</span>(实参):调用当前对象的有参构造</span><br><span class="line">  b.调用当前对象的成员变量:</span><br><span class="line">    <span class="built_in">this</span>.成员变量名</span><br><span class="line">  c.调用当前对象的成员方法:</span><br><span class="line">    <span class="built_in">this</span>.成员方法名(实参)</span><br><span class="line"><span class="number">4.</span>注意:</span><br><span class="line">  不管是<span class="built_in">super</span>还是<span class="built_in">this</span>,只要在构造中使用,都必须在第一行,所以二者不能同时手写出来</span><br></pre></td></tr></table></figure><p>super 和 this 不能同时出现，因为两个都要在第一行</p><h6 id="继承的特点："><a href="#继承的特点：" class="headerlink" title="继承的特点："></a>继承的特点：</h6><p><strong>只能单继承，不能多继承</strong></p><p>想给private赋值或读取，那就要用到非私有的方法，getset也好，构造方法也行</p><h5 id="抽象："><a href="#抽象：" class="headerlink" title="抽象："></a>抽象：</h5><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog_imgimage-20250411215743850.png" alt="image-20250411215743850"></p><p>抽象的真正意义：</p><ul><li>可以将抽象类看成是一类事物的标准,要求只要是属于这一类的,都必须要拥有抽象类中的方法,必须要给我实现</li><li>怎么证明拥有了,怎么证明实现了呢?-&gt; 重写</li></ul><h5 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>接口:是一个引用数据类型,是一种标准,规则</span><br><span class="line"><span class="number">2.</span>关键字:</span><br><span class="line">   a.interface 接口</span><br><span class="line">      <span class="keyword">public</span> interface 接口名&#123;&#125;</span><br><span class="line">   </span><br><span class="line">  b.implements 实现</span><br><span class="line">      实现类 implements 接口名&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>接口中可以定义的成员:</span><br><span class="line">   </span><br><span class="line">   a.jdk7以及之前:</span><br><span class="line">     抽象方法: <span class="keyword">public</span> <span class="keyword">abstract</span>  -&gt; 即使不写<span class="keyword">public</span> <span class="keyword">abstract</span>,默认也有</span><br><span class="line">     成员变量:<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> 数据类型 变量名 = 值-&gt; 即使不写<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span>,默认也有</span><br><span class="line">                    <span class="keyword">final</span>是最终的,被<span class="keyword">final</span>修饰的变量不能二次赋值,所以我们一般将<span class="keyword">final</span>修饰的变量视为常量</span><br><span class="line"></span><br><span class="line">   b.jdk8:</span><br><span class="line">      默认方法:<span class="keyword">public</span> <span class="keyword">default</span> 返回值类型 方法名(形参)&#123;&#125;</span><br><span class="line">      静态方法:<span class="keyword">public</span> <span class="keyword">static</span> 返回值类型 方法名(形参)&#123;&#125;</span><br><span class="line"></span><br><span class="line">   c.jdk9开始:</span><br><span class="line">     私有方法:</span><br><span class="line">        <span class="keyword">private</span>的方法</span><br></pre></td></tr></table></figure><h6 id="接口中的抽象方法："><a href="#接口中的抽象方法：" class="headerlink" title="接口中的抽象方法："></a>接口中的抽象方法：</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>定义格式:</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> 返回值类型 方法名(形参);</span><br><span class="line"><span class="number">2.</span>注意:</span><br><span class="line">  不写<span class="keyword">public</span> <span class="keyword">abstract</span> 默认也有</span><br><span class="line"><span class="number">3.</span>使用:</span><br><span class="line">  a.定义实现类,实现接口</span><br><span class="line">  b.重写抽象方法</span><br><span class="line">  c.创建实现类对象,调用重写的方法</span><br></pre></td></tr></table></figure><h6 id="接口中的默认方法：（要显示default）"><a href="#接口中的默认方法：（要显示default）" class="headerlink" title="接口中的默认方法：（要显示default）"></a>接口中的默认方法：（要显示default）</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>格式:</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">default</span> 返回值类型 方法名(形参)&#123;</span><br><span class="line">      方法体</span><br><span class="line">      <span class="keyword">return</span> 结果</span><br><span class="line">  &#125;</span><br><span class="line"><span class="number">2.</span>使用:</span><br><span class="line">  a.定义实现类,实现接口</span><br><span class="line">  b.默认方法可重写,可不重写</span><br><span class="line">  c.创建实现类对象,调用默认方法 </span><br></pre></td></tr></table></figure><p>接口中的静态方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>定义格式:</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> 返回值类型 方法名(形参)&#123;</span><br><span class="line">      方法体</span><br><span class="line">      <span class="keyword">return</span> 结果</span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>使用:</span><br><span class="line">  接口名直接调用</span><br></pre></td></tr></table></figure><p><strong>默认方法和静态方法的作用</strong>：默认方法和静态方法 -&gt; 可以作为临时加的一个小功能来使用</p><h6 id="接口中的成员变量"><a href="#接口中的成员变量" class="headerlink" title="接口中的成员变量"></a>接口中的成员变量</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>格式:</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> 数据类型 变量名 = 值</span><br><span class="line"><span class="number">2.</span>相关知识点:<span class="keyword">final</span></span><br><span class="line">  <span class="keyword">final</span>代表最终的,被它修饰的变量,不能二次赋值,可以视为常量</span><br><span class="line"><span class="number">3.</span>特点:</span><br><span class="line">  不写<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> 默认也有</span><br><span class="line"><span class="number">4.</span>使用:</span><br><span class="line">  接口名直接调用</span><br><span class="line"><span class="number">5.</span>注意:</span><br><span class="line">  a.被<span class="keyword">static</span> <span class="keyword">final</span>修饰的成员变量需要手动赋值</span><br><span class="line">  b.习惯上我们会将<span class="keyword">static</span> <span class="keyword">final</span>修饰的成员变量名大写</span><br></pre></td></tr></table></figure><h6 id="总结一下接口的成员变量和成员方法"><a href="#总结一下接口的成员变量和成员方法" class="headerlink" title="总结一下接口的成员变量和成员方法"></a>总结一下接口的成员变量和成员方法</h6><p>继承也好,实现接口也罢,只要是父类中或者接口的抽象方法,子类或者实现类都要重写</p><p>接口中的成员变量：public static final，直接通过接口名调用</p><p>接口中的静态方法：public static method()，直接通过接口名调用</p><p>接口中的 默认方法 和 抽象方法：不写前缀默认是抽象方法，显式public default,是默认方法，二者，抽象方法必须在实现类中重写，然后通过new实现类来调用，default方法可重现可不重写，但也要通过new实现类来调用</p><p><strong>注意，多个接口中的抽象方法或默认方法重名，实现类都要重写一次抽象方法或默认方法</strong></p><h6 id="接口和抽象类的区别："><a href="#接口和抽象类的区别：" class="headerlink" title="接口和抽象类的区别："></a>接口和抽象类的区别：</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">相同点:</span><br><span class="line">  a.都位于继承体系的顶端,用于被其他类实现或者继承</span><br><span class="line">  b.都不能<span class="keyword">new</span></span><br><span class="line">  <span class="title class_">c</span>.都包含抽象方法,其子类或者实现类都必须重写这些抽象方法</span><br><span class="line">      </span><br><span class="line">不同点:</span><br><span class="line">  a.抽象类:一般作为父类使用,可以有成员变量,构造,成员方法,抽象方法等</span><br><span class="line">  b.接口:成员单一,一般抽取接口,抽取的都是方法,视为功能的大集合</span><br><span class="line">  c.类不能多继承,但是接口可以</span><br></pre></td></tr></table></figure><h5 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h5><h6 id="多态的表达方式："><a href="#多态的表达方式：" class="headerlink" title="多态的表达方式："></a>多态的表达方式：</h6><p>Fu fu &#x3D; new Zi();</p><p>也就是：<strong>父类引用指向子类对象</strong></p><p>多态的相关使用说明：</p><ul><li><p>父类引用指向子类对象后，这个引用不能调用子类的特有功能（也就是不是重写的父类中的功能），这是一个弊端</p></li><li><p>由于多态是父类引用指向子类对象，相当于 一个大的数据类型接受了一个小的数据类型的赋值 ，如 double x &#x3D; 10，因此，它具有很强的 <strong>兼容性</strong> ，他能够兼容比自己小的数据类型传来的赋值，也就是说，这个Fu fu 可以随便被自己的子类给赋值，无论是new zi1(); 还是 new zi2()；</p><p><strong>因此，多态常用于执行方法的形参中</strong></p></li><li><p>多态下，成员变量和成员方法的访问特点：成员变量看左边，一般是父类的，成员方法看右边，一般是子类的，还有就是多态一般是用来玩方法的，因此大多都只用成员方法即可</p></li></ul><h6 id="多态中的向下转型："><a href="#多态中的向下转型：" class="headerlink" title="多态中的向下转型："></a>多态中的向下转型：</h6><p>类似于强转，将大类型强制转换成小类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例如，Animal animal是父类，Dog dog是子类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//转型语句：</span></span><br><span class="line"><span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> (Dog) animal;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//但是注意，向下转型以后，原来的方法中可能会存在类型转换异常，原因是，一个方法中如果集合了很多子类的特有方法，转成一种以后，就会和其他的子类方法起冲突</span></span><br><span class="line"><span class="comment">//解决办法： 对象名 instanceof 类型 -&gt; 判断的是关键字前面的对象是否符合关键字后面的类型</span></span><br><span class="line">        <span class="keyword">if</span> (animal <span class="keyword">instanceof</span> Cat)&#123;</span><br><span class="line">            <span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> (Cat) animal;</span><br><span class="line">            cat.eat();</span><br><span class="line">            cat.catchMouse();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h5 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h5><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog_imgimage-20250418191139231.png" alt="image-20250418191139231"></p><h5 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h5><h6 id="final关键字可以修饰的内容"><a href="#final关键字可以修饰的内容" class="headerlink" title="final关键字可以修饰的内容:"></a>final关键字可以修饰的内容:</h6><p>类：不能被继承</p><p>方法：不能被重写</p><p>局部变量：值不能被改变</p><p>成员变量：<strong>需要手动赋值</strong>，且不能二次赋值</p><p>对象：对象的属性值可以改变，但是对象的地址值不能改变</p><h5 id="代码块："><a href="#代码块：" class="headerlink" title="代码块："></a>代码块：</h5><p><strong>构造代码块</strong>：执行特点:优先于构造方法执行,每new一次,就会执行一次</p><p>静态代码块：执行特点：优于构造方法和构造代码块执行，且只执行一次</p><p>如果想让一些数据最先初始化,而且只需要初始化一次,就可以将这些数据放到静态代码块中</p><p>比如初始化数据库的过程中，每次都要注册驱动，初始化操作数据库的地址，用户名，密码啥的，是没有意义的，因此放到一个静态代码块中只初始化一次即可</p><h5 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h5><p>内部类的分类：</p><p>成员内部类：</p><ul><li>静态内部类</li><li>非静态内部类</li></ul><p>局部内部类</p><p><strong>匿名内部类</strong></p><h6 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>格式:直接在定义内部类的时候加上<span class="keyword">static</span>关键字</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">      <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line">          </span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>注意:</span><br><span class="line">  a.内部类可以定义属性,方法,构造等</span><br><span class="line">  b.静态内部类可以被<span class="keyword">final</span>或者<span class="keyword">abstract</span>修饰</span><br><span class="line">    被<span class="keyword">final</span>修饰之后,不能被继承</span><br><span class="line">    被<span class="keyword">abstract</span>修饰之后,不能<span class="keyword">new</span></span><br><span class="line">  <span class="title class_">c</span>.静态内部类不能调用外部的非静态成员</span><br><span class="line">  d.内部类还可以被四种权限修饰符修饰</span><br><span class="line">      </span><br><span class="line"><span class="number">3.</span>调用静态内部类成员:</span><br><span class="line">  外部类.内部类 对象名 = <span class="keyword">new</span> 外部类.内部类()</span><br></pre></td></tr></table></figure><h6 id="非静态内部类："><a href="#非静态内部类：" class="headerlink" title="非静态内部类："></a>非静态内部类：</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>格式:直接在定义内部类的时候加上<span class="keyword">static</span>关键字</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">      <span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line">          </span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>注意:</span><br><span class="line">  a.内部类可以定义属性,方法,构造等</span><br><span class="line">  b.静态内部类可以被<span class="keyword">final</span>或者<span class="keyword">abstract</span>修饰</span><br><span class="line">    被<span class="keyword">final</span>修饰之后,不能被继承</span><br><span class="line">    被<span class="keyword">abstract</span>修饰之后,不能<span class="keyword">new</span></span><br><span class="line">  <span class="title class_">c</span>.静态内部类不能调用外部的非静态成员</span><br><span class="line">  d.内部类还可以被四种权限修饰符修饰</span><br><span class="line">      </span><br><span class="line"><span class="number">3.</span>调用非静态内部类成员:</span><br><span class="line">  外部类.内部类 对象名 = <span class="keyword">new</span> 外部类().new 内部类()</span><br></pre></td></tr></table></figure><p><strong>外部类与内部类的成员变量以及内部类的局部变量重名</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;金莲&quot;</span>;</span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">Heart</span>&#123;</span><br><span class="line">     <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;大郎&quot;</span>;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">(String name)</span>&#123;</span><br><span class="line">         System.out.println(name);<span class="comment">//内部类的局部变量</span></span><br><span class="line">         System.out.println(<span class="built_in">this</span>.name);<span class="comment">//内部类的成员变量</span></span><br><span class="line">         System.out.println(Student.<span class="built_in">this</span>.name);<span class="comment">//外部类的成员变量</span></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test02</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">     Student.<span class="type">Heart</span> <span class="variable">heart</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>().<span class="keyword">new</span> <span class="title class_">Heart</span>();</span><br><span class="line">     heart.display(<span class="string">&quot;涛哥&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在内部类中，变量前没有任何修饰，是局部变量</p><p>有 this. 修饰，是内部成员变量</p><p>有 <strong>外部类名.this. 修饰</strong>，是外部类的成员变量</p><h4 id="8-15更新"><a href="#8-15更新" class="headerlink" title="8_15更新"></a>8_15更新</h4><h5 id="API"><a href="#API" class="headerlink" title="API"></a>API</h5><h6 id="String"><a href="#String" class="headerlink" title="String"></a>String</h6><p><strong>所有字符串类型的的“变量”，常量，都是String的实现类对象</strong></p><p><strong>字符串类型本质上是常量，一旦创建就不能改变，对字符串修改的过程实际上是创建新对象的过程</strong></p><p><strong>字符串对象是不可变的，所以可以共享，已经定义了一个s1，如果s2和s1内容一样，那么定义s2就会复用s1</strong></p><p><strong>实现原理</strong>：</p><p>String的实现原理分为jdk8之前和之后</p><p>之前： private final char[] value</p><p>之后： private final bytes[] value </p><p>由char变成bytes，内存占用从2个字节到1个字节 ——&gt;节省内存</p><p><strong>String面试题</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04String</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        System.out.println(s1==s2);<span class="comment">//true</span></span><br><span class="line">        System.out.println(s1==s3);<span class="comment">//false</span></span><br><span class="line">        System.out.println(s2==s3);<span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">字符串常量池可以避免重复创建相同字符串</span><br><span class="line">==比较的是对象引用地址，不是内容</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">String</span>()总是创建新对象，即使内容相同</span><br><span class="line">如果要比较内容，应该使用equals()方法而不是==</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo05String</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;world&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;helloworld&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>+<span class="string">&quot;world&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> s1+<span class="string">&quot;world&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s6</span> <span class="operator">=</span> s1+s2;</span><br><span class="line"></span><br><span class="line">        System.out.println(s3==s4);<span class="comment">//true</span></span><br><span class="line">        System.out.println(s3==s5);<span class="comment">//false</span></span><br><span class="line">        System.out.println(s3==s6);<span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>字符串拼接,如果等号右边是字符串字面值拼接,不会产生新对象</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>字符串拼接,如果等号右边有变量参数拼接,会产生新字符串对象</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>String 方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(String s)</span> -&gt; 比较字符串内容</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">equalsIgnoreCase</span><span class="params">(String s)</span> -&gt; 比较字符串内容,忽略大小写    </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">length</span><span class="params">()</span></span><br><span class="line">String <span class="title function_">concat</span><span class="params">(String s)</span> 字符串拼接，返回新串</span><br><span class="line"><span class="type">char</span> <span class="title function_">charAt</span><span class="params">(<span class="type">int</span> index)</span> 获取对应的字符</span><br><span class="line"><span class="type">int</span> <span class="title function_">indexOf</span> <span class="params">(String s)</span> 返回第一次s字串在大串中出现的索引位置</span><br><span class="line">String <span class="title function_">subString</span> <span class="params">(<span class="type">int</span> beginIdex)</span> 截取字符串 从指定的所用开始</span><br><span class="line">String <span class="title function_">subString</span> <span class="params">(<span class="type">int</span> begin,<span class="type">int</span> end)</span> 截取字符串，含头不含尾</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="type">char</span>[] toCharArray() 将字符串转成<span class="type">char</span>数组</span><br><span class="line"><span class="type">byte</span>[] getBytes() 将字符串转成<span class="type">byte</span>数组</span><br><span class="line"><span class="type">byte</span>[] getBytes(String charsetname) 根据给定的编码格式转换</span><br><span class="line">    </span><br><span class="line">String[] split (String regex) regex是正则表达式</span><br><span class="line">    </span><br><span class="line"><span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(String s)</span> -&gt; 判断老串儿中是否包含指定的串儿</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">endsWith</span><span class="params">(String s)</span> -&gt; 判断老串儿是否以指定的串儿结尾</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">startsWith</span><span class="params">(String s)</span> -&gt; 判断老串儿是否以指定的串儿开头</span><br><span class="line">String <span class="title function_">toLowerCase</span><span class="params">()</span>-&gt; 将字母转成小写</span><br><span class="line">String <span class="title function_">toUpperCase</span><span class="params">()</span> -&gt; 将字母转成大写</span><br><span class="line">String <span class="title function_">trim</span><span class="params">()</span> -&gt; 去掉字符串两端空格</span><br></pre></td></tr></table></figure><p><strong>StringBulider</strong></p><p>StringBulider 是可变的，相比于String的不可变，每次操作都要新建对象，StringBulider可以直接修改</p><p>StringBulider方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StringBulider <span class="title function_">append</span><span class="params">(任意类型的数据)</span> 字符串拼接，返回的是StringBulider自己</span><br><span class="line">StringBulider <span class="title function_">reverse</span><span class="params">()</span> 字符串反转，返回的是StringBulider自己</span><br><span class="line">String <span class="title function_">toString</span><span class="params">()</span> 返回将自己转为String类型后的字符串</span><br></pre></td></tr></table></figure><p>StringBulider vs StringBuffer</p><p>builder效率高，线程不安全，buffer比builder慢，线程安全</p><h6 id="其他api"><a href="#其他api" class="headerlink" title="其他api"></a>其他api</h6><p><strong>Math</strong>工具类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">abs</span><span class="params">(<span class="type">int</span> a)</span> -&gt; 求参数的绝对值</span><br><span class="line"><span class="keyword">static</span> <span class="type">double</span> <span class="title function_">ceil</span><span class="params">(<span class="type">double</span> a)</span> -&gt; 向上取整</span><br><span class="line"><span class="keyword">static</span> <span class="type">double</span> <span class="title function_">floor</span><span class="params">(<span class="type">double</span> a)</span> -&gt;向下取整</span><br><span class="line"><span class="keyword">static</span> <span class="type">long</span> <span class="title function_">round</span><span class="params">(<span class="type">double</span> a)</span>  -&gt; 四舍五入</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> -&gt;求两个数之间的较大值 </span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">min</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> -&gt;求两个数之间的较小值</span><br></pre></td></tr></table></figure><p><strong>BigInteger</strong>大数 <strong>BigDecimal</strong>大小数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">构造:</span><br><span class="line">  BigInteger(String val) -&gt; 参数的格式必须是数字形式</span><br><span class="line">方法:</span><br><span class="line">  BigInteger <span class="title function_">add</span><span class="params">(BigInteger val)</span>  返回其值为 (<span class="built_in">this</span> + val) 的 BigInteger</span><br><span class="line">  BigInteger <span class="title function_">subtract</span><span class="params">(BigInteger val)</span> 返回其值为 (<span class="built_in">this</span> - val) 的 BigInteger</span><br><span class="line">  BigInteger <span class="title function_">multiply</span><span class="params">(BigInteger val)</span>  返回其值为 (<span class="built_in">this</span> * val) 的 BigInteger</span><br><span class="line">  BigInteger <span class="title function_">divide</span><span class="params">(BigInteger val)</span>    返回其值为 (<span class="built_in">this</span> / val) 的 BigInteger  </span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">构造方法:</span><br><span class="line">  BigDecimal(String val)  -&gt; val必须要是数字形式</span><br><span class="line">      </span><br><span class="line">常用方法:</span><br><span class="line">  <span class="keyword">static</span> BigDecimal <span class="title function_">valueOf</span><span class="params">(<span class="type">double</span> val)</span>  -&gt; 此方法初始化小数时可以传入<span class="type">double</span>型数据</span><br><span class="line">  BigDecimal <span class="title function_">add</span><span class="params">(BigDecimal val)</span>  返回其值为 (<span class="built_in">this</span> + val) 的 BigDecimal</span><br><span class="line">  BigDecimal <span class="title function_">subtract</span><span class="params">(BigDecimal val)</span> 返回其值为 (<span class="built_in">this</span> - val) 的 BigDecimal</span><br><span class="line">  BigDecimal <span class="title function_">multiply</span><span class="params">(BigDecimal val)</span>  返回其值为 (<span class="built_in">this</span> * val) 的 BigDecimal</span><br><span class="line">  BigDecimal <span class="title function_">divide</span><span class="params">(BigDecimal val)</span>    返回其值为 (<span class="built_in">this</span> / val) 的 BigDecimal </span><br><span class="line">  BigDecimal <span class="title function_">divide</span><span class="params">(BigDecimal divisor, <span class="type">int</span> scale, <span class="type">int</span> roundingMode)</span>  </span><br><span class="line">                    divisor:除号后面的那个数</span><br><span class="line">                    scale:指定保留几位小数</span><br><span class="line">                    roundingMode:取舍方式</span><br><span class="line">                                 <span class="keyword">static</span> <span class="type">int</span> ROUND_UP -&gt; 向上加<span class="number">1</span></span><br><span class="line">                                 <span class="keyword">static</span> <span class="type">int</span> ROUND_DOWN -&gt; 直接舍去</span><br><span class="line">                                 <span class="keyword">static</span> <span class="type">int</span> ROUND_HALF_UP -&gt; 四舍五入</span><br></pre></td></tr></table></figure><p><strong>Date</strong> 日期类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>构造:</span><br><span class="line">  Date() -&gt; 获取当前系统时间</span><br><span class="line">  Date(<span class="type">long</span> time) -&gt; 获取指定时间,传递毫秒值 -&gt; 从时间原点开始算   比如传递<span class="number">1000l</span>，就是原点后<span class="number">1</span>秒</span><br><span class="line">      </span><br><span class="line"><span class="number">2.</span>方法：</span><br><span class="line">  setTime和getTime</span><br></pre></td></tr></table></figure><p><strong>Calendar</strong> 日历类</p><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog_imgimage-20250815080312300.png" alt="image-20250815080312300"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">常用方法:</span><br><span class="line">  <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> field)</span> -&gt;返回给定日历字段的值</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">int</span> field, <span class="type">int</span> value)</span>  :将给定的日历字段设置为指定的值</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> field, <span class="type">int</span> amount)</span> :根据日历的规则,为给定的日历字段添加或者减去指定的时间量</span><br><span class="line">  Date <span class="title function_">getTime</span><span class="params">()</span>:将Calendar转成Date对象</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">int</span> year, <span class="type">int</span> month, <span class="type">int</span> date)</span> -&gt; 直接设置年月日</span><br></pre></td></tr></table></figure><p><strong>SimpleDateFormat</strong>日期格式化类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>概述:日期格式化类</span><br><span class="line"><span class="number">2.</span>构造:</span><br><span class="line">  SimpleDateFormat(String pattern)</span><br><span class="line"><span class="number">3.</span>pattern代表啥:代表的是我们自己指定的日期格式</span><br><span class="line">  字母不能改变,但是中间的连接符我们可以改变 </span><br><span class="line">  </span><br><span class="line">  yyyy-MM-dd HH:mm:ss  </span><br><span class="line"></span><br><span class="line">常用方法：</span><br><span class="line"><span class="number">1.</span>String <span class="title function_">format</span><span class="params">(Date date)</span> -&gt; 将Date对象按照指定的格式转成String </span><br><span class="line"><span class="number">2.</span>Date <span class="title function_">parse</span><span class="params">(String source)</span>-&gt; 将符合日期格式的字符串转成Date对象      </span><br></pre></td></tr></table></figure><p><strong>JDK8新日期类</strong></p><p>LocalDate  LocalDateTime对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>概述:LocalDate是一个不可变的日期时间对象，表示日期，通常被视为年月日</span><br><span class="line"><span class="number">2.</span>获取:</span><br><span class="line">  <span class="keyword">static</span> LocalDate <span class="title function_">now</span><span class="params">()</span>  -&gt; 创建LocalDate对象</span><br><span class="line">  <span class="keyword">static</span> LocalDate <span class="title function_">of</span><span class="params">(<span class="type">int</span> year, <span class="type">int</span> month, <span class="type">int</span> dayOfMonth)</span>  -&gt; 创建LocalDate对象,设置年月日   </span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line"><span class="number">1.</span>LocalDateTime概述:LocalDateTime是一个不可变的日期时间对象，代表日期时间，通常被视为年 - 月 - 日 - 时 - 分 - 秒。</span><br><span class="line"><span class="number">2.</span>获取:</span><br><span class="line"><span class="keyword">static</span> LocalDateTime <span class="title function_">now</span><span class="params">()</span>  创建LocalDateTime对象</span><br><span class="line"><span class="keyword">static</span> LocalDateTime <span class="title function_">of</span><span class="params">(<span class="type">int</span> year, Month month, <span class="type">int</span> dayOfMonth, <span class="type">int</span> hour, <span class="type">int</span> minute, <span class="type">int</span> second)</span> 创建LocalDateTime对象,设置年月日时分秒</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">从LocalDate 和 LocalDateTime中获取指定字段的方法：</span><br><span class="line"><span class="type">int</span> <span class="title function_">getYear</span><span class="params">()</span>-&gt;获取年份</span><br><span class="line"><span class="type">int</span> <span class="title function_">getMonthValue</span><span class="params">()</span>-&gt;获取月份</span><br><span class="line"><span class="type">int</span> <span class="title function_">getDayOfMonth</span><span class="params">()</span>-&gt;获取月中的第几天</span><br><span class="line">设置各个字段的方法：</span><br><span class="line">LocalDate <span class="title function_">withYear</span><span class="params">(<span class="type">int</span> year)</span>:设置年份</span><br><span class="line">LocalDate <span class="title function_">withMonth</span><span class="params">(<span class="type">int</span> month)</span>:设置月份</span><br><span class="line">LocalDate <span class="title function_">withDayOfMonth</span><span class="params">(<span class="type">int</span> day)</span>:设置月中的天数</span><br><span class="line">    </span><br><span class="line">日期字段偏移(用新的对象去接收)：</span><br><span class="line">设置日期字段的偏移量,方法名plus开头,向后偏移</span><br><span class="line">设置日期字段的偏移量,方法名minus开头,向前偏移</span><br><span class="line">    eg: <span class="type">LocalDate</span> <span class="variable">myLD</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LocalDate</span>();</span><br><span class="line">想要在这个ld对象的基础上，往前偏移一年，就调用方法minusYears：</span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">myMinusLD</span> <span class="operator">=</span> myLD.minusYears(<span class="number">1L</span>);    </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Period和Duration类</p><p>这两者都是计算时间差的，period操作的是LocalDate对象，年月日分别计算，Duration操作的是LocalDate 和LocalDateTime对象，是获取总天&#x2F;时&#x2F;分&#x2F;秒差值的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Period <span class="title function_">between</span><span class="params">(LocalDate d1,LocalDate d2)</span>:计算两个日期之间的差值</span><br><span class="line"></span><br><span class="line">getYears()-&gt;获取相差的年</span><br><span class="line">getMonths()-&gt;获取相差的月</span><br><span class="line">getDays()-&gt;获取相差的天</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> Duration <span class="title function_">between</span><span class="params">(Temporal startInclusive, Temporal endExclusive)</span>  -&gt; 计算时间差</span><br><span class="line">Temporal : 是一个接口</span><br><span class="line">  实现类:LocalDate LocalDateTime</span><br><span class="line">      </span><br><span class="line">参数需要传递 Temporal 的实现类对象, 注意要传递LocalDateTime</span><br><span class="line">  因为Duration计算精确时间偏差,所以需要传递能操作精确时间的 LocalDateTime</span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">利用Dutation获取相差的时分秒 -&gt; to开头</span><br><span class="line">  toDays() :获取相差天数</span><br><span class="line">  toHours(): 获取相差小时</span><br><span class="line">  toMinutes():获取相差分钟</span><br><span class="line">  toMillis():获取相差秒(毫秒)</span><br></pre></td></tr></table></figure><p>DateTimeFormatter日期格式化类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>获取:</span><br><span class="line">  <span class="keyword">static</span> DateTimeFormatter <span class="title function_">ofPattern</span><span class="params">(String pattern)</span>   -&gt; 获取对象,指定格式</span><br><span class="line"><span class="number">2.</span>方法:</span><br><span class="line">  String <span class="title function_">format</span><span class="params">(TemporalAccessor temporal)</span>-&gt; 将日期对象按照指定的规则转成String </span><br><span class="line">                TemporalAccessor:接口,子接口有Temporal</span><br><span class="line">                Temporal的实现类:LocalDate LocalDateTime    </span><br><span class="line">                    </span><br><span class="line">  TemporalAccessor <span class="title function_">parse</span><span class="params">(CharSequence text)</span>-&gt; 将符合规则的字符串转成日期对象 </span><br><span class="line">                   如果想将TemporalAccessor转成我们常见的LocalDateTime日期对象,就需要用到LocalDateTime中的静态方法:</span><br><span class="line">                   <span class="keyword">static</span> LocalDateTime <span class="title function_">from</span><span class="params">(TemporalAccessor temporal)</span>  </span><br></pre></td></tr></table></figure><p>System类：</p><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog_imgimage-20250815082633405.png" alt="image-20250815082633405"></p><p>Arrays工具类：</p><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog_imgimage-20250815082817290.png" alt="image-20250815082817290"></p><h5 id="Callable与线程池"><a href="#Callable与线程池" class="headerlink" title="Callable与线程池"></a>Callable与线程池</h5><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog_imgimage-20250815084012847.png" alt="image-20250815084012847"></p><p>使用方法：</p><p>1.自定义类实现callabe接口，重写call方法，其中call方法的返回值就是callable接口应用时指定的泛型</p><p>2.创建线程池对象，将自定义类new的对象submit到线程池中，并用future对象接收submit方法的返回值</p><p>3.对future对象执行get方法，可以获得call方法的返回值</p><h5 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h5><h6 id="原生创建线程池的方式"><a href="#原生创建线程池的方式" class="headerlink" title="原生创建线程池的方式"></a>原生创建线程池的方式</h6><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog_imgimage-20250815215632996.png" alt="image-20250815215632996"></p><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog_imgimage-20250815215653650.png" alt="image-20250815215653650"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义一个线程工厂对象，重写newThread方法，可以自行对线程进行一些设置</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">myThreadFactory</span> <span class="keyword">implements</span> <span class="title class_">ThreadFactory</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">1</span>); <span class="comment">//创建原子计数器，这东西操作是原子性的，线程安全</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span>&#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line">        Thread.setName(<span class="string">&quot;线程&quot;</span>+i.getAndIncrement()+<span class="string">&quot;号&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> thread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//编写一个任务，通过自定义类实现runnable接口实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.plintln(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在main方法中使用线程池</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="comment">//创建三个任务</span></span><br><span class="line">    <span class="type">Task</span> <span class="variable">task1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Task</span>();</span><br><span class="line">    <span class="type">Task</span> <span class="variable">task2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Task</span>();</span><br><span class="line">    <span class="type">Task</span> <span class="variable">task3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Task</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建线程池对象</span></span><br><span class="line">    <span class="type">ThreadPoolExecutor</span> <span class="variable">mytpe</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">10</span>,<span class="number">25</span>,<span class="number">10L</span>,</span><br><span class="line">                                                      TimeUnit.SECONDS,</span><br><span class="line">                                                      <span class="keyword">new</span> <span class="title class_">LinkdBlockingQueue</span>&lt;&gt;(),</span><br><span class="line">                                                      <span class="keyword">new</span> <span class="title class_">myThreadFactory</span>(),</span><br><span class="line">                                                      <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());</span><br><span class="line">    mytpe.execute(task1);</span><br><span class="line">    mytpe.execute(task2);</span><br><span class="line">    mytpe.execute(task3);    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//关闭线程池</span></span><br><span class="line">    mytpe.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>各个参数详解：</p><p>10：核心线程数量</p><p>25：最大线程数量</p><p>10L：空闲线程存活时间</p><p>new LinkdBlockingQueue&lt;&gt;()：任务队列，这里使用阻塞链式队列，还有阻塞数组队列</p><p>new myThreadFactory()：线程工厂</p><p>new ThreadPoolExecutor.AbortPolicy()：拒绝任务策略，这里是默认的策略</p><h6 id="三种不推荐的创建线程池的方式："><a href="#三种不推荐的创建线程池的方式：" class="headerlink" title="三种不推荐的创建线程池的方式："></a>三种不推荐的创建线程池的方式：</h6><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog_imgimage-20250815221805670.png" alt="image-20250815221805670"></p><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog_imgimage-20250815221914018.png" alt="image-20250815221914018"></p><p>原因就是他们的任务队列存在溢出风险</p><h6 id="提交任务的两种方式，execute和submit"><a href="#提交任务的两种方式，execute和submit" class="headerlink" title="提交任务的两种方式，execute和submit"></a>提交任务的两种方式，execute和submit</h6><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog_imgimage-20250815222203241.png" alt="image-20250815222203241"></p><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog_imgimage-20250815222219082.png" alt="image-20250815222219082"></p><h6 id="future对象中的get方法"><a href="#future对象中的get方法" class="headerlink" title="future对象中的get方法:"></a>future对象中的get方法:</h6><p>future对象中的get方法作用是获取call的return的结果</p><p><strong>默认是阻塞的</strong></p><p>如果想给这个get设定一个超时时间，就在get里面传入参数即可，如 future.get(1, TimeUnit.SECONDS);</p><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog_imgimage-20250815222601775.png" alt="image-20250815222601775"></p><h6 id="future对象中的cancel方法："><a href="#future对象中的cancel方法：" class="headerlink" title="future对象中的cancel方法："></a>future对象中的cancel方法：</h6><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog_imgimage-20250815222656651.png" alt="image-20250815222656651"></p><p>未执行的任务，调用cancel方法，传递的参数true和false是没有作用的，因为根本用不到，结果是能取消任务</p><p>正在执行中的任务，</p><p>​1.传递true代表可以相应中断线程指令（相当于打开了中断线程指令的获取权），这时候程序可以根据中断线程指令来做出相应行为（如果不手动根据指令做出动作，那和false没区别）</p><p>​2.传递false，代表没有什么使用权，当前任务会继续执行完</p><p>已完成的任务，无法取消</p><p><strong>quastion：既然false的时候，程序还是执行完了，那标记有啥意义？</strong></p><p>答：<strong>仅作逻辑标记</strong></p><h6 id="任务拒绝策略："><a href="#任务拒绝策略：" class="headerlink" title="任务拒绝策略："></a>任务拒绝策略：</h6><p><img src="C:\Users\EdwardNygma\AppData\Roaming\Typora\typora-user-images\image-20250815224437313.png" alt="image-20250815224437313"></p><h6 id="shutdown-shutdownNow方法："><a href="#shutdown-shutdownNow方法：" class="headerlink" title="shutdown&amp;&amp;shutdownNow方法："></a>shutdown&amp;&amp;shutdownNow方法：</h6><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog_imgimage-20250815224705096.png" alt="image-20250815224705096"></p><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog_imgimage-20250815225022596.png" alt="image-20250815225022596"></p><h6 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h6><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog_imgimage-20250815225301231.png" alt="image-20250815225301231"></p><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog_imgimage-20250815225310827.png" alt="image-20250815225310827"></p><h6 id="线程池执行流程"><a href="#线程池执行流程" class="headerlink" title="线程池执行流程"></a>线程池执行流程</h6><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog_imgimage-20250815233301354.png" alt="image-20250815233301354"></p><h6 id="线程池批量执行"><a href="#线程池批量执行" class="headerlink" title="线程池批量执行"></a>线程池批量执行</h6><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog_imgimage-20250815234043731.png" alt="image-20250815234043731"></p><h5 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h5><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog_imgimage-20250815234851152.png" alt="image-20250815234851152"></p><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog_imgimage-20250815234950023.png" alt="image-20250815234950023"></p><h5 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h5><h6 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>两个操作符常量：</span><br><span class="line"><span class="keyword">static</span> String pathSeparator:与系统有关的路径分隔符，为了方便，它被表示为一个字符串。</span><br><span class="line"><span class="keyword">static</span> String separator:与系统有关的默认名称分隔符，为了方便，它被表示为一个字符串。 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>File的构造方法：</span><br><span class="line">File(String parent, String child) 根据所填写的路径创建File对象</span><br><span class="line">     parent:父路径</span><br><span class="line">     child:子路径</span><br><span class="line">File(File parent, String child)  根据所填写的路径创建File对象</span><br><span class="line">     parent:父路径,是一个File对象</span><br><span class="line">     child:子路径</span><br><span class="line">File(String pathname)  根据所填写的路径创建File对象</span><br><span class="line">     pathname:直接指定路径   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"><span class="number">3.</span>File的获取方法：</span><br><span class="line">String <span class="title function_">getAbsolutePath</span><span class="params">()</span> -&gt; 获取File的绝对路径-&gt;带盘符的路径</span><br><span class="line">String <span class="title function_">getPath</span><span class="params">()</span> -&gt;获取的是封装路径-&gt;<span class="keyword">new</span> <span class="title class_">File</span>对象的时候写的啥路径,获取的就是啥路径</span><br><span class="line">String <span class="title function_">getName</span><span class="params">()</span>  -&gt; 获取的是文件或者文件夹名称</span><br><span class="line"><span class="type">long</span> <span class="title function_">length</span><span class="params">()</span> -&gt; 获取的是文件的长度 -&gt; 文件的字节数   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>File的创建/删除方法：</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">createNewFile</span><span class="params">()</span>  -&gt; 创建文件</span><br><span class="line">        如果要创建的文件之前有,创建失败,返回<span class="literal">false</span></span><br><span class="line">        如果要创建的文件之前没有,创建成功,返回<span class="literal">true</span></span><br><span class="line">    </span><br><span class="line"><span class="type">boolean</span> <span class="title function_">mkdirs</span><span class="params">()</span> -&gt; 创建文件夹(目录)既可以创建多级文件夹,还可以创建单级文件夹</span><br><span class="line">        如果要创建的文件夹之前有,创建失败,返回<span class="literal">false</span></span><br><span class="line">        如果要创建的文件夹之前没有,创建成功,返回<span class="literal">true</span></span><br><span class="line">        </span><br><span class="line"><span class="type">boolean</span> <span class="title function_">delete</span><span class="params">()</span>-&gt;删除文件或者文件夹</span><br><span class="line">注意:</span><br><span class="line">  <span class="number">1.</span>如果删除文件,不走回收站</span><br><span class="line">  <span class="number">2.</span>如果删除文件夹,必须是空文件夹,而且也不走回收站          </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">5.</span>File的判断方法</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isDirectory</span><span class="params">()</span> -&gt; 判断是否为文件夹 </span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isFile</span><span class="params">()</span>  -&gt; 判断是否为文件</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">exists</span><span class="params">()</span>  -&gt; 判断文件或者文件夹是否存在    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">6.</span>File的遍历方法</span><br><span class="line">String[] list() -&gt; 遍历指定的文件夹,返回的是String数组 </span><br><span class="line">File[] listFiles()-&gt; 遍历指定的文件夹,返回的是File数组 -&gt;这个推荐使用</span><br><span class="line">    </span><br><span class="line">细节:listFiles方法底层还是list方法</span><br><span class="line">     调用list方法,遍历文件夹,返回一个Stirng数组,遍历数组,将数组中的内容一个一个封装到File对象中,然后再将File对象放到File数组中</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="字节字符流"><a href="#字节字符流" class="headerlink" title="字节字符流"></a>字节字符流</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">字节流:万能流,一切皆字节</span><br><span class="line">      字节输出流:  OutputStream 抽象类</span><br><span class="line">      字节输入流:  InputStream 抽象类</span><br><span class="line">          </span><br><span class="line">字符流:专门操作文本文档</span><br><span class="line">      字符输出流:Writer 抽象类</span><br><span class="line">      字符输入流:Reader 抽象类</span><br><span class="line">      </span><br><span class="line"><span class="number">1.</span>OutputStream：</span><br><span class="line">构造（使用的是实现类FileOutputStream）:</span><br><span class="line">   FileOutputStream(File file) </span><br><span class="line">   FileOutputStream(String name)</span><br><span class="line">   </span><br><span class="line">特点:</span><br><span class="line">   a.指定的文件如果没有,输出流会自动创建</span><br><span class="line">   b.每执行一次,默认都会创建一个新的文件,覆盖老文件 </span><br><span class="line"></span><br><span class="line">方法:</span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> b)</span>  一次写一个字节</span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">byte</span>[] b)</span>  一次写一个字节数组</span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">byte</span>[] b, <span class="type">int</span> off, <span class="type">int</span> len)</span>  一次写一个字节数组一部分 </span><br><span class="line">             b:写的数组</span><br><span class="line">             off:从数组的哪个索引开始写</span><br><span class="line">             len:写多少个</span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>  -&gt; 关闭资源 </span><br><span class="line"></span><br><span class="line">字节流的续写追加:</span><br><span class="line">  FileOutputStream(String name, <span class="type">boolean</span> append) </span><br><span class="line">                   append:<span class="literal">true</span> -&gt; 会实现续写追加,文件不覆盖了</span><br><span class="line">                   </span><br><span class="line">                   </span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>InputStream</span><br><span class="line">构造:（使用的是实现类FileInputStream）</span><br><span class="line">  FileInputStream(File file)</span><br><span class="line">  FileInputStream(String path)  </span><br><span class="line"></span><br><span class="line">方法:</span><br><span class="line">  <span class="type">int</span> <span class="title function_">read</span><span class="params">()</span>   一次读一个字节,返回的是读取的字节</span><br><span class="line">  <span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">byte</span>[] b)</span>  一次读取一个字节数组,返回的是读取的字节个数</span><br><span class="line">  <span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">byte</span>[] b, <span class="type">int</span> off, <span class="type">int</span> len)</span>  一次读取一个字节数组一部分,返回的是读取的字节个数</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>  关闭资源  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="number">3.</span>FileWriter</span><br><span class="line">构造:</span><br><span class="line">  FileWriter(File file) </span><br><span class="line">  FileWriter(String fileName)     </span><br><span class="line">  FileWriter(String fileName, <span class="type">boolean</span> append) -&gt; 追加,续写</span><br><span class="line">方法:</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> c)</span> -&gt; 一次写一个字符 </span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">char</span>[] cbuf)</span> 一次写一个字符数组 </span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">char</span>[] cbuf, <span class="type">int</span> off, <span class="type">int</span> len)</span> 一次写一个字符数组一部分  </span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(String str)</span> 直接写一个字符串</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">flush</span><span class="params">()</span>  :将缓冲区中的数据刷到文件中    </span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>  关流 （调用时，自动触发flush）</span><br><span class="line">注意:FileWriterr底层自带一个缓冲区,我们写的数据会先保存到缓冲区中,所以我们需要将缓冲区中的数据刷到文件中</span><br><span class="line">flush():将缓冲区中的数据刷到文件中,后续流对象还能继续使用</span><br><span class="line">close():先刷新后关闭,后续流对象不能使用了    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>FileReader</span><br><span class="line">构造:</span><br><span class="line">  FileReader(File file)</span><br><span class="line">  FileReader(String path)</span><br><span class="line">方法:</span><br><span class="line">  <span class="type">int</span> <span class="title function_">read</span><span class="params">()</span> -&gt; 一次读取一个字符,返回的是读取字符对应的<span class="type">int</span>值 </span><br><span class="line">  <span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">char</span>[] cbuf)</span> -&gt; 一次读取一个字符数组,返回的是读取个数  </span><br><span class="line">  <span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">char</span>[] cbuf, <span class="type">int</span> off, <span class="type">int</span> len)</span> -&gt; 一次读取一个字符数组一部分,返回的是读取个数</span><br><span class="line">           cbuf:读取的数组</span><br><span class="line">           off:从数组的哪个索引开始读</span><br><span class="line">           len:读多少个</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> -&gt; 关闭资源  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">5.</span>JDK7之后io异常处理方式</span><br><span class="line"><span class="number">1.</span>格式:</span><br><span class="line">  <span class="keyword">try</span>(IO对象)&#123;</span><br><span class="line">      可能出现异常的代码</span><br><span class="line">  &#125;<span class="keyword">catch</span>(异常类型 对象名)&#123;</span><br><span class="line">      处理异常</span><br><span class="line">  &#125;</span><br><span class="line"><span class="number">2.</span>注意:</span><br><span class="line">  以上格式处理IO异常,会自动关流</span><br></pre></td></tr></table></figure><h6 id="字节-字符缓冲流-转换流-序列化接口-序列化流-打印流"><a href="#字节-字符缓冲流-转换流-序列化接口-序列化流-打印流" class="headerlink" title="字节&#x2F;字符缓冲流 转换流 序列化接口&#x2F;序列化流  打印流"></a>字节&#x2F;字符缓冲流 转换流 序列化接口&#x2F;序列化流  打印流</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字节缓冲流</span></span><br><span class="line">  a.BufferedOutputStream:字节缓冲输出流</span><br><span class="line">    构造:BufferedOutputStream(OutputStream out)</span><br><span class="line">    使用:和FileOutputStream一样</span><br><span class="line">        </span><br><span class="line">  b.BufferedInputStream:字节缓冲输入流</span><br><span class="line">    构造:BufferedInputStream(InputStream in)</span><br><span class="line">    使用:和FileInputStream一样   </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">//字符缓冲输出流_BufferedWriter </span></span><br><span class="line">构造:</span><br><span class="line">  BufferedWriter(Writer w)</span><br><span class="line">方法:</span><br><span class="line">  用起来和FileWriter一样</span><br><span class="line">特有方法:</span><br><span class="line">  newLine() 换行</span><br><span class="line"></span><br><span class="line"><span class="comment">//字符缓冲输入流_BufferedReader</span></span><br><span class="line">构造:</span><br><span class="line">  BufferedReader(Reader r)</span><br><span class="line">方法:</span><br><span class="line">  用法和FileReader一样</span><br><span class="line">特有方法:</span><br><span class="line">  String <span class="title function_">readLine</span><span class="params">()</span>-&gt; 一次读一行,如果读到结束标记,返回的是<span class="literal">null</span></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="comment">//转换流_InputStreamReader</span></span><br><span class="line">构造:</span><br><span class="line">  InputStreamReader(InputStream in,String charsetName)</span><br><span class="line">                                   charsetName:指定编码,不区分大小写</span><br><span class="line">作用:</span><br><span class="line">  可以直接指定编码,按照指定的编码去读内容</span><br><span class="line">用法:</span><br><span class="line">  基本用法和FileReader一样</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//转换流_OutputStreamWriter</span></span><br><span class="line">构造:</span><br><span class="line">  OutputStreamWriter(OutputStream out,String charsetName)</span><br><span class="line">作用:</span><br><span class="line">  按照指定的编码规则去存数据</span><br><span class="line">用法:</span><br><span class="line">  和FileWriter一样</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="comment">//序列化流和反序列化流</span></span><br><span class="line"> ObjectOutputStream -&gt; 序列化流 -&gt; 写对象</span><br><span class="line"> ObjectInputStream -&gt; 反序列化流 -&gt; 读对象  </span><br><span class="line"> </span><br><span class="line"> 序列化eg：</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">()</span><span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;module22\\person.txt&quot;</span>));</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;涛哥&quot;</span>, <span class="number">12</span>);</span><br><span class="line">        oos.writeObject(p1);</span><br><span class="line">        oos.close();</span><br><span class="line">    &#125;</span><br><span class="line">  反序列化eg：</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">read</span><span class="params">()</span><span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;module22\\person.txt&quot;</span>));</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person) ois.readObject();</span><br><span class="line">        System.out.println(person);</span><br><span class="line">        ois.close();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">打印流eg：</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01PrintStream</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(<span class="string">&quot;module22\\printstream.txt&quot;</span>);</span><br><span class="line">        ps.println(<span class="string">&quot;涛哥是一个大帅哥&quot;</span>);</span><br><span class="line">        ps.println(<span class="string">&quot;涛哥是一个小鲜肉&quot;</span>);</span><br><span class="line">        ps.println(<span class="string">&quot;涛哥和金莲不为人知的故事&quot;</span>);</span><br><span class="line">        ps.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">改变流向:</span><br><span class="line">  什么叫做改变流向:</span><br><span class="line">    System.out.println()-&gt; 本身是输出到控制台上</span><br><span class="line">    改变流向:可以让输出语句从控制台上输出改变成往指定文件中输出</span><br><span class="line">        </span><br><span class="line">  方法:System中的方法:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setOut</span><span class="params">(PrintStream out)</span> -&gt; 改变流向 -&gt;让输出语句从控制台输出转移到指定文件中</span><br></pre></td></tr></table></figure><h6 id="properties结合IO流"><a href="#properties结合IO流" class="headerlink" title="properties结合IO流"></a>properties结合IO流</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">概述: Properties extends Hashtable</span><br><span class="line">特点:</span><br><span class="line">    a.无序,无索引</span><br><span class="line">    b.key唯一,value可重复</span><br><span class="line">    c.线程安全</span><br><span class="line">    d.key和value默认类型都是String</span><br><span class="line">    </span><br><span class="line">特有方法:</span><br><span class="line">    setProperty(String key,String value) 存键值对</span><br><span class="line">    getProperty(String key) -&gt; 根据key获取value</span><br><span class="line">    stringPropertyNames()-&gt; 获取所有的key存放到set集合中</span><br><span class="line">    load(InputStream in) -&gt; 将流中的数据加载到Properties集合中</span><br></pre></td></tr></table></figure><h5 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h5><h5 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h5><h5 id="新特性"><a href="#新特性" class="headerlink" title="新特性"></a>新特性</h5><h5 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h5><h5 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h5>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学生信息管理系统</title>
      <link href="/2025/04/10/JAVA%E5%AD%A6%E7%94%9F%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/"/>
      <url>/2025/04/10/JAVA%E5%AD%A6%E7%94%9F%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="功能概述："><a href="#功能概述：" class="headerlink" title="功能概述："></a>功能概述：</h2><ul><li>每个Student 对象存储一个学生的信息</li><li>查询功能：<ul><li>通过姓名查询（考虑重名情况）</li><li>通过学号查询</li></ul></li><li>修改功能：<ul><li>修改姓名</li><li>修改学号</li><li>修改年龄</li><li>修改班级信息</li></ul></li><li>增删信息：<ul><li>增加&#x2F;删除条目</li></ul></li><li>展示全部：<ul><li>展示当前全部信息</li></ul></li></ul><h2 id="项目结构："><a href="#项目结构：" class="headerlink" title="项目结构："></a>项目结构：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">src</span><br><span class="line">    └─com</span><br><span class="line">        └─stu_info_manage</span><br><span class="line">            ├─controller</span><br><span class="line">            │      main.java</span><br><span class="line">            │      UserInput.java</span><br><span class="line">            │</span><br><span class="line">            ├─data</span><br><span class="line">            │      Add_rm.java</span><br><span class="line">            │      Change_info.java</span><br><span class="line">            │      Info_Stroage.java</span><br><span class="line">            │      Search.java</span><br><span class="line">            │      Student.java</span><br><span class="line">            │</span><br><span class="line">            └─service</span><br><span class="line">                    Add_rm.java</span><br><span class="line">                    ChangeInfo.java</span><br><span class="line">                    Search.java</span><br></pre></td></tr></table></figure><h2 id="实现："><a href="#实现：" class="headerlink" title="实现："></a>实现：</h2><p>首先创建一个Student标准JavaBean，包含各个get，set方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.stu_info_manage.data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getId_num</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.id_num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId_num</span><span class="params">(String id_num)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id_num = id_num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getClass_info</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> class_info;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setClass_info</span><span class="params">(String class_info)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.class_info = class_info;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String id_num;</span><br><span class="line">    <span class="keyword">private</span> String class_info;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后，根据标准Java管理系统结构，分出3个package：</p><ul><li>表层：controller</li><li>服务层：service</li><li>数据层：dao（我写的data）</li></ul><p>表层中，使用Userinputt类处理用户的输入输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.stu_info_manage.controller;</span><br><span class="line"><span class="keyword">import</span> com.stu_info_manage.data.Student;</span><br><span class="line"><span class="keyword">import</span> com.stu_info_manage.service.Search;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserInput</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print_init_info</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Welcome,输入你的操作&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;1：查询\n2.修改\n3.添加\\删除\n4.列出所有&quot;</span>);</span><br><span class="line">            <span class="type">Scanner</span> <span class="variable">init_sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">            <span class="type">int</span> <span class="variable">init_choice</span> <span class="operator">=</span> init_sc.nextInt();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (init_choice ==<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                choice1_init();</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (init_choice == <span class="number">2</span>) &#123;</span><br><span class="line"></span><br><span class="line">                choice2_init();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (init_choice == <span class="number">3</span>) &#123;</span><br><span class="line"></span><br><span class="line">                add_rm_stu_init();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (init_choice == <span class="number">4</span>) &#123;</span><br><span class="line"></span><br><span class="line">                show_all();</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;请重新输入&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">choice1_init</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">        stu = <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;你想通过什么查询？，输入\n1.姓名\n2.学号&quot;</span>);</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">choice1_sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">choice1_choice</span> <span class="operator">=</span> choice1_sc.nextInt();</span><br><span class="line">        <span class="keyword">if</span>(choice1_choice == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;你选择从姓名查询&quot;</span>);</span><br><span class="line">            garbage_char = choice1_sc.nextLine();</span><br><span class="line">            name = choice1_sc.nextLine();</span><br><span class="line">            stu_list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            stu_list = Search.search_form_name(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(choice1_choice == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;你选择从学号查询&quot;</span>);</span><br><span class="line">            garbage_char = choice1_sc.nextLine();</span><br><span class="line">            id_num = choice1_sc.nextLine();</span><br><span class="line">            stu_list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            stu_list = Search.search_form_id_num(id_num);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;你的查询结果：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; stu_list.size(); i++) &#123;</span><br><span class="line">            stu = stu_list.get(i);</span><br><span class="line">            System.out.println(<span class="string">&quot;name:&quot;</span>+stu.getName()+<span class="string">&quot; id:&quot;</span>+stu.getId_num()+<span class="string">&quot; age:&quot;</span>+stu.getAge()+<span class="string">&quot; class:&quot;</span>+stu.getClass_info());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">choice2_init</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;输入你想修改的人的学号&quot;</span>);</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">choice2_sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        id_num = choice2_sc.nextLine();</span><br><span class="line">        System.out.println(<span class="string">&quot;你选择了学号为：&quot;</span>+id_num+<span class="string">&quot; 的人&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入你想修改的信息：\n 1.姓名 \n 2.学号 \n 3.年龄 \n 4.班级&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">choice</span> <span class="operator">=</span> choice2_sc.nextInt();</span><br><span class="line">        <span class="keyword">if</span>(choice == <span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;你要将姓名改成什么：&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">trash</span> <span class="operator">=</span> choice2_sc.nextLine();</span><br><span class="line">            <span class="type">String</span> <span class="variable">rename</span> <span class="operator">=</span> choice2_sc.nextLine();</span><br><span class="line">            System.out.println(<span class="string">&quot;你想将姓名修改为 &quot;</span>+rename);</span><br><span class="line"></span><br><span class="line">            com.stu_info_manage.service.<span class="type">ChangeInfo</span> <span class="variable">changeInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">com</span>.stu_info_manage.service.ChangeInfo();</span><br><span class="line"></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">renamed</span> <span class="operator">=</span> changeInfo.Rename(rename,id_num);</span><br><span class="line">            <span class="keyword">if</span>(renamed)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;success!&quot;</span>);</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;error!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (choice == <span class="number">2</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;你想将学号改成什么？&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">trash</span> <span class="operator">=</span> choice2_sc.nextLine();</span><br><span class="line">            <span class="type">String</span> <span class="variable">re_id_num</span> <span class="operator">=</span> choice2_sc.nextLine();</span><br><span class="line">            System.out.println(<span class="string">&quot;你想将学号改成：&quot;</span>+re_id_num);</span><br><span class="line"></span><br><span class="line">            com.stu_info_manage.service.<span class="type">ChangeInfo</span> <span class="variable">changeInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">com</span>.stu_info_manage.service.ChangeInfo();</span><br><span class="line">            System.out.println(<span class="string">&quot;before: &quot;</span>+id_num+<span class="string">&quot; after: &quot;</span>+re_id_num);</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">re_id_numed</span> <span class="operator">=</span> changeInfo.Re_id_num(id_num,re_id_num);</span><br><span class="line">            <span class="keyword">if</span>(re_id_numed)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;success!&quot;</span>);</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;error!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (choice == <span class="number">3</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;你想将年龄改成什么？&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">trash</span> <span class="operator">=</span> choice2_sc.nextLine();</span><br><span class="line">            <span class="type">int</span> <span class="variable">reage</span> <span class="operator">=</span> choice2_sc.nextInt();</span><br><span class="line">            System.out.println(<span class="string">&quot;你想将年龄改为&quot;</span>+reage);</span><br><span class="line">            com.stu_info_manage.service.<span class="type">ChangeInfo</span> <span class="variable">changeInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">com</span>.stu_info_manage.service.ChangeInfo();</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">reaged</span> <span class="operator">=</span> changeInfo.Reage(reage,id_num);</span><br><span class="line">            <span class="keyword">if</span>(reaged)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;success!&quot;</span>);</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;error!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (choice == <span class="number">4</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;你想将班级改成什么？&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">trash</span> <span class="operator">=</span> choice2_sc.nextLine();</span><br><span class="line">            String reclass= choice2_sc.nextLine();</span><br><span class="line">            System.out.println(<span class="string">&quot;你想将班级改为&quot;</span>+reclass);</span><br><span class="line">            com.stu_info_manage.service.<span class="type">ChangeInfo</span> <span class="variable">changeInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">com</span>.stu_info_manage.service.ChangeInfo();</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">reclassed</span> <span class="operator">=</span> changeInfo.Reclass(reclass,id_num);</span><br><span class="line">            <span class="keyword">if</span>(reclassed)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;success!&quot;</span>);</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;error!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add_rm_stu_init</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;加成员按1，减成员按2&quot;</span>);</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">choice3_sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">add_or_rm</span> <span class="operator">=</span> choice3_sc.nextInt();</span><br><span class="line">        <span class="keyword">if</span>(add_or_rm==<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;输入姓名&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">trush</span> <span class="operator">=</span> choice3_sc.nextLine();</span><br><span class="line">            <span class="type">String</span> <span class="variable">add_name</span> <span class="operator">=</span> choice3_sc.nextLine();</span><br><span class="line">            System.out.println(<span class="string">&quot;输入学号&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">add_id</span> <span class="operator">=</span> choice3_sc.nextLine();</span><br><span class="line">            System.out.println(<span class="string">&quot;输入年龄&quot;</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">add_age</span> <span class="operator">=</span> choice3_sc.nextInt();</span><br><span class="line">            System.out.println(<span class="string">&quot;输入班级&quot;</span>);</span><br><span class="line">            trush = choice3_sc.nextLine();</span><br><span class="line">            <span class="type">String</span> <span class="variable">add_class</span> <span class="operator">=</span> choice3_sc.nextLine();</span><br><span class="line">            System.out.println(<span class="string">&quot;你想添加：&quot;</span>+add_name+<span class="string">&quot; &quot;</span>+add_id+<span class="string">&quot; &quot;</span>+add_age+<span class="string">&quot; &quot;</span>+add_class);</span><br><span class="line">            com.stu_info_manage.service.<span class="type">Add_rm</span> <span class="variable">add_rm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">com</span>.stu_info_manage.service.Add_rm();</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">added</span> <span class="operator">=</span> add_rm.add_item(add_name,add_id,add_age,add_class);</span><br><span class="line">            <span class="keyword">if</span>(added)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;success!&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;error!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (add_or_rm==<span class="number">2</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;输入你要删除的学号&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">trush</span> <span class="operator">=</span> choice3_sc.nextLine();</span><br><span class="line">            <span class="type">String</span> <span class="variable">rm_id</span> <span class="operator">=</span> choice3_sc.nextLine();</span><br><span class="line">            System.out.println(<span class="string">&quot;你想删除：&quot;</span>+rm_id);</span><br><span class="line">            com.stu_info_manage.service.<span class="type">Add_rm</span> <span class="variable">add_rm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">com</span>.stu_info_manage.service.Add_rm();</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">rmed</span> <span class="operator">=</span> add_rm.rm_item(rm_id);</span><br><span class="line">            <span class="keyword">if</span>(rmed)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;success!&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;error!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show_all</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        com.stu_info_manage.data.Info_Stroage.show_all();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String id_num;</span><br><span class="line">    <span class="keyword">private</span> Student stu;</span><br><span class="line">    <span class="keyword">private</span> String garbage_char;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Student&gt; stu_list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>服务层中，分出 增删条目 &#x2F; 修改信息 &#x2F; 查找条目 三块，因为这个小系统服务层不用处理什么东西，所以基本是一个转接头的作用，不过还是写出来了框架：</p><ul><li>增删条目：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.stu_info_manage.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Add_rm</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add_item</span><span class="params">(String add_name,String add_id_num,<span class="type">int</span> add_age,String add_class)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">added</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(add_age&gt;<span class="number">30</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            added = <span class="literal">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            com.stu_info_manage.data.<span class="type">Add_rm</span> <span class="variable">add_rm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">com</span>.stu_info_manage.data.Add_rm();</span><br><span class="line">            added = add_rm.add_item(add_name,add_id_num,add_age,add_class);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> added;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>  <span class="type">boolean</span> <span class="title function_">rm_item</span><span class="params">(String rm_id_num)</span>&#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">rmed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        com.stu_info_manage.data.<span class="type">Add_rm</span> <span class="variable">add_rm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">com</span>.stu_info_manage.data.Add_rm();</span><br><span class="line">        rmed = add_rm.rm_item(rm_id_num);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rmed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>修改信息：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.stu_info_manage.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChangeInfo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">Rename</span><span class="params">(String rename,String id_num)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.rename = rename;</span><br><span class="line">        <span class="built_in">this</span>.id_num = id_num;</span><br><span class="line">        com.stu_info_manage.data.<span class="type">Change_info</span> <span class="variable">change_info</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">com</span>.stu_info_manage.data.Change_info();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">renamed</span> <span class="operator">=</span> change_info.Rename(<span class="built_in">this</span>.id_num,<span class="built_in">this</span>.rename);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> renamed;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">Re_id_num</span><span class="params">(String id_num,String id_num_aft)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.id_num = id_num;</span><br><span class="line">        <span class="built_in">this</span>.id_num_aft = id_num_aft;</span><br><span class="line">        com.stu_info_manage.data.<span class="type">Change_info</span> <span class="variable">change_info</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">com</span>.stu_info_manage.data.Change_info();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">re_id_numed</span> <span class="operator">=</span> change_info.Re_id_numed(<span class="built_in">this</span>.id_num,<span class="built_in">this</span>.id_num_aft);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> re_id_numed;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">Reage</span><span class="params">(<span class="type">int</span> reage,String id_num)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.reage = reage;</span><br><span class="line">        <span class="built_in">this</span>.id_num = id_num;</span><br><span class="line">        com.stu_info_manage.data.<span class="type">Change_info</span> <span class="variable">change_info</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">com</span>.stu_info_manage.data.Change_info();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">reaged</span> <span class="operator">=</span> change_info.Reage(<span class="built_in">this</span>.id_num,<span class="built_in">this</span>.reage);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> reaged;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">Reclass</span><span class="params">(String reclass,String id_num)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.reclass = reclass;</span><br><span class="line">        <span class="built_in">this</span>.id_num = id_num;</span><br><span class="line">        com.stu_info_manage.data.<span class="type">Change_info</span> <span class="variable">change_info</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">com</span>.stu_info_manage.data.Change_info();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">reclassed</span> <span class="operator">=</span> change_info.Reclass(<span class="built_in">this</span>.id_num,<span class="built_in">this</span>.reclass);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> reclassed;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String rename;</span><br><span class="line">    <span class="keyword">private</span> String reclass;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> reage;</span><br><span class="line">    <span class="keyword">private</span> String id_num;</span><br><span class="line">    <span class="keyword">private</span> String id_num_aft;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>查找条目：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.stu_info_manage.service;</span><br><span class="line"><span class="keyword">import</span> com.stu_info_manage.data.Student;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Search</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Student&gt; <span class="title function_">search_form_name</span><span class="params">(String name)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Search</span> <span class="variable">sh</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Search</span>();</span><br><span class="line">        sh.name = name;</span><br><span class="line">        com.stu_info_manage.data.<span class="type">Search</span> <span class="variable">sh_data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">com</span>.stu_info_manage.data.Search();</span><br><span class="line">        sh.stu_list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        sh.stu_list = sh_data.search_form_name(sh.name);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>  sh.stu_list;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Student&gt; <span class="title function_">search_form_id_num</span><span class="params">(String id_num)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Search</span> <span class="variable">sh</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Search</span>();</span><br><span class="line">        sh.id_num = id_num;</span><br><span class="line">        com.stu_info_manage.data.<span class="type">Search</span> <span class="variable">sh_data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">com</span>.stu_info_manage.data.Search();</span><br><span class="line">        sh.stu_list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        sh.stu_list = sh_data.search_form_id_num(sh.id_num);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sh.stu_list;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String id_num ;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">private</span> Student stu;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Student&gt; stu_list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>数据层同样分出三层，也相当于转接头，不予列出</p><p>最终数据处理在Info_stroage类中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.stu_info_manage.data;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Info_Stroage</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">init_example</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        stu_null = <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        stu_null .setName(<span class="string">&quot;null&quot;</span>);</span><br><span class="line">        stu_null.setAge(<span class="number">000</span>);</span><br><span class="line">        stu_null.setId_num(<span class="string">&quot;000&quot;</span>);</span><br><span class="line"></span><br><span class="line">        students = <span class="keyword">new</span> <span class="title class_">Student</span>[<span class="number">100</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; students.length; i++) &#123;</span><br><span class="line">            students[i] = <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        students[<span class="number">0</span>].setName(<span class="string">&quot;ctx&quot;</span>);</span><br><span class="line">        students[<span class="number">0</span>].setAge(<span class="number">20</span>);</span><br><span class="line">        students[<span class="number">0</span>].setId_num(<span class="string">&quot;2023211949&quot;</span>);</span><br><span class="line">        students[<span class="number">0</span>].setClass_info(<span class="string">&quot;23dx0211&quot;</span>);</span><br><span class="line"></span><br><span class="line">        students[<span class="number">2</span>].setName(<span class="string">&quot;ctx&quot;</span>);</span><br><span class="line">        students[<span class="number">2</span>].setAge(<span class="number">21</span>);</span><br><span class="line">        students[<span class="number">2</span>].setId_num(<span class="string">&quot;2023211950&quot;</span>);</span><br><span class="line">        students[<span class="number">2</span>].setClass_info(<span class="string">&quot;23dx0211&quot;</span>);</span><br><span class="line"></span><br><span class="line">        students[<span class="number">1</span>].setName(<span class="string">&quot;zwc&quot;</span>);</span><br><span class="line">        students[<span class="number">1</span>].setAge(<span class="number">20</span>);</span><br><span class="line">        students[<span class="number">1</span>].setId_num(<span class="string">&quot;2023211940&quot;</span>);</span><br><span class="line">        students[<span class="number">1</span>].setClass_info(<span class="string">&quot;23dx0210&quot;</span>);</span><br><span class="line"></span><br><span class="line">        stu_num = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Student&gt; <span class="title function_">getStudents_name</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        stu_list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">stu_num</span>  <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; students.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (students[i].getName()!=<span class="literal">null</span>&amp;&amp;students[i].getName().equals(name))</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;find the studrent:&quot;</span>+i);</span><br><span class="line">                stu_list.add(students[i]);</span><br><span class="line">                stu_num ++ ;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(stu_num==<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;stu_name_is_null&quot;</span>);</span><br><span class="line">            stu_list.add(stu_null);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> stu_list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Student&gt; <span class="title function_">getStudents_id_num</span><span class="params">(String id_num)</span> &#123;</span><br><span class="line">        stu_list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">stu_num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; students.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (students[i].getId_num()!=<span class="literal">null</span> &amp;&amp; students[i].getId_num().equals(id_num))</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;find the studrent:&quot;</span>+i);</span><br><span class="line">                stu_list.add(students[i]);</span><br><span class="line">                stu_num++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(stu_num == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;the student is null&quot;</span>);</span><br><span class="line">            stu_list.add(stu_null);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> stu_list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">Rename</span><span class="params">(String id_num,String rename)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">renamed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; students.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(students[i].getId_num()!=<span class="literal">null</span>&amp;&amp;students[i].getId_num().equals(id_num))</span><br><span class="line">            &#123;</span><br><span class="line">                students[i].setName(rename);</span><br><span class="line">                renamed = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> renamed;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">Re_id_num</span><span class="params">(String id_num_pre,String id_num_aft)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">re_id_numed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; students.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(students[i].getId_num()!=<span class="literal">null</span>&amp;&amp;students[i].getId_num().equals(id_num_pre))</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;find_stu&quot;</span>+i);</span><br><span class="line">                students[i].setId_num(id_num_aft);</span><br><span class="line">                re_id_numed = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(re_id_numed);</span><br><span class="line">        <span class="keyword">return</span> re_id_numed;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">Reage</span><span class="params">(String id_num,<span class="type">int</span> reage)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">reaged</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; students.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(students[i].getId_num()!=<span class="literal">null</span>&amp;&amp;students[i].getId_num().equals(id_num))</span><br><span class="line">            &#123;</span><br><span class="line">                students[i].setAge(reage);</span><br><span class="line">                reaged = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> reaged;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">Reclass</span><span class="params">(String id_num,String reclass)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">reclassed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; students.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(students[i].getId_num()!=<span class="literal">null</span>&amp;&amp;students[i].getId_num().equals(id_num))</span><br><span class="line">            &#123;</span><br><span class="line">                students[i].setClass_info(reclass);</span><br><span class="line">                reclassed = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> reclassed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">add_item</span><span class="params">(String add_name,String add_id_num,<span class="type">int</span> add_age,String add_class)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">added</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        students[stu_num].setName(add_name);</span><br><span class="line">        students[stu_num].setId_num(add_id_num);</span><br><span class="line">        students[stu_num].setAge(add_age);</span><br><span class="line">        students[stu_num].setClass_info(add_class);</span><br><span class="line">        stu_num++;</span><br><span class="line">        added = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> added;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">rm_item</span><span class="params">(String rm_id_num)</span>&#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">rmed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">loc</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; students.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(students[i].getId_num().equals(rm_id_num)) &#123;</span><br><span class="line">                loc = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> loc; i &lt; stu_num; i++) &#123;</span><br><span class="line">            students[i] = students[i+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stu_num--;</span><br><span class="line">        rmed = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> rmed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">show_all</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;total: &quot;</span>+stu_num);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; stu_num; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;name: &quot;</span>+students[i].getName()+<span class="string">&quot; age: &quot;</span>+students[i].getAge()+<span class="string">&quot; id: &quot;</span>+students[i].getId_num()+<span class="string">&quot; class: &quot;</span>+students[i].getClass_info());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Student[] students;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Student stu_null;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ArrayList&lt;Student&gt; stu_list;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> stu_num;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="开发记录"><a href="#开发记录" class="headerlink" title="开发记录"></a>开发记录</h2><h3 id="1-ArrayList-的使用"><a href="#1-ArrayList-的使用" class="headerlink" title="1.ArrayList 的使用"></a>1.ArrayList 的使用</h3><p>在存储对象的时候，一开始想把对象存储在数组中，也就是对象数组，当然最后也是这么存的，但在查找类的构建过程中，意识到可能存在重名情况，因此不能固定返回一个Student对象，而应该返回一个数组</p><p>然而，数组的长度是不确定的，所以引入ArrayList可变长数组来进行对象的动态数目存储</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// new ArrayList 对象：</span></span><br><span class="line">ArrayList&lt;Student&gt; stu_list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//增加元素：</span></span><br><span class="line">stu_list.add(stu_example);</span><br><span class="line"></span><br><span class="line"><span class="comment">//作为函数返回值：</span></span><br><span class="line"><span class="keyword">public</span> ArrayList&lt;stduent&gt; <span class="title function_">method</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础语法</title>
      <link href="/2025/01/07/cmake/"/>
      <url>/2025/01/07/cmake/</url>
      
        <content type="html"><![CDATA[<h2 id="CMakeLists-txt编写"><a href="#CMakeLists-txt编写" class="headerlink" title="CMakeLists.txt编写"></a>CMakeLists.txt编写</h2><ul><li>文件名必须严格写为CMakeLists</li></ul><h3 id="基础的三句话："><a href="#基础的三句话：" class="headerlink" title="基础的三句话："></a>基础的三句话：</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cmake_minmum_required (VERSION <span class="number">2.8</span>) //这句话指的是支持的cmake最低版本</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span> (<span class="keyword">test</span>)//这句话是项目名称</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(test_executable_file main.c) </span><br><span class="line">//这句话有两类参数，第一个参数是预计生成的可执行文件，后面的参数是Cpp语言源文件，</span><br><span class="line">如果说有多个源文件，则在第二类参数里面添加，比如：</span><br><span class="line"><span class="keyword">add_executable</span>(test2 main.cpp <span class="keyword">test</span>.cpp)</span><br></pre></td></tr></table></figure><h3 id="清除命令："><a href="#清除命令：" class="headerlink" title="清除命令："></a>清除命令：</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">make clean //清除test_executable_file可执行文件</span><br><span class="line"></span><br><span class="line">rm -rf CMakeFiles CMakeCache.txt cmake_install.cmake Makefile test_executable_file //删干净</span><br></pre></td></tr></table></figure><h3 id="将所有文件包含进去的命令："><a href="#将所有文件包含进去的命令：" class="headerlink" title="将所有文件包含进去的命令："></a>将所有文件包含进去的命令：</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">aux_source_directionary(dir var)</span><br><span class="line"><span class="comment">#这句话有两个参数，前面一个dir指的是目标路径，后面的var指的是一个变量</span></span><br><span class="line"><span class="comment">#因此这句话的作用就是，把dir路径下的cpp文件列表存到var变量里</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#对应的，add_executable() 的第二个参数变为 $&#123;var&#125;:</span></span><br><span class="line"><span class="keyword">add_executable</span>(<span class="keyword">test</span> <span class="variable">$&#123;var&#125;</span>)</span><br></pre></td></tr></table></figure><h3 id="用set命令来指定我们想包含的文件："><a href="#用set命令来指定我们想包含的文件：" class="headerlink" title="用set命令来指定我们想包含的文件："></a>用set命令来指定我们想包含的文件：</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> (var</span><br><span class="line">./mian.c</span><br><span class="line">./test1.c</span><br><span class="line">./test2.c</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">#这个命令把上面三个c文件列表存到了var变量，同样的 add_executable()的第二个参数也是变为$&#123;var&#125;</span></span><br></pre></td></tr></table></figure><h3 id="指定头文件路径"><a href="#指定头文件路径" class="headerlink" title="指定头文件路径"></a>指定头文件路径</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include_directories</span> (dir1 dir2)</span><br><span class="line"><span class="comment">#把dir1 和dir2 内的头文件包含进去</span></span><br></pre></td></tr></table></figure><h2 id="构建项目结构"><a href="#构建项目结构" class="headerlink" title="构建项目结构"></a>构建项目结构</h2><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_subdirectory</span>(source_dir [binary_dir] [EXCLUDE_FROM_ALL])</span><br></pre></td></tr></table></figure><ul><li><p>source_dir 源代码目录</p><p>指定一个包含CMakeLists.txt和代码文件所在的目录，该目录可以是绝对路径，也可以是相对路径，对于后者相对路径的起点是CMAKE_CURRENT_SOURCE_DIR。此外，如果子目录再次包含的CMakeLists.txt，则将继续处理里层的CMakeLists.txt，而不是继续处理当前源代码</p></li><li><p>binary_dir 二进制代码目录</p><p>这个目录是可选的，如果指定，cmake命令执行后的输出文件将会存放在此处，若没有指定，默认情况等于<code>source_dir</code>没有进行相对路径计算前的路径，也就是<code>CMAKE_BINARY_DIR</code></p></li><li><p>EXCLUDE_FEOM_ALL</p><p>这个标志是可选的，如果传递了该参数表示新增加的子目录将会排除在ALL目录之外</p></li></ul><h4 id="双CMakeLists法："><a href="#双CMakeLists法：" class="headerlink" title="双CMakeLists法："></a>双CMakeLists法：</h4><ul><li><p>在根目录下构建 CMakeLists.txt ，然后再这个lists里面，使用add_subdirectionary命令，使编译过程转到src文件夹内的CMakeLists里面</p></li><li><p>在src的CMakeLists里面，编写主要工作：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">aux_source_directionary (. src_list)</span><br><span class="line"><span class="keyword">include_directories</span> (../<span class="keyword">include</span>)</span><br><span class="line"><span class="keyword">add_executable</span> (main <span class="variable">$&#123;src_list&#125;</span>)</span><br><span class="line"><span class="keyword">set</span> (EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/bin)</span><br></pre></td></tr></table></figure><ul><li>EXECUTABLE_OUTPUT_PATH ：目标二进制可执行文件的存放位置</li><li>PROJECT_SOURCE_DIR：工程的根目录</li></ul><p>这两个都是cmake的预定义变量，直接拿来用</p></li><li><p>在build目录下执行cmake过程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake ..</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>cd build以后，会把执行编译生成的文件放在build里面，防止把代码结构变成史</p><p>cmake .. 的含义，是从上一级目录中寻找cmakelist</p></li></ul><h4 id="单CMakeLists法"><a href="#单CMakeLists法" class="headerlink" title="单CMakeLists法"></a>单CMakeLists法</h4><p>直接在根目录下编写cmakelist，并把参数写好</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cmake_minmun_required (VERSION <span class="number">2.8</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(single_cmakelist)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/bin) <span class="comment">#把可执行文件放到bin里边</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">aux_source_directory</span> (src SRC_LIST)</span><br><span class="line"></span><br><span class="line"><span class="keyword">include_directories</span> (<span class="keyword">include</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span> (main <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br></pre></td></tr></table></figure><p>同样的，新建一个bulid文件夹然后在里面cmake .. make即可</p><h4 id="二者的区别"><a href="#二者的区别" class="headerlink" title="二者的区别"></a>二者的区别</h4><p>最明显的区别就是，双cmakelist利用了add_subdirectoryI()函数进入后优先执行字母里cmakelist的特性</p><p>把整个编译过程分层了，分成外层的控制全局和内层的具体实现</p><h2 id="动态库和静态库的编译控制"><a href="#动态库和静态库的编译控制" class="headerlink" title="动态库和静态库的编译控制"></a>动态库和静态库的编译控制</h2><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span> (VERSION <span class="number">3.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span> (demo)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> (SRC_LIST <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/testFunc/testFunc.c) <span class="comment">#把src路径设置好</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">add_library</span> (testFunc_shared SHARED <span class="variable">$&#123;SRC_LIST&#125;</span>)  <span class="comment">#第1个参数指定库的名字；第2个参数决定是动态还是静态，如果没有就默认静态；第3个参数指定生成库的源文件</span></span><br><span class="line"><span class="keyword">add_library</span> (testFunc_static STATIC <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set_target_properties</span> (testFunc_shared PROPERTIES OUTPUT_NAME <span class="string">&quot;testFunc&quot;</span>) </span><br><span class="line"><span class="keyword">set_target_properties</span> (testFunc_static PROPERTIES OUTPUT_NAME <span class="string">&quot;testFunc&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> (LIBRARY_OUTPUT_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span> (VERSION <span class="number">3.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span> (demo)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> (EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/bin)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> (SRC_LIST <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/src/main.c)</span><br><span class="line"></span><br><span class="line"><span class="comment"># find testFunc.h</span></span><br><span class="line"><span class="keyword">include_directories</span> (<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/testFunc/inc)</span><br><span class="line"></span><br><span class="line"><span class="keyword">find_library</span>(TESTFUNC_LIB testFunc HINTS <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/testFunc/lib)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span> (main <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span> (main <span class="variable">$&#123;TESTFUNC_LIB&#125;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>find_library: 在指定目录下查找指定库，并把库的绝对路径存放到变量里，其第一个参数是变量名称，第二个参数是库名称，第三个参数是HINTS，第4个参数是路径，其它用法可以参考cmake文档</li><li>target_link_libraries: 把目标文件与库文件进行链接</li></ul><h2 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h2><h3 id="简单程序"><a href="#简单程序" class="headerlink" title="简单程序"></a>简单程序</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span> (VERSION <span class="number">2.8</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span> (demo)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> (EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/bin)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_compile_options</span>(-std=c++<span class="number">11</span> -Wall)  <span class="comment">#这句话</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(main main.cpp)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="生成指定的bin"><a href="#生成指定的bin" class="headerlink" title="生成指定的bin"></a>生成指定的bin</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(demo)</span><br><span class="line"></span><br><span class="line"><span class="keyword">option</span>(MYDEBUG <span class="string">&quot;enable debug compilation&quot;</span> <span class="keyword">OFF</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> (EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/bin)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_subdirectory</span>(src)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用option命令，第一个参数是用户自己规定的名字，中间是显示的信息，最后一个是开关，不写默认是关</p><p>然后在src的cmakelist里面就可以读取呼呼自己输入的名字的开关状态来决定：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span> (VERSION <span class="number">3.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(main1 main1.c)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (MYDEBUG) <span class="comment">#如果为ON</span></span><br><span class="line">    <span class="keyword">add_executable</span>(main2 main2.c)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;Currently is not in debug mode&quot;</span>)    </span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CMake </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>静态库/动态库</title>
      <link href="/2025/01/07/%E9%9D%99%E6%80%81%E5%BA%93%E5%8A%A8%E6%80%81%E5%BA%93/"/>
      <url>/2025/01/07/%E9%9D%99%E6%80%81%E5%BA%93%E5%8A%A8%E6%80%81%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h2 id="形式"><a href="#形式" class="headerlink" title="形式"></a>形式</h2><p>一般来说，Windows的静态库文件扩展名是 .lib，动态库文件扩展名是 .dll (Dynamic-Link Libraries)；Linux的静态库扩展名是 .a，动态库扩展名是 .so (Shared Object)</p><p>Linux系统存储的库的位置一般在：&#x2F;lib 和 &#x2F;usr&#x2F;lib。 在 64 位的系统上有些库也可能被存储在&#x2F;usr&#x2F;lib64 下。库的头文件一般会被存储在 &#x2F;usr&#x2F;include 下或其子目录下。<br>Linux库有两种，一种是静态库，其命令规则为 libxxx.a；一种是共享库，其命令规则为 libxxx.so</p><h2 id="生成"><a href="#生成" class="headerlink" title="生成"></a>生成</h2><h3 id="静态库生成"><a href="#静态库生成" class="headerlink" title="静态库生成"></a>静态库生成</h3><h4 id="step1-编译生成-o文件"><a href="#step1-编译生成-o文件" class="headerlink" title="step1 编译生成.o文件"></a>step1 编译生成.o文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c hello.c</span><br></pre></td></tr></table></figure><p>此时将会生成一个hello.o文件 </p><p>-c 和含义：只编译，不链接</p><h4 id="step2-使用-o文件生成-a静态库"><a href="#step2-使用-o文件生成-a静态库" class="headerlink" title="step2 使用.o文件生成 .a静态库"></a>step2 使用.o文件生成 .a静态库</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ar -crv libhello.a hello.o</span><br></pre></td></tr></table></figure><p>-crv是ar命令的选项：c，r，v分别代表crate，replace，verbose</p><ol><li><strong><code>-c</code> (create)：</strong><ul><li>表示创建一个新的静态库文件（即 <code>libhello.a</code>）。</li><li>如果库文件已经存在，<code>-c</code> 不会报错，而是继续执行操作。</li><li>如果没有此选项，<code>ar</code> 在库文件不存在时可能会提示错误。</li></ul></li><li><strong><code>-r</code> (replace)：</strong><ul><li>将一个或多个目标文件（如 <code>hello.o</code>）添加到静态库中。</li><li>如果静态库中已经存在同名文件，则替换它。</li><li>如果静态库中不存在该文件，则会新增该文件。</li></ul></li><li><strong><code>-v</code> (verbose)：</strong><ul><li>显示详细信息。</li><li>在执行操作时，会列出具体处理了哪些目标文件。</li></ul></li></ol><h3 id="动态库生成"><a href="#动态库生成" class="headerlink" title="动态库生成"></a>动态库生成</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -shared -fPIC -o libhyhello.so hello.o</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o hello main.c libhyhello.so </span><br></pre></td></tr></table></figure><p><strong><code>-shared</code></strong></p><ul><li>指定生成一个共享库（动态库，<code>.so</code> 文件）</li><li>共享库是运行时动态加载的，适用于多进程共享代码，减少内存占用</li></ul><p><strong><code>-fPIC</code></strong></p><ul><li>生成位置无关代码（Position-Independent Code）</li><li><strong>作用：</strong> 共享库在内存中加载到任何地址都能正常运行，这对于动态库至关重要</li><li><code>hello.o</code> 必须是通过 <code>-fPIC</code> 编译生成的，确保目标代码是位置无关的</li></ul><p><strong><code>-o libhyhello.so</code></strong></p><ul><li>指定输出文件名为 <code>libhyhello.so</code>，这是动态库的标准命名格式</li><li>Linux 系统中，动态库通常以 <code>lib</code> 开头，扩展名为 <code>.so</code>（shared object）</li></ul><p><strong><code>hello.o</code></strong></p><ul><li>输入文件，是先前用 <code>gcc</code> 编译生成的目标文件</li></ul><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o hello main.c -L. -lhello</span><br></pre></td></tr></table></figure><p><strong><code>-L.</code></strong></p><ul><li>指定库的搜索路径为当前目录 (<code>.</code>)。</li><li>链接器在查找静态库或动态库时，除了默认的路径（如 <code>/usr/lib</code>、<code>/usr/local/lib</code>），也会在当前目录中查找。</li><li><strong>作用：</strong> 如果静态库文件 <code>libhello.a</code> 或动态库文件 <code>libhello.so</code> 位于当前目录，这个选项确保它们能够被正确找到。</li></ul><p><strong><code>-lhello</code></strong></p><ul><li>表示链接名为 <code>hello</code> 的库。</li><li>工作原理：<ul><li>链接器会自动寻找以下文件：<ul><li>静态库：<code>libhello.a</code></li><li>动态库：<code>libhello.so</code></li></ul></li><li>搜索路径包括默认路径和通过 <code>-L</code> 指定的路径（这里是当前目录 <code>.</code>）。</li></ul></li></ul><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c libhyhello.a -o hello</span><br></pre></td></tr></table></figure><h3 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -c main.c</span><br><span class="line">gcc -o hello main.o libmyhello.a</span><br></pre></td></tr></table></figure><h2 id="GCC命令相同时，会先执行-a文件，还是会先执行-so文件？"><a href="#GCC命令相同时，会先执行-a文件，还是会先执行-so文件？" class="headerlink" title="GCC命令相同时，会先执行.a文件，还是会先执行.so文件？"></a>GCC命令相同时，会先执行.a文件，还是会先执行.so文件？</h2><p>先删除除.c和.h文件外的所有文件，然后再编译形成.o文件，生成.o文件后，再由.o文件分别生成.a文件和.so文件。<br>执行程序后，发现当静态库和动态库同名时，gcc 命令将优先使用动态库，默认去连&#x2F;usr&#x2F;lib 和&#x2F;lib 等目录中的动态库。</p><h2 id="静态库与动态库的区别"><a href="#静态库与动态库的区别" class="headerlink" title="静态库与动态库的区别"></a>静态库与动态库的区别</h2><p>每一个程序在使用静态库时，都会将静态库文件拷贝一份添加到自身。如果有多个程序都要使用该静态库文件时，都会给自身添加一份拷贝，这就导致会产生空间浪费。在源文件较少时不明显，但如果在一个项目中，静态库文件本身就比较大，并且使用该静态库文件的源程序很多，这就会造成大量内存浪费。<br>而动态库文件在被使用时，会对所有想使用该动态库的源程序添加一个标记，在程序执行时再链接动态库文件使用。这就是动态库的优点，也是动态库被称为共享库的原因。</p><p>参考资料<a href="https://blog.csdn.net/weixin_43717839/article/details/127991174?spm=1001.2014.3001.5502">【C++】静态库和动态库文件的生成和使用_c++ .a文件-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CMake </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础语法</title>
      <link href="/2024/12/04/C++_%E5%85%A5%E9%97%A8/"/>
      <url>/2024/12/04/C++_%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="1-基础语法"><a href="#1-基础语法" class="headerlink" title="1. 基础语法"></a><strong>1. 基础语法</strong></h2><h3 id="1-1-引用运算-和-const-关键字"><a href="#1-1-引用运算-和-const-关键字" class="headerlink" title="1.1 引用运算 &amp; 和 const 关键字"></a><strong>1.1 引用运算 <code>&amp;</code> 和 <code>const</code> 关键字</strong></h3><h4 id="引用运算"><a href="#引用运算" class="headerlink" title="引用运算 &amp;"></a><strong>引用运算 <code>&amp;</code></strong></h4><p>引用是已有变量的别名，创建引用时不会分配新内存，而是直接操作原变量。<br><strong>引用的特性：</strong></p><ol><li>必须在定义时初始化。</li><li>一旦初始化，就和原变量绑定，不能重新绑定。</li></ol><p><strong>代码示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> &amp;ref = a; <span class="comment">// ref 是 a 的引用</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;, ref = &quot;</span> &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    ref = <span class="number">20</span>; <span class="comment">// 修改 ref，相当于修改 a</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;After modifying ref: a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;, ref = &quot;</span> &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = 10, ref = 10</span><br><span class="line">After modifying ref: a = 20, ref = 20</span><br></pre></td></tr></table></figure><h5 id="常见应用："><a href="#常见应用：" class="headerlink" title="常见应用："></a><strong>常见应用：</strong></h5><ol><li><strong>函数传参：</strong> 引用作为函数参数可以避免值传递时的拷贝，提高效率。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">(<span class="type">int</span> &amp;n)</span> </span>&#123;</span><br><span class="line">    n++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">increment</span>(x);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;x = &quot;</span> &lt;&lt; x &lt;&lt; endl; <span class="comment">// 输出 x = 6</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>引用返回值：</strong> 引用可以作为函数返回值，允许函数返回原始变量的引用。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">getReference</span><span class="params">(<span class="type">int</span> &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x; <span class="comment">// 返回引用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> &amp;ref = <span class="built_in">getReference</span>(a); </span><br><span class="line">    ref = <span class="number">20</span>; <span class="comment">// 修改引用，影响原变量</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl; <span class="comment">// 输出 a = 20</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="const-关键字"><a href="#const-关键字" class="headerlink" title="const 关键字"></a><strong><code>const</code> 关键字</strong></h4><p><code>const</code>可以修饰变量、函数参数、成员函数等，表示不可修改的属性。</p><p><strong>修饰变量：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> x = <span class="number">10</span>; <span class="comment">// x 是常量</span></span><br><span class="line">x = <span class="number">20</span>;           <span class="comment">// 错误：x 不能被修改</span></span><br></pre></td></tr></table></figure><p><strong>修饰函数参数：</strong> 用<code>const</code>修饰函数参数，可以防止函数修改传入的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// n 是只读的，不能修改</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;n = &quot;</span> &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于类对象或结构体，通过引用传递避免拷贝开销，同时用 <code>const</code> 确保不会修改内容：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;MyClass display&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showObject</span><span class="params">(<span class="type">const</span> MyClass &amp;obj)</span> </span>&#123;</span><br><span class="line">    obj.<span class="built_in">display</span>(); <span class="comment">// 可以调用 const 方法</span></span><br><span class="line">    <span class="comment">// obj.modify(); // 错误：obj 是 const，不能调用能修改内容的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>修饰指针：</strong></p><ul><li>指针本身不可修改：<code>int *const ptr;</code></li><li>指针指向的值不可修改：<code>const int *ptr;</code></li></ul><p><strong>代码示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cpp复制代码<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> a = <span class="number">10</span>;        <span class="comment">// a 是常量，不能修改</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> *ptr = &amp;a;     <span class="comment">// 指向常量的指针</span></span><br><span class="line">    <span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="type">int</span> *<span class="type">const</span> constPtr = &amp;b; <span class="comment">// 常量指针，地址不能修改</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="1-2-内联函数"><a href="#1-2-内联函数" class="headerlink" title="1.2 内联函数"></a><strong>1.2 内联函数</strong></h3><p>一言以蔽之，内联函数类似于宏定义</p><h4 id="内联函数的定义："><a href="#内联函数的定义：" class="headerlink" title="内联函数的定义："></a><strong>内联函数的定义：</strong></h4><p>内联函数是通过 <code>inline</code> 关键字声明的函数，目的是告诉编译器尽可能将该函数的代码插入到函数调用的位置，而不是通过正常的函数调用机制（如栈操作）来执行。通过这种方式，函数调用的开销可以被消除，从而提高程序的运行效率。</p><h4 id="内联函数的优点："><a href="#内联函数的优点：" class="headerlink" title="内联函数的优点："></a><strong>内联函数的优点：</strong></h4><ol><li><strong>避免函数调用开销</strong><br>每次函数调用都涉及一些开销，包括参数传递、栈帧的创建和销毁、函数返回等。对于非常简单的函数（如常见的数学计算、获取属性值等），每次调用这些小函数时，编译器可以直接将函数体嵌入到调用处，消除这些开销。</li><li><strong>增强代码效率，适合频繁调用的小函数</strong><br>内联函数尤其适用于那些频繁调用的函数，因为它可以减少函数调用的时间开销。当一个小函数被大量调用时，内联可以显著提高程序的执行效率。例如，一些简单的 getter、setter 函数、数值计算函数等，内联处理后能显著优化性能。</li><li><strong>减少函数调用栈开销</strong><br>传统函数调用需要维护调用栈，而内联函数的展开直接将代码嵌入调用处，避免了栈的创建和销毁过程，从而减少了内存和处理器的负担。</li></ol><h4 id="内联函数的语法："><a href="#内联函数的语法：" class="headerlink" title="内联函数的语法："></a><strong>内联函数的语法：</strong></h4><p>内联函数的语法与普通函数唯一的区别是在函数前加上 <code>inline</code> 关键字。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">square</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Square of 5: &quot;</span> &lt;&lt; <span class="built_in">square</span>(<span class="number">5</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在这个例子中，<code>square</code> 函数被声明为内联函数。<code>inline</code> 关键字告诉编译器尽可能将这个函数的代码直接插入到调用它的地方。</li><li>当程序运行时，编译器会将 <code>square(5)</code> 替换为 <code>5 * 5</code>，避免了调用函数的传统开销。</li></ul><h4 id="内联函数的使用场景："><a href="#内联函数的使用场景：" class="headerlink" title="内联函数的使用场景："></a><strong>内联函数的使用场景：</strong></h4><p>内联函数最适合用于以下几种情况：</p><ol><li><strong>简单函数</strong>：内联函数最适合那些计算量小、逻辑简单的函数。例如，单纯的数学运算、获取和设置变量值等。内联不会对大型、复杂的函数有显著的优化效果。</li><li><strong>频繁调用的函数</strong>：对于需要频繁调用的短小函数，内联可以减少函数调用的时间和开销，尤其是在嵌套调用和循环中调用的函数。</li><li><strong>不涉及递归</strong>：内联函数不适合递归函数，因为递归的每一次调用都涉及到不同的栈帧和参数，因此递归的内联展开会导致性能下降。</li><li><strong>避免大量栈操作的函数</strong>：如果一个函数没有太多的局部变量，也没有复杂的逻辑，使用内联可以避免函数调用时产生的栈开销。</li></ol><h4 id="内联函数的限制："><a href="#内联函数的限制：" class="headerlink" title="内联函数的限制："></a><strong>内联函数的限制：</strong></h4><ol><li><strong>不同编译器标准不同</strong><br>通过 <code>inline</code> 关键字声明函数并不意味着编译器一定会将其内联展开。编译器可能会基于函数的复杂性、调用频率、优化目标等因素决定是否进行内联展开。因此，内联函数只是对编译器的一个建议，而非强制要求。</li><li><strong>复杂函数不适合内联</strong><br>内联函数适用于简单的、计算量小的函数。对于逻辑复杂、体积较大的函数，内联可能导致代码膨胀，使得代码变得冗长、占用更多内存，甚至可能引发性能下降。</li><li><strong>递归函数不应内联</strong><br>递归函数是不能内联的，因为每次递归都会创建新的栈帧，而内联函数的目的是减少栈开销。递归展开会导致栈帧无法共享，进而消除内联的优势。</li></ol><h4 id="编译器如何决定内联展开："><a href="#编译器如何决定内联展开：" class="headerlink" title="编译器如何决定内联展开："></a><strong>编译器如何决定内联展开：</strong></h4><ul><li>对于小函数，编译器通常会自动进行内联优化，即使没有显式声明 <code>inline</code>。</li><li>对于较大的函数，编译器一般不会内联，因为内联会导致代码膨胀，增加 CPU 缓存的压力，反而可能带来性能下降。</li><li>编译器还可能根据一些编译选项、优化级别等决定是否内联。</li></ul><h4 id="内联与宏的比较："><a href="#内联与宏的比较：" class="headerlink" title="内联与宏的比较："></a><strong>内联与宏的比较：</strong></h4><p>内联函数有时可以替代宏（<code>#define</code>）来进行常见的计算，但它们之间有一些重要区别：</p><ul><li><strong>类型安全</strong>：内联函数是强类型的，宏没有类型检查，容易引发隐式类型转换错误。</li><li><strong>调试友好</strong>：内联函数可以被调试器追踪，而宏无法单步调试。</li><li><strong>作用域</strong>：内联函数遵循正常的作用域规则，而宏在预处理阶段进行替换，可能引发作用域问题。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SQUARE(x) ((x) * (x)) <span class="comment">// 宏</span></span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">square</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x * x; &#125; <span class="comment">// 内联函数</span></span><br></pre></td></tr></table></figure><p>内联函数相较于宏有更强的类型检查和更好的可维护性。</p><hr><h3 id="1-3-函数参数缺省值"><a href="#1-3-函数参数缺省值" class="headerlink" title="1.3 函数参数缺省值"></a><strong>1.3 函数参数缺省值</strong></h3><h4 id="缺省参数的规则："><a href="#缺省参数的规则：" class="headerlink" title="缺省参数的规则："></a><strong>缺省参数的规则：</strong></h4><ol><li>缺省值从右向左定义。(不能两边有缺省值，中间夹着一个正常的)</li><li>调用时可以省略有缺省值的参数。</li></ol><h4 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a><strong>代码示例：</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">greet</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name = <span class="string">&quot;Guest&quot;</span>, <span class="type">int</span> age = <span class="number">18</span>)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Hello, &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;! Age: &quot;</span> &lt;&lt; age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">greet</span>();                 <span class="comment">// 使用默认值</span></span><br><span class="line">    <span class="built_in">greet</span>(<span class="string">&quot;Alice&quot;</span>);          <span class="comment">// 覆盖第一个参数</span></span><br><span class="line">    <span class="built_in">greet</span>(<span class="string">&quot;Bob&quot;</span>, <span class="number">25</span>);        <span class="comment">// 覆盖所有参数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hello, Guest! Age: <span class="number">18</span></span><br><span class="line">Hello, Alice! Age: <span class="number">18</span></span><br><span class="line">Hello, Bob! Age: <span class="number">25</span></span><br></pre></td></tr></table></figure><hr><h3 id="1-4-输入输出"><a href="#1-4-输入输出" class="headerlink" title="1.4 输入输出"></a><strong>1.4 输入输出</strong></h3><h4 id="标准输入输出："><a href="#标准输入输出：" class="headerlink" title="标准输入输出："></a><strong>标准输入输出：</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cpp复制代码<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Enter a number: &quot;</span>;</span><br><span class="line">    cin &gt;&gt; num;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;You entered: &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>cin</code> 从键盘输入。</li><li><code>cout</code> 输出到屏幕。</li></ul><h4 id="格式化输出："><a href="#格式化输出：" class="headerlink" title="格式化输出："></a><strong>格式化输出：</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line">cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">2</span>) &lt;&lt; fixed &lt;&lt; <span class="number">3.14159</span>; <span class="comment">// 输出 3.14</span></span><br></pre></td></tr></table></figure><hr><h4 id="二进制文件读写"><a href="#二进制文件读写" class="headerlink" title="二进制文件读写"></a><strong>二进制文件读写</strong></h4><h5 id="写入二进制文件："><a href="#写入二进制文件：" class="headerlink" title="写入二进制文件："></a><strong>写入二进制文件：</strong></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Data</span> &#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">50</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Data d = &#123;<span class="number">1</span>, <span class="string">&quot;Alice&quot;</span>&#125;;</span><br><span class="line">    <span class="function">ofstream <span class="title">outFile</span><span class="params">(<span class="string">&quot;data.bin&quot;</span>, ios::binary)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (outFile) &#123;</span><br><span class="line">        outFile.<span class="built_in">write</span>((<span class="type">char</span> *)&amp;d, <span class="built_in">sizeof</span>(d));</span><br><span class="line">    &#125;</span><br><span class="line">    outFile.<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="读取二进制文件："><a href="#读取二进制文件：" class="headerlink" title="读取二进制文件："></a><strong>读取二进制文件：</strong></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">inFile</span><span class="params">(<span class="string">&quot;data.bin&quot;</span>, ios::binary)</span></span>;</span><br><span class="line">Data d;</span><br><span class="line"><span class="keyword">if</span> (inFile) &#123;</span><br><span class="line">    inFile.<span class="built_in">read</span>((<span class="type">char</span> *)&amp;d, <span class="built_in">sizeof</span>(d));</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ID: &quot;</span> &lt;&lt; d.id &lt;&lt; <span class="string">&quot;, Name: &quot;</span> &lt;&lt; d.name &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">inFile.<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure><hr><h3 id="1-5-异常处理"><a href="#1-5-异常处理" class="headerlink" title="1.5 异常处理"></a><strong>1.5 异常处理</strong></h3><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog_imgimage-20250105145816419.png" alt="image-20250105145816419"></p><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog_imgimage-20250105145901566.png" alt="image-20250105145901566"></p><h4 id="异常的基本结构："><a href="#异常的基本结构：" class="headerlink" title="异常的基本结构："></a><strong>异常的基本结构：</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;Division by zero!&quot;</span>);</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> runtime_error &amp;e) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Caught exception: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Caught exception: Division by zero!</span><br></pre></td></tr></table></figure><h4 id="常见异常类型："><a href="#常见异常类型：" class="headerlink" title="常见异常类型："></a><strong>常见异常类型：</strong></h4><ul><li><code>std::exception</code>：所有异常的基类。</li><li><code>std::runtime_error</code>：运行时错误。</li><li><code>std::invalid_argument</code>：无效参数。</li></ul><h2 id="2-类与对象"><a href="#2-类与对象" class="headerlink" title="2. 类与对象"></a><strong>2. 类与对象</strong></h2><h3 id="2-1-构造函数、复制构造函数、析构函数"><a href="#2-1-构造函数、复制构造函数、析构函数" class="headerlink" title="2.1 构造函数、复制构造函数、析构函数"></a><strong>2.1 构造函数、复制构造函数、析构函数</strong></h3><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a><strong>构造函数</strong></h4><p>构造函数是类的特殊函数，在对象创建时自动调用，用于初始化对象。<br><strong>特点：</strong></p><ol><li>名字与类名相同，无返回值。</li><li>可以重载（支持多个构造函数）。</li></ol><p><strong>语法与示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> v) &#123;</span><br><span class="line">        value = v;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Constructor called, value = &quot;</span> &lt;&lt; value &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; value &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj1</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">// 调用构造函数</span></span><br><span class="line">    obj<span class="number">1.</span><span class="built_in">display</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Constructor called, value = <span class="number">10</span></span><br><span class="line">Value: <span class="number">10</span></span><br></pre></td></tr></table></figure><hr><h4 id="复制构造函数"><a href="#复制构造函数" class="headerlink" title="复制构造函数"></a><strong>复制构造函数</strong></h4><p>复制构造函数用于通过已有对象创建新对象。<br><strong>语法：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ClassName</span>(<span class="type">const</span> ClassName &amp;obj);</span><br></pre></td></tr></table></figure><p><strong>代码示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> v) : <span class="built_in">value</span>(v) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制构造函数</span></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">const</span> MyClass &amp;obj) &#123;</span><br><span class="line">        value = obj.value;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Copy constructor called!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; value &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    MyClass obj2 = obj1; <span class="comment">// 调用复制构造函数</span></span><br><span class="line">    obj<span class="number">2.</span><span class="built_in">display</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Copy constructor called!</span><br><span class="line">Value: <span class="number">10</span></span><br></pre></td></tr></table></figure><hr><h4 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a><strong>析构函数</strong></h4><p>析构函数用于释放对象销毁时占用的资源。<br><strong>特点：</strong></p><ol><li>名字为类名前加 <code>~</code>。</li><li>无参数、无返回值。</li><li>一个类只能有一个析构函数，<strong>不能重载</strong>。</li></ol><p><strong>代码示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Constructor called!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">MyClass</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Destructor called!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Inside main function.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 程序结束，调用析构函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Constructor called!</span><br><span class="line">Inside main function.</span><br><span class="line">Destructor called!</span><br></pre></td></tr></table></figure><hr><h3 id="2-2-this-指针"><a href="#2-2-this-指针" class="headerlink" title="2.2 this 指针"></a><strong>2.2 <code>this</code> 指针</strong></h3><p><code>this</code> 是一个指针，指向调用成员函数的当前对象。常用于以下场景：</p><ol><li>区分成员变量和局部变量同名的情况。</li><li>在链式调用中返回当前对象的引用。</li></ol><p><strong>代码示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> value) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;value = value; <span class="comment">// 使用 this 指针区分成员变量和局部变量</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">MyClass &amp;<span class="title">setValue</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;value = value;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">// 返回当前对象引用</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; value &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    obj.<span class="built_in">setValue</span>(<span class="number">20</span>).<span class="built_in">display</span>(); <span class="comment">// 链式调用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Value: 20</span><br></pre></td></tr></table></figure><hr><h3 id="2-3-友元函数、静态成员变量、const-成员函数"><a href="#2-3-友元函数、静态成员变量、const-成员函数" class="headerlink" title="2.3 友元函数、静态成员变量、const 成员函数"></a><strong>2.3 友元函数、静态成员变量、<code>const</code> 成员函数</strong></h3><h4 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a><strong>友元函数</strong></h4><p>友元函数可以访问类的私有成员，通常用来实现特殊操作。<br><strong>语法：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">friend</span> ReturnType <span class="title">FunctionName</span><span class="params">(ClassName &amp;obj)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>代码示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> v) : <span class="built_in">value</span>(v) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明友元函数</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">display</span><span class="params">(<span class="type">const</span> MyClass &amp;obj)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义友元函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(<span class="type">const</span> MyClass &amp;obj)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; obj.value &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="built_in">display</span>(obj); <span class="comment">// 调用友元函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Value: 10</span><br></pre></td></tr></table></figure><hr><h4 id="静态成员变量"><a href="#静态成员变量" class="headerlink" title="静态成员变量"></a><strong>静态成员变量</strong></h4><p>静态成员变量属于类而不是对象，所有对象共享一份。<br><strong>特点：</strong></p><ol><li>必须在类外初始化。</li><li>使用 <code>ClassName::StaticMember</code> 访问。</li></ol><p><strong>代码示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count; <span class="comment">// 声明静态成员变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>() &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123; <span class="comment">// 静态成员函数</span></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化静态成员变量</span></span><br><span class="line"><span class="type">int</span> MyClass::count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj1, obj2, obj3;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Number of objects: &quot;</span> &lt;&lt; MyClass::<span class="built_in">getCount</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Number of objects: 3</span><br></pre></td></tr></table></figure><hr><h4 id="const-成员函数"><a href="#const-成员函数" class="headerlink" title="const 成员函数"></a><strong><code>const</code> 成员函数</strong></h4><p><code>const</code> 成员函数保证函数不会修改类的成员变量。<br><strong>语法：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ReturnType <span class="title">FunctionName</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><p><strong>代码示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> v) : <span class="built_in">value</span>(v) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="comment">// const 成员函数</span></span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setValue</span><span class="params">(<span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="type">const</span> MyClass <span class="title">obj</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; obj.<span class="built_in">getValue</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// obj.setValue(20); // 错误：const 对象只能调用 const 成员函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Value: 10</span><br></pre></td></tr></table></figure><hr><h3 id="2-4-数据封装与访问限定符"><a href="#2-4-数据封装与访问限定符" class="headerlink" title="2.4 数据封装与访问限定符"></a><strong>2.4 数据封装与访问限定符</strong></h3><h4 id="访问限定符"><a href="#访问限定符" class="headerlink" title="访问限定符"></a><strong>访问限定符</strong></h4><ul><li><strong><code>public</code>:</strong> 公有成员，类外部可访问。</li><li><strong><code>private</code>:</strong> 私有成员，仅类内部可访问。</li><li><strong><code>protected</code>:</strong> 受保护成员，仅类及其子类可访问。</li></ul><h4 id="代码示例：-1"><a href="#代码示例：-1" class="headerlink" title="代码示例："></a><strong>代码示例：</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> privateValue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> publicValue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> protectedValue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>() : <span class="built_in">privateValue</span>(<span class="number">10</span>), <span class="built_in">publicValue</span>(<span class="number">20</span>), <span class="built_in">protectedValue</span>(<span class="number">30</span>) &#123;&#125; <span class="comment">//构造函数初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Private: &quot;</span> &lt;&lt; privateValue &lt;&lt; <span class="string">&quot;, Public: &quot;</span> &lt;&lt; publicValue</span><br><span class="line">             &lt;&lt; <span class="string">&quot;, Protected: &quot;</span> &lt;&lt; protectedValue &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj;</span><br><span class="line">    obj.publicValue = <span class="number">50</span>; <span class="comment">// 公有成员可直接访问</span></span><br><span class="line">    <span class="comment">// obj.privateValue = 60; // 错误：私有成员不能直接访问</span></span><br><span class="line">    obj.<span class="built_in">display</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Private: 10, Public: 50, Protected: 30</span><br></pre></td></tr></table></figure><h2 id="3-运算符重载"><a href="#3-运算符重载" class="headerlink" title="3. 运算符重载"></a><strong>3. 运算符重载</strong></h2><p>运算符重载允许为用户自定义的类定义运算符的行为。<br><strong>注意：</strong></p><ul><li>不能重载 <code>::</code>（作用域解析）、<code>.</code>（成员访问）等。</li><li>至少有一个操作数是用户定义类型。</li></ul><hr><h3 id="3-1-类内运算符重载"><a href="#3-1-类内运算符重载" class="headerlink" title="3.1 类内运算符重载"></a><strong>3.1 类内运算符重载</strong></h3><p>运算符可以作为类的成员函数重载。<br><strong>语法：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ReturnType <span class="title">operatorSymbol</span><span class="params">(Arguments)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="示例：重载-运算符"><a href="#示例：重载-运算符" class="headerlink" title="示例：重载 + 运算符"></a><strong>示例：重载 <code>+</code> 运算符</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> real, imag;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Complex</span>(<span class="type">double</span> r, <span class="type">double</span> i) : <span class="built_in">real</span>(r), <span class="built_in">imag</span>(i) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 + 运算符</span></span><br><span class="line">    Complex <span class="keyword">operator</span>+(<span class="type">const</span> Complex &amp;c) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Complex</span>(real + c.real, imag + c.imag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; real &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; imag &lt;&lt; <span class="string">&quot;i&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">1.5</span>, <span class="number">2.5</span>)</span>, <span class="title">c2</span><span class="params">(<span class="number">2.0</span>, <span class="number">3.0</span>)</span></span>;</span><br><span class="line">    Complex c3 = c1 + c2; <span class="comment">// 调用运算符重载</span></span><br><span class="line">    c<span class="number">3.</span><span class="built_in">display</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3.5</span> + <span class="number">5.5</span>i</span><br></pre></td></tr></table></figure><hr><h3 id="3-2-类外运算符重载"><a href="#3-2-类外运算符重载" class="headerlink" title="3.2 类外运算符重载"></a><strong>3.2 类外运算符重载</strong></h3><p>类外定义运算符时需要将其声明为友元函数。<br><strong>语法：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">friend</span> ReturnType <span class="title">operatorSymbol</span><span class="params">(<span class="type">const</span> ClassName &amp;lhs, <span class="type">const</span> ClassName &amp;rhs)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="示例：重载"><a href="#示例：重载" class="headerlink" title="示例：重载 &lt;&lt; 运算符"></a><strong>示例：重载 <code>&lt;&lt;</code> 运算符</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> real, imag;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Complex</span>(<span class="type">double</span> r, <span class="type">double</span> i) : <span class="built_in">real</span>(r), <span class="built_in">imag</span>(i) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明友元函数</span></span><br><span class="line">    <span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="type">const</span> Complex &amp;c);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义友元函数</span></span><br><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="type">const</span> Complex &amp;c) &#123;</span><br><span class="line">    out &lt;&lt; c.real &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; c.imag &lt;&lt; <span class="string">&quot;i&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">1.5</span>, <span class="number">2.5</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Complex number: &quot;</span> &lt;&lt; c1 &lt;&lt; endl; <span class="comment">// 使用重载运算符</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Complex number: <span class="number">1.5</span> + <span class="number">2.5</span>i</span><br></pre></td></tr></table></figure><h3 id="3-3-类内运算符重载和类外运算符重载的区别"><a href="#3-3-类内运算符重载和类外运算符重载的区别" class="headerlink" title="3.3 类内运算符重载和类外运算符重载的区别"></a>3.3 类内运算符重载和类外运算符重载的区别</h3><h4 id="1-定义方式"><a href="#1-定义方式" class="headerlink" title="1. 定义方式"></a><strong>1. 定义方式</strong></h4><h5 id="类内运算符重载"><a href="#类内运算符重载" class="headerlink" title="类内运算符重载"></a><strong>类内运算符重载</strong></h5><ul><li><p><strong>定义位置：</strong> 在类的内部定义为类的成员函数。</p></li><li><p><strong>调用方式：</strong> 隐式使用类的对象调用。</p></li><li><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> v) : <span class="built_in">value</span>(v) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类内重载运算符+</span></span><br><span class="line">    MyClass <span class="keyword">operator</span>+(<span class="type">const</span> MyClass &amp;other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">MyClass</span>(value + other.value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; value &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">a</span><span class="params">(<span class="number">10</span>)</span>, <span class="title">b</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">    MyClass c = a + b; <span class="comment">// 调用类内的operator+</span></span><br><span class="line">    c.<span class="built_in">display</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h5 id="类外运算符重载"><a href="#类外运算符重载" class="headerlink" title="类外运算符重载"></a><strong>类外运算符重载</strong></h5><ul><li><p><strong>定义位置：</strong> 在类的外部定义为普通函数，通常声明为类的 <strong>友元函数</strong>（如果需要访问私有或保护成员）。</p></li><li><p><strong>调用方式：</strong> 使用运算符直接作用于类的对象。</p></li><li><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> v) : <span class="built_in">value</span>(v) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明类外友元函数用于重载运算符+</span></span><br><span class="line">    <span class="keyword">friend</span> MyClass <span class="keyword">operator</span>+(<span class="type">const</span> MyClass &amp;a, <span class="type">const</span> MyClass &amp;b);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; value &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类外定义operator+</span></span><br><span class="line">MyClass <span class="keyword">operator</span>+(<span class="type">const</span> MyClass &amp;a, <span class="type">const</span> MyClass &amp;b) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">MyClass</span>(a.value + b.value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">a</span><span class="params">(<span class="number">10</span>)</span>, <span class="title">b</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">    MyClass c = a + b; <span class="comment">// 调用类外的operator+</span></span><br><span class="line">    c.<span class="built_in">display</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="2-参数与调用区别"><a href="#2-参数与调用区别" class="headerlink" title="2. 参数与调用区别"></a><strong>2. 参数与调用区别</strong></h4><h5 id="类内运算符重载-1"><a href="#类内运算符重载-1" class="headerlink" title="类内运算符重载"></a><strong>类内运算符重载</strong></h5><ul><li><p><strong>隐式传递左操作数：</strong> 类的成员函数默认会把调用者作为 <strong>左操作数</strong>，右操作数需要通过参数传递。</p></li><li><p><strong>参数数量：</strong> 一元运算符不需要参数，二元运算符只需要一个参数（右操作数）。</p></li><li><p>调用方式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyClass a, b;</span><br><span class="line">a + b; <span class="comment">// 等价于 a.operator+(b);</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="类外运算符重载-1"><a href="#类外运算符重载-1" class="headerlink" title="类外运算符重载"></a><strong>类外运算符重载</strong></h5><ul><li><p><strong>显式传递操作数：</strong> 所有操作数都通过参数传递，包括左操作数。</p></li><li><p><strong>参数数量：</strong> 一元运算符需要一个参数，二元运算符需要两个参数。</p></li><li><p>调用方式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyClass a, b;</span><br><span class="line">a + b; <span class="comment">// 等价于 operator+(a, b);</span></span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="3-访问权限"><a href="#3-访问权限" class="headerlink" title="3. 访问权限"></a><strong>3. 访问权限</strong></h4><h5 id="类内运算符重载-2"><a href="#类内运算符重载-2" class="headerlink" title="类内运算符重载"></a><strong>类内运算符重载</strong></h5><ul><li>类内的成员函数可以直接访问类的 <strong>私有成员</strong> 和 <strong>保护成员</strong>，无需额外处理。</li></ul><h5 id="类外运算符重载-2"><a href="#类外运算符重载-2" class="headerlink" title="类外运算符重载"></a><strong>类外运算符重载</strong></h5><ul><li><p>如果类外的重载函数需要访问类的私有成员或保护成员，必须将其声明为 </p><p>友元函数</p><p>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">friend</span> MyClass <span class="keyword">operator</span>+(<span class="type">const</span> MyClass &amp;a, <span class="type">const</span> MyClass &amp;b);</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="4-功能范围"><a href="#4-功能范围" class="headerlink" title="4. 功能范围"></a><strong>4. 功能范围</strong></h4><h5 id="类内运算符重载-3"><a href="#类内运算符重载-3" class="headerlink" title="类内运算符重载"></a><strong>类内运算符重载</strong></h5><ul><li><p>类内重载通常用于运算符的 </p><p>左操作数</p><p> 必须是类的对象，例如：</p><ul><li><code>a + b</code> 中，<code>a</code> 必须是类的对象。</li><li>如果左操作数不是类的对象（如 <code>3 + a</code>），类内运算符无法直接处理。</li></ul></li></ul><h5 id="类外运算符重载-3"><a href="#类外运算符重载-3" class="headerlink" title="类外运算符重载"></a><strong>类外运算符重载</strong></h5><ul><li>类外重载可以处理更灵活的场景，比如：<ul><li>左操作数是类对象时：<code>a + b</code>。</li><li>左操作数不是类对象时：<code>3 + a</code>。</li></ul></li></ul><p><strong>示例：支持 <code>3 + a</code> 的类外重载：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> v) : <span class="built_in">value</span>(v) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> MyClass <span class="keyword">operator</span>+(<span class="type">int</span> num, <span class="type">const</span> MyClass &amp;a); <span class="comment">// 支持3 + a</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类外定义</span></span><br><span class="line">MyClass <span class="keyword">operator</span>+(<span class="type">int</span> num, <span class="type">const</span> MyClass &amp;a) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">MyClass</span>(num + a.value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">a</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    MyClass b = <span class="number">3</span> + a; <span class="comment">// 支持左操作数为普通数据</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="5-代码设计与适用场景"><a href="#5-代码设计与适用场景" class="headerlink" title="5. 代码设计与适用场景"></a><strong>5. 代码设计与适用场景</strong></h4><table><thead><tr><th><strong>比较维度</strong></th><th><strong>类内运算符重载</strong></th><th><strong>类外运算符重载</strong></th></tr></thead><tbody><tr><td><strong>适用性</strong></td><td>左操作数必须是类对象。</td><td>左操作数可以是类对象或其他类型。</td></tr><tr><td><strong>访问权限</strong></td><td>能直接访问类的私有或保护成员。</td><td>需要声明为友元函数才能访问私有成员。</td></tr><tr><td><strong>代码风格</strong></td><td>更紧密地绑定类本身，逻辑集中在类内。</td><td>功能更灵活，适合跨类或跨类型的操作符重载。</td></tr><tr><td><strong>实现复杂度</strong></td><td>较简单，适合常见的运算符重载。</td><td>适合需要更高灵活性的重载场景。</td></tr></tbody></table><hr><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h4><ul><li><strong>类内运算符重载：</strong><ul><li>左操作数必须是类对象。</li><li>使用更简单，适合内部逻辑紧密绑定类的情况。</li></ul></li><li><strong>类外运算符重载：</strong><ul><li>左操作数可以是类对象，也可以是其他类型。</li><li>更灵活，适合需要处理跨类或多种数据类型操作的场景。</li></ul></li></ul><hr><h2 id="4-多线程"><a href="#4-多线程" class="headerlink" title="4. 多线程"></a><strong>4. 多线程</strong></h2><p>多线程使程序可以同时运行多个任务，提高效率。C++11 提供了 <code>std::thread</code> 支持多线程。</p><hr><h3 id="4-1-创建线程"><a href="#4-1-创建线程" class="headerlink" title="4.1 创建线程"></a><strong>4.1 创建线程</strong></h3><h4 id="语法："><a href="#语法：" class="headerlink" title="语法："></a><strong>语法：</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 线程要执行的代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(function)</span></span>; <span class="comment">// 创建线程</span></span><br><span class="line">    t.<span class="built_in">join</span>(); <span class="comment">// 等待线程执行完毕</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="示例：简单线程创建"><a href="#示例：简单线程创建" class="headerlink" title="示例：简单线程创建"></a><strong>示例：简单线程创建</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printMessage</span><span class="params">(<span class="type">const</span> string &amp;msg)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Message: &quot;</span> &lt;&lt; msg &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(printMessage, <span class="string">&quot;Hello from thread!&quot;</span>)</span></span>; <span class="comment">// 创建线程</span></span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>(); <span class="comment">// 等待线程结束</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Message: Hello from thread!</span><br></pre></td></tr></table></figure><hr><h3 id="4-2-多线程同步"><a href="#4-2-多线程同步" class="headerlink" title="4.2 多线程同步"></a><strong>4.2 多线程同步</strong></h3><p>为了避免多个线程同时修改共享资源，C++ 提供了互斥锁 (<code>std::mutex</code>)。</p><h4 id="示例：使用互斥锁"><a href="#示例：使用互斥锁" class="headerlink" title="示例：使用互斥锁"></a><strong>示例：使用互斥锁</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">mutex mtx; <span class="comment">// 定义互斥锁</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printNumbers</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        mtx.<span class="built_in">lock</span>(); <span class="comment">// 加锁</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">        mtx.<span class="built_in">unlock</span>(); <span class="comment">// 解锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(printNumbers, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(printNumbers, <span class="number">2</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出（线程顺序可能不同）：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Thread <span class="number">1</span>: <span class="number">0</span></span><br><span class="line">Thread <span class="number">2</span>: <span class="number">0</span></span><br><span class="line">Thread <span class="number">1</span>: <span class="number">1</span></span><br><span class="line">Thread <span class="number">2</span>: <span class="number">1</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><h4 id="高级的lock方式："><a href="#高级的lock方式：" class="headerlink" title="高级的lock方式："></a><strong>高级的lock方式：</strong></h4><h3 id="1-std-mutex"><a href="#1-std-mutex" class="headerlink" title="1. std::mutex"></a>1. <strong><code>std::mutex</code></strong></h3><p>首先要了解的是 **<code>std::mutex</code>**，它是一个基本的互斥量，用于实现线程间的同步。在 C++11 中，<code>std::mutex</code> 提供了基本的加锁和解锁功能。</p><ul><li>**<code>std::mutex::lock()</code>**：加锁。</li><li>**<code>std::mutex::unlock()</code>**：解锁。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;  <span class="comment">// 定义一个全局的互斥量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">safeFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mtx.<span class="built_in">lock</span>();     <span class="comment">// 手动加锁</span></span><br><span class="line">    <span class="comment">// 访问或修改共享资源</span></span><br><span class="line">    mtx.<span class="built_in">unlock</span>();   <span class="comment">// 手动解锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尽管手动加锁和解锁是有效的，但它们需要小心处理，尤其是在异常发生时。如果发生异常而未能解锁互斥量，程序可能会进入死锁状态。因此，C++ 提供了 <strong><code>std::lock_guard</code></strong> 和 <strong><code>std::unique_lock</code></strong> 来简化互斥量的管理，确保锁在作用域结束时自动释放。</p><h3 id="2-std-lock-guard"><a href="#2-std-lock-guard" class="headerlink" title="2. std::lock_guard"></a>2. <strong><code>std::lock_guard</code></strong></h3><p><code>std::lock_guard</code> 是一个简单的封装，它用于在作用域内自动加锁，并且在作用域结束时自动解锁。它是一种 <strong>作用域锁</strong>，非常适合于只需要加锁并自动解锁的场景。</p><ul><li><strong>作用</strong>：当 <code>std::lock_guard</code> 对象被创建时，它会自动加锁互斥量。当 <code>std::lock_guard</code> 对象超出作用域时，它会自动调用析构函数，进而解锁互斥量。</li><li><strong>优点</strong>：避免手动解锁，降低死锁风险。</li></ul><h4 id="语法示例："><a href="#语法示例：" class="headerlink" title="语法示例："></a>语法示例：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">safeFunctionWithLockGuard</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mtx)</span></span>;  <span class="comment">// 自动加锁</span></span><br><span class="line">    <span class="comment">// 访问或修改共享资源</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Shared resource accessed with lock_guard\n&quot;</span>;</span><br><span class="line">    <span class="comment">// 锁会在lk超出作用域时自动释放</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">safeFunctionWithLockGuard</span>();  <span class="comment">// 调用函数，自动加锁和解锁</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中：</p><ul><li>当 <code>lock_guard</code> 对象 <code>lk</code> 被创建时，它会自动加锁互斥量 <code>mtx</code>。</li><li>当 <code>lk</code> 超出作用域（即 <code>safeFunctionWithLockGuard</code> 函数结束时），<code>lk</code> 会自动解锁 <code>mtx</code>。</li></ul><p><code>std::lock_guard</code> 的特点是简单且有效，但它不支持解锁或重新锁定操作，只适合于简单的加锁和解锁场景。</p><h3 id="3-std-unique-lock"><a href="#3-std-unique-lock" class="headerlink" title="3. std::unique_lock"></a>3. <strong><code>std::unique_lock</code></strong></h3><p><code>std::unique_lock</code> 是一个比 <code>std::lock_guard</code> 更加灵活的锁管理工具，它提供了比 <code>std::lock_guard</code> 更多的功能，包括：</p><ul><li>可以显式地 <strong>手动解锁</strong>。</li><li>支持 <strong>锁的延迟</strong>（即在创建 <code>unique_lock</code> 对象时不立即加锁）。</li><li>可以 <strong>重新锁定</strong>。</li><li>可以 <strong>转移锁的所有权</strong>，即将锁的所有权从一个 <code>unique_lock</code> 对象转移到另一个。</li></ul><p><code>std::unique_lock</code> 是 <strong>可移动的</strong>，而 <code>std::lock_guard</code> 不是。</p><h4 id="语法示例：-1"><a href="#语法示例：-1" class="headerlink" title="语法示例："></a>语法示例：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">safeFunctionWithUniqueLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">ul</span><span class="params">(mtx)</span></span>;  <span class="comment">// 自动加锁</span></span><br><span class="line">    <span class="comment">// 访问或修改共享资源</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Shared resource accessed with unique_lock\n&quot;</span>;</span><br><span class="line">    ul.<span class="built_in">unlock</span>();  <span class="comment">// 手动解锁</span></span><br><span class="line">    <span class="comment">// 你可以在这里做其他不需要锁的操作</span></span><br><span class="line">    ul.<span class="built_in">lock</span>();  <span class="comment">// 如果需要，可以重新加锁</span></span><br><span class="line">    <span class="comment">// 访问共享资源</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Shared resource accessed after relocking\n&quot;</span>;</span><br><span class="line">    <span class="comment">// 锁会在ul超出作用域时自动释放</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">safeFunctionWithUniqueLock</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中：</p><ul><li><code>std::unique_lock</code> 在创建时自动加锁互斥量 <code>mtx</code>。</li><li>使用 <code>ul.unlock()</code> 手动解锁，之后可以执行一些不需要锁的操作。</li><li><code>ul.lock()</code> 可以在之后重新加锁。</li><li>当 <code>unique_lock</code> 对象 <code>ul</code> 超出作用域时，<code>mtx</code> 会自动解锁。</li></ul><p><code>std::unique_lock</code> 提供了比 <code>std::lock_guard</code> 更高的灵活性，但也相对复杂一些。它适用于需要更细粒度控制的场景，如需要手动解锁和重新加锁的情况。</p><h3 id="4-std-lock-和-std-lock-guard-与-std-unique-lock-的区别"><a href="#4-std-lock-和-std-lock-guard-与-std-unique-lock-的区别" class="headerlink" title="4. std::lock 和 std::lock_guard 与 std::unique_lock 的区别"></a>4. <code>std::lock</code> 和 <code>std::lock_guard</code> 与 <code>std::unique_lock</code> 的区别</h3><ul><li>**<code>std::lock_guard</code>**：<ul><li>简单，适用于无需手动解锁的场景。</li><li>自动加锁并在作用域结束时自动解锁。</li><li>不能显式解锁或重新加锁。</li><li>不能转移所有权。</li></ul></li><li>**<code>std::unique_lock</code>**：<ul><li>更灵活，适用于需要手动解锁、重新加锁、或转移锁所有权的场景。</li><li>支持显式解锁（<code>unlock()</code>）和重新加锁（<code>lock()</code>）。</li><li>支持锁的延迟和转移。</li></ul></li><li>**<code>std::mutex</code> 和 <code>std::lock</code>**：<ul><li><code>std::mutex</code> 提供了基本的加锁和解锁机制。</li><li><code>std::lock</code> 是一个可以同时加锁多个互斥量的工具，可以防止死锁的发生。</li></ul></li></ul><h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. <strong>总结</strong></h3><ul><li><strong><code>std::lock_guard</code></strong> 和 <strong><code>std::unique_lock</code></strong> 都是用来管理互斥量锁的工具，分别适用于不同的场景。</li><li><strong><code>std::lock_guard</code></strong> 是简洁的自动锁管理工具，适合简单的加锁和解锁。</li><li><strong><code>std::unique_lock</code></strong> 提供了更灵活的锁管理方式，支持手动解锁、重新加锁等高级操作。</li><li>使用这些锁可以有效地避免死锁，减少编写线程安全代码时的复杂性。</li></ul><h2 id="5-STL（标准模板库）"><a href="#5-STL（标准模板库）" class="headerlink" title="5. STL（标准模板库）"></a><strong>5. STL（标准模板库）</strong></h2><p>STL 提供了常用的数据结构和算法。以下是重点内容。</p><hr><h3 id="5-1-常用容器"><a href="#5-1-常用容器" class="headerlink" title="5.1 常用容器"></a><strong>5.1 常用容器</strong></h3><h4 id="5-1-1-vector"><a href="#5-1-1-vector" class="headerlink" title="5.1.1 vector"></a><strong>5.1.1 <code>vector</code></strong></h4><p>动态数组，支持随机访问和自动扩容。</p><p><strong>示例：基本操作</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="number">4</span>); <span class="comment">// 添加元素</span></span><br><span class="line">    vec.<span class="built_in">pop_back</span>();   <span class="comment">// 删除最后一个元素</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : vec) &#123;</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 3</span><br></pre></td></tr></table></figure><hr><h4 id="5-1-2-queue"><a href="#5-1-2-queue" class="headerlink" title="5.1.2 queue"></a><strong>5.1.2 <code>queue</code></strong></h4><p>先进先出（FIFO）队列。</p><p><strong>示例：基本操作</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    queue&lt;int&gt; q;</span><br><span class="line">    q.push(1); q.push(2); q.push(3);</span><br><span class="line"></span><br><span class="line">    while (!q.empty()) &#123;</span><br><span class="line">        cout &lt;&lt; q.front() &lt;&lt; &quot; &quot;; // 获取队头元素</span><br><span class="line">        q.pop(); // 移除队头元素</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 3</span><br></pre></td></tr></table></figure><hr><h4 id="5-1-3-deque"><a href="#5-1-3-deque" class="headerlink" title="5.1.3 deque"></a><strong>5.1.3 <code>deque</code></strong></h4><p>双端队列，可以从两端插入或删除。</p><p><strong>示例：基本操作</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; dq = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    dq.<span class="built_in">push_front</span>(<span class="number">0</span>); <span class="comment">// 前端插入</span></span><br><span class="line">    dq.<span class="built_in">push_back</span>(<span class="number">4</span>);  <span class="comment">// 后端插入</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : dq) &#123;</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><h5 id="记录代码"><a href="#记录代码" class="headerlink" title="记录代码"></a>记录代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> <span class="comment">//input output 流，类似于stdio.h</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ventor 数组 的三种定义</span></span><br><span class="line">    vector &lt;<span class="type">int</span>&gt; v1; <span class="comment">//定义一个空数组</span></span><br><span class="line">    vector &lt;<span class="type">int</span>&gt; <span class="built_in">v2</span>(<span class="number">10</span>); <span class="comment">//定义一个10个元素的空数组</span></span><br><span class="line">    vector &lt;<span class="type">int</span>&gt; <span class="built_in">v3</span>(<span class="number">10</span>,<span class="number">2</span>); <span class="comment">//定义一个10个元素的空数组，并且每个变量都初始化为2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    v<span class="number">3.</span><span class="built_in">resize</span>(<span class="number">12</span>); <span class="comment">//resize 可以更改数组长度，增加数组长度的时候，不会修改原有值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ;i &lt;<span class="number">12</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;v3[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//可替换原生for循环的工具：迭代器 (适用于c++11)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> p =v<span class="number">3.</span><span class="built_in">begin</span>();p!=v<span class="number">3.</span><span class="built_in">end</span>();p++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;*p&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//使用迭代器的好处：无需考虑for循环的开头和结束</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//set: 集合，元素互异，自动从小到大排序</span></span><br><span class="line">    <span class="comment">//set在创建的时候，没有额外的参数</span></span><br><span class="line">    set &lt;<span class="type">int</span>&gt; my_set;</span><br><span class="line">    <span class="comment">//插入元素</span></span><br><span class="line">    my_set.<span class="built_in">insert</span>(<span class="number">8</span>);</span><br><span class="line">    my_set.<span class="built_in">insert</span>(<span class="number">2</span>);</span><br><span class="line">    my_set.<span class="built_in">insert</span>(<span class="number">5</span>);</span><br><span class="line">    my_set.<span class="built_in">insert</span>(<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//迭代器遍历</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> p = my_set.<span class="built_in">begin</span>();p!=my_set.<span class="built_in">end</span>();p++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;*p&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">auto</span> p = my_set.<span class="built_in">find</span>(<span class="number">8</span>); <span class="comment">// .find(data)函数返回的是一个指针</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;*p is &quot;</span>&lt;&lt;*p&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//set 清除某一个元素</span></span><br><span class="line">    my_set.<span class="built_in">erase</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> p = my_set.<span class="built_in">begin</span>();p!=my_set.<span class="built_in">end</span>();p++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;*p&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//map</span></span><br><span class="line">    map&lt;<span class="type">int</span>,string&gt; m;</span><br><span class="line">    m[<span class="number">2</span>] =<span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    m[<span class="number">1</span>] = <span class="string">&quot;wrold&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> p = m.<span class="built_in">begin</span>();p!=m.<span class="built_in">end</span>();p++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; (*p).first &lt;&lt;<span class="string">&quot;:&quot;</span>&lt;&lt;p-&gt;second&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    map&lt;string,<span class="type">int</span>&gt; m2;</span><br><span class="line">    m2[<span class="string">&quot;hello&quot;</span>] = <span class="number">9</span>;</span><br><span class="line">    m2[<span class="string">&quot;wrold&quot;</span>] = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> p = m.<span class="built_in">begin</span>();p!=m.<span class="built_in">end</span>();p++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; (*p).first &lt;&lt;<span class="string">&quot;:&quot;</span>&lt;&lt;p-&gt;second&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//stack</span></span><br><span class="line">    stack &lt;<span class="type">int</span>&gt; mystack;</span><br><span class="line">    mystack.<span class="built_in">push</span>(<span class="number">4</span>);</span><br><span class="line">    mystack.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line">    mystack.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    mystack.<span class="built_in">pop</span>();</span><br><span class="line">    cout&lt;&lt;mystack.<span class="built_in">top</span>()&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;mystack.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//queue</span></span><br><span class="line">    queue &lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">4</span>);</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">6</span>);</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">-1</span>);</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;q.<span class="built_in">front</span>()&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;q.<span class="built_in">back</span>()&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用哈希表实现的 unordered_map 顺序由哈希函数规定</span></span><br><span class="line">    <span class="comment">//unordered_map 默认使用 std::hash 作为哈希函数</span></span><br><span class="line">    unordered_map&lt;string,<span class="type">int</span>&gt; hashtable;</span><br><span class="line">    hashtable[<span class="string">&quot;apple&quot;</span>] = <span class="number">10</span>;</span><br><span class="line">    hashtable[<span class="string">&quot;banana&quot;</span>] = <span class="number">4</span>;</span><br><span class="line">    hashtable[<span class="string">&quot;pear&quot;</span>]  = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> p = hashtable.<span class="built_in">begin</span>();p!=hashtable.<span class="built_in">end</span>();p++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;p-&gt;first&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;p-&gt;second&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用哈希表实现的 unordered_set</span></span><br><span class="line">    unordered_set&lt;<span class="type">int</span>&gt; mySet;</span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    mySet.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">    mySet.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">    mySet.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">    mySet.<span class="built_in">insert</span>(<span class="number">10</span>); <span class="comment">// 重复元素不会插入</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查元素</span></span><br><span class="line">    <span class="keyword">if</span> (mySet.<span class="built_in">find</span>(<span class="number">20</span>) != mySet.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;20 is in the set.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历元素 元素顺序由内部哈希函数决定</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span>&amp; num : mySet) &#123;</span><br><span class="line">        cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="5-2-算法库"><a href="#5-2-算法库" class="headerlink" title="5.2 算法库"></a><strong>5.2 算法库</strong></h3><h4 id="5-2-1-std-sort"><a href="#5-2-1-std-sort" class="headerlink" title="5.2.1 std::sort"></a><strong>5.2.1 <code>std::sort</code></strong></h4><p>排序容器中的元素。</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>()); <span class="comment">// 升序排序</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : vec) &#123;</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 1 3 4 5</span><br></pre></td></tr></table></figure><hr><h3 id="5-3-C-11-新特性"><a href="#5-3-C-11-新特性" class="headerlink" title="5.3 C++11 新特性"></a><strong>5.3 C++11 新特性</strong></h3><h4 id="5-3-1-auto-关键字"><a href="#5-3-1-auto-关键字" class="headerlink" title="5.3.1 auto 关键字"></a><strong>5.3.1 <code>auto</code> 关键字</strong></h4><p>自动推断变量类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> x = <span class="number">10</span>;  <span class="comment">// 推断为 int</span></span><br><span class="line"><span class="keyword">auto</span> y = <span class="number">3.14</span>; <span class="comment">// 推断为 double</span></span><br></pre></td></tr></table></figure><h4 id="5-3-2-Lambda-表达式c"><a href="#5-3-2-Lambda-表达式c" class="headerlink" title="5.3.2 Lambda 表达式c"></a><strong>5.3.2 Lambda 表达式c</strong></h4><p>定义匿名函数的方式，适合轻量级操作。</p><p><strong>语法：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[捕获列表](参数列表) -&gt; 返回类型 &#123; 函数体 &#125;</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    for_each(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), [&amp;sum](<span class="type">int</span> x) &#123; sum += x; &#125;);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Sum: &quot;</span> &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sum: 15</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>串</title>
      <link href="/2024/11/25/%E4%B8%B2/"/>
      <url>/2024/11/25/%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="串的表示和实现"><a href="#串的表示和实现" class="headerlink" title="串的表示和实现"></a>串的表示和实现</h2><h3 id="定长顺序存储"><a href="#定长顺序存储" class="headerlink" title="定长顺序存储"></a>定长顺序存储</h3><p>直接定义数组 Sstring[MAXSTRLEN+1]</p><h3 id="堆分配存储"><a href="#堆分配存储" class="headerlink" title="堆分配存储"></a>堆分配存储</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">char</span> *ch;</span><br><span class="line"><span class="type">int</span> lenth;</span><br><span class="line">&#125;HString;</span><br></pre></td></tr></table></figure><h3 id="块链存储"><a href="#块链存储" class="headerlink" title="块链存储"></a>块链存储</h3><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog_imgimage-20241125090558654.png" alt="image-20241125090558654"></p><p>块链存储的实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CHUNKSIZE 80</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Chunk</span> //结点结构</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">char</span> ch[CHUNKSIZE];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Chunk</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;Chunk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Chunk *head,*tail;</span><br><span class="line">    <span class="type">int</span> curlen; </span><br><span class="line">&#125;LString;</span><br></pre></td></tr></table></figure><h2 id="匹配模式算法"><a href="#匹配模式算法" class="headerlink" title="匹配模式算法"></a>匹配模式算法</h2><h3 id="简单匹配模式算法"><a href="#简单匹配模式算法" class="headerlink" title="简单匹配模式算法"></a>简单匹配模式算法</h3><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog_imgimage-20241125091001386.png" alt="image-20241125091001386"></p><p>简单来说：</p><ul><li>第一步，从头开始比较两个字符串</li><li>如果短的那个字符串比较完了，并且没有出现不等的情况，说明已经匹配成功</li><li>如果说出现了S[i] !&#x3D; T[j]的情况，说明在这个位置，出现了匹配失败，于是进行下一步</li><li>字串T重新开始从第一个元素比较，主串S从上一次开始比较的元素的下一个位置开始比较</li><li>用程序表达就是，S从i-j+2重新开始比较，t从j &#x3D; 0重新开始比较</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSTRLEN 255</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> Sstring[MAXSTELEN+<span class="number">1</span>]</span><br><span class="line"><span class="type">int</span> <span class="title function_">index</span><span class="params">(Sstring S,Sstring T,<span class="type">int</span> pos)</span><span class="comment">//传入的pos代表想要从主串的第几个位置开始比较</span></span><br><span class="line">&#123;</span><br><span class="line">i = pos;</span><br><span class="line">    j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=S[<span class="number">0</span>] &amp;&amp; j&lt;=T[<span class="number">0</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==T[j])</span><br><span class="line">        &#123;</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//重新开始匹配</span></span><br><span class="line">        &#123;</span><br><span class="line">            i=i-j+<span class="number">2</span>;</span><br><span class="line">            j = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j&gt;T[<span class="number">0</span>])</span><br><span class="line">    &#123;<span class="keyword">return</span> i-T[<span class="number">0</span>];&#125; <span class="comment">//返回位置</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度</p><p>最好： 一次成功 -&gt; O(m+n)</p><p>最坏： 最后一次成功 -&gt; O(m*n)</p><h3 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h3><p><strong>核心思想：主串指针不回溯，模式串向后滑动至某个位置上</strong></p><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog_imgimage-20241125105804817.png" alt="image-20241125105804817"></p><ul><li>一个主串，且主串不回溯</li><li>一个字串，且字串的每个元素伴随着next数组的一个值</li><li>next数组的意义是，当匹配失败的时候，下一次匹配可以跳过的字符个数</li><li>next数组的求法，是当前元素及之前元素构成的字符串中，前后元素一致的元素个数</li><li>求next数组，使用递归的方法，比如说，现在有三个元素，其中第一个和最后一个元素一致，现在读取第四个元素，想要判断前两个和后两个元素是不是相等的，只需要在第一个元素和第三个元素相同的基础上再判断第二个元素和第四个元素相等与否，这个过程会产生两种结果：</li><li>结果一 ： 元素2 和元素4相等，那么第四个元素的next数组值就是2</li><li>结果二： 元素二和元素4不相等,那么开始寻找更短的</li><li>在之前，我们已经判断了一段前后缀是相等的，这里有一个隐藏条件，就是这一对前后缀自己的前后缀与对方的使完全相等的，因此我们只需要找出上一次的前缀自身的前后缀，他们就是<strong>可以准备用于添加新元素后进行判断是否为新前后缀</strong>的一对前后缀</li></ul><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog_imgimage-20241125115306013.png" alt="image-20241125115306013"></p><p>比如这个，aba 和 aba 是已有的前后缀，加上b以后，与前面的c不一致，产生冲突</p><ul><li>对aba找前后缀，根据next数组，可知长度为1，即只有a一个</li></ul><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog_imgimage-20241125115437507.png" alt="image-20241125115437507"></p><ul><li>下面再对两个a后面两个元素</li></ul><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><h5 id="计算next数组"><a href="#计算next数组" class="headerlink" title="计算next数组"></a>计算next数组</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">build_next</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, <span class="type">int</span> *next)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">strlen</span>(s); <span class="comment">// 字符串长度</span></span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">0</span>;       <span class="comment">// 初始化第一个位置为 0</span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;         <span class="comment">// j 指向前缀的末尾</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="comment">// 不匹配时回退</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; s[i] != s[j]) &#123;</span><br><span class="line">            j = next[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果匹配，前缀长度加 1</span></span><br><span class="line">        <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        next[i] = j; <span class="comment">// 记录当前位置的 next 值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/11/13/%E6%95%B0%E7%94%B5%E9%9B%B6%E5%9F%BA%E7%A1%80%E9%80%9F%E9%80%9A/"/>
      <url>/2024/11/13/%E6%95%B0%E7%94%B5%E9%9B%B6%E5%9F%BA%E7%A1%80%E9%80%9F%E9%80%9A/</url>
      
        <content type="html"><![CDATA[<h4 id="与非-与非式。"><a href="#与非-与非式。" class="headerlink" title="与非-与非式。"></a>与非-与非式。</h4><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog_imged670f44e36b6fb5c2d2c3acc0a8d31.png" alt="ed670f44e36b6fb5c2d2c3acc0a8d31"><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog_img5b4d8c8c55aa5cec97ba996689a9399.png" alt="5b4d8c8c55aa5cec97ba996689a9399"></p><p>方法技巧：用二次求反，引入反演律</p><h4 id="转为与或非："><a href="#转为与或非：" class="headerlink" title="转为与或非："></a>转为与或非：</h4><p>先求反函数，在整体取反</p><p>求反函数可以在卡诺图中圈0</p><h4 id="转为或非或非"><a href="#转为或非或非" class="headerlink" title="转为或非或非"></a>转为或非或非</h4><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog_imgimage-20241113171330964.png" alt="image-20241113171330964"></p><p>最大项之积 取反两次即可</p><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog_imgimage-20241113180818326.png" alt="image-20241113180818326"></p><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog_imgimage-20241113181223584.png" alt="image-20241113181223584"></p><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog_imgimage-20241113182327370.png" alt="image-20241113182327370"></p><p><strong>求最小项之和的对偶式，变成最大项之积，里面的项的下标为2的n次方减i减1</strong></p><h3 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h3><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog_imgimage-20241113192709243.png" alt="image-20241113192709243"></p><p>npn,指向基极，pnp，指出基极（类比mos管记忆，mos管中，p沟道型指出gate，n沟道型指出gate）</p><p>三极管工作状态:</p><p>基极和发射基之间形成输入回路，但电路中实际上使用的是ce（也就是集电极和发射基）之间的电流回路</p><p>这个图的信息：</p><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog_imgimage-20241113193307206.png" alt="image-20241113193307206"></p><ul><li>发射结，集电结 的正反偏指的是 b相对于c和e的电压 </li><li>当b电压大于c和e的时候，直接饱和，饱和的含义就是 ic 不会再增大，因为电压已经比b小了</li><li>当b的电压大于e，并且b的电压小于c的时候，没饱和，正在放大</li><li>当b的电压小于二者，直接截至</li></ul><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog_imgimage-20241113192322430.png" alt="image-20241113192322430"></p><p>nmos指向gate</p><p>pmos指出gate</p><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog_imgimage-20241113194438607.png" alt="image-20241113194438607"></p><p>G极(gate)—栅极，不用说比较好认<br>S极(source)—源极，不论是P沟道还是N沟道，两根线相交的就是<br>D极(drain)—漏极，不论是P沟道还是N沟道，是单独引线的那边</p><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog_imgimage-20241113194452674.png" alt="image-20241113194452674"></p><p> <strong>导通</strong>电流方向的判断：<strong>能与中间那个箭头形成闭环</strong></p><p>开关特性:</p><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog_imgimage-20241113200142586.png" alt="image-20241113200142586"></p><p>nmos gate<strong>高电平导通</strong></p><p>pmos  gate<strong>低电平导通</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>stm32学习笔记004</title>
      <link href="/2024/11/02/stm3204/"/>
      <url>/2024/11/02/stm3204/</url>
      
        <content type="html"><![CDATA[<h2 id="任务（1）：ADC-采样并通过串⼝发送⾄上位机"><a href="#任务（1）：ADC-采样并通过串⼝发送⾄上位机" class="headerlink" title="任务（1）：ADC 采样并通过串⼝发送⾄上位机"></a>任务（1）：ADC 采样并通过串⼝发送⾄上位机</h2><h3 id="ADC简介"><a href="#ADC简介" class="headerlink" title="ADC简介"></a>ADC简介</h3><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241102110242914.png" alt="image-20241102110242914"></p><h3 id="ADC原理（逐次比较型）"><a href="#ADC原理（逐次比较型）" class="headerlink" title="ADC原理（逐次比较型）"></a>ADC原理（逐次比较型）</h3><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241102110346796.png" alt="image-20241102110346796"></p><h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><ol><li><p><strong>初始化</strong>：</p><p>选择输入信号并设置参考电压。</p></li><li><p><strong>采样</strong>：</p><p>ADC 读取输入模拟信号，并在采样保持电路中保持该值。</p></li><li><p><strong>逐次比较</strong>：</p><p>ADC 开始进行逐次比较，将输入信号与内部的数字化值进行比较。这个过程通过一个逐次逼近寄存器实现。</p><p>设定一个初始的数字值（通常是中间值），然后将其转换为模拟信号（DAC 输出），并与输入信号进行比较。</p></li><li><p><strong>比较结果</strong>：</p><p>如果 DAC 输出的模拟信号大于输入信号，则该位为 0；如果小于，则该位为 1。根据比较结果，SAR 更新其当前的数字值。</p><p>逐位比较过程从最高位到最低位进行，逐次确定每一位的值。</p></li><li><p><strong>重复过程</strong>：</p><p>重复以上步骤，直到所有位都确定为止。一般来说，逐次比较型 ADC 的转换过程需要 N 次比较，其中 N 是 ADC 的分辨率（位数）。</p></li><li><p><strong>输出结果</strong>：</p><p>一旦所有位都确定，转换结果就存储在输出寄存器中，可以通过数字接口读取。</p></li></ol><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241102110819185.png" alt="image-20241102110819185"></p><h4 id="ADC基本结构"><a href="#ADC基本结构" class="headerlink" title="ADC基本结构"></a>ADC基本结构</h4><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241102111034836.png" alt="image-20241102111034836"></p><h3 id="ADC四种工作模式"><a href="#ADC四种工作模式" class="headerlink" title="ADC四种工作模式"></a>ADC四种工作模式</h3><ul><li>单次转换，扫描：配置多个通道，每次扫描可以扫描多通道，但每个大过程都要用函数触发</li><li>单次转换，非扫描：配置单个同通道，每次扫描都要用一个函数触发一次</li><li>连续转换，扫描：配置多个通道，进行连续扫描，只需触发一次</li><li>连续转换，非扫描：配置一个通道，只扫描他，只需触发一次</li></ul><h3 id="转换时间"><a href="#转换时间" class="headerlink" title="转换时间"></a>转换时间</h3><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241102111751744.png" alt="image-20241102111751744"></p><h3 id="程序设计"><a href="#程序设计" class="headerlink" title="程序设计"></a>程序设计</h3><h4 id="（技术点介绍）首先是配置adc及其中断："><a href="#（技术点介绍）首先是配置adc及其中断：" class="headerlink" title="（技术点介绍）首先是配置adc及其中断："></a>（技术点介绍）首先是配置adc及其中断：</h4><h5 id="时钟配置"><a href="#时钟配置" class="headerlink" title="时钟配置"></a>时钟配置</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC3, ENABLE);</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, ENABLE);</span><br></pre></td></tr></table></figure><p>这两行代码开启了 ADC3 和 GPIOC 的时钟。只有在时钟开启后，ADC 才能工作</p><h5 id="ADC-时钟分频"><a href="#ADC-时钟分频" class="headerlink" title="ADC 时钟分频"></a>ADC 时钟分频</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RCC_ADCCLKConfig(RCC_PCLK2_Div6);</span><br></pre></td></tr></table></figure><p>此行设置 ADC 的时钟分频，2和4不能选，只能从6开始选</p><h5 id="GPIO-配置"><a href="#GPIO-配置" class="headerlink" title="GPIO 配置"></a>GPIO 配置</h5><p>将 ADC 的输入引脚配置为模拟输入模式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6 | GPIO_Pin_7 | GPIO_Pin_8 | GPIO_Pin_9;</span><br><span class="line">GPIO_Init(GPIOC, &amp;GPIO_InitStructure);</span><br></pre></td></tr></table></figure><p>这里配置了 GPIOC 的 6 到 9 引脚为模拟输入，以便 ADC 可以读取这些引脚上的电压信号。</p><h5 id="ADC-配置"><a href="#ADC-配置" class="headerlink" title="ADC 配置"></a>ADC 配置</h5><p>使用 <code>ADC_InitTypeDef</code> 结构体配置 ADC 参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ADC_InitTypeDef ADC_InitStructure;</span><br><span class="line">ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;</span><br><span class="line">ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;</span><br><span class="line">ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;</span><br><span class="line">ADC_InitStructure.ADC_ContinuousConvMode = DISABLE;</span><br><span class="line">ADC_InitStructure.ADC_ScanConvMode = DISABLE;</span><br><span class="line">ADC_InitStructure.ADC_NbrOfChannel = 1;</span><br><span class="line">ADC_Init(ADC3, &amp;ADC_InitStructure);</span><br></pre></td></tr></table></figure><ul><li><strong>独立模式</strong>：表示此 ADC 不与其他 ADC 共享工作。</li><li><strong>数据对齐</strong>：选择数据右对齐，可以更容易地处理和解析结果。</li><li><strong>外部触发</strong>：这里设置为无外部触发，表示使用软件触发进行转换。</li><li><strong>连续转换</strong>：设置为禁用，这样 ADC 只在每次软件触发时进行一次转换。</li><li><strong>扫描模式</strong>：设置为禁用，表示只配置单个通道进行转换。</li></ul><h5 id="使能-ADC-和校准"><a href="#使能-ADC-和校准" class="headerlink" title="使能 ADC 和校准"></a>使能 ADC 和校准</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ADC_Cmd(ADC3, ENABLE);</span><br><span class="line">ADC_ResetCalibration(ADC3);</span><br><span class="line">while (ADC_GetResetCalibrationStatus(ADC3) == SET);</span><br><span class="line">ADC_StartCalibration(ADC3);</span><br><span class="line">while (ADC_GetCalibrationStatus(ADC3) == SET);</span><br></pre></td></tr></table></figure><p>这些代码段使能 ADC，并进行校准以确保测量的准确性。校准过程包括重置校准状态和开始校准。</p><h5 id="中断配置"><a href="#中断配置" class="headerlink" title="中断配置"></a>中断配置</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannel = ADC3_IRQn;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;</span><br><span class="line">NVIC_Init(&amp;NVIC_InitStructure);</span><br><span class="line">ADC_ITConfig(ADC3, ADC_IT_EOC, ENABLE);</span><br></pre></td></tr></table></figure><ul><li><strong>EOC 中断</strong>：使能 EOC 中断，这样 ADC 转换完成时会触发中断</li></ul><h5 id="数据读取和处理"><a href="#数据读取和处理" class="headerlink" title="数据读取和处理"></a>数据读取和处理</h5><h6 id="启动-ADC-转换"><a href="#启动-ADC-转换" class="headerlink" title="启动 ADC 转换"></a>启动 ADC 转换</h6><p>在 <code>AD_GetValue</code> 函数中，选择通道并启动转换：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ADC_RegularChannelConfig(ADC3, ADC_Channel_5, 1, ADC_SampleTime_55Cycles5);</span><br><span class="line">ADC_SoftwareStartConvCmd(ADC3, ENABLE);</span><br></pre></td></tr></table></figure><p>这段代码根据输入参数配置要读取的 ADC 通道，并通过软件触发开始转换。<code>ADC_SampleTime_55Cycles5</code> 表示采样时间为 55.5 个 ADC 时钟周期，这是一个影响转换速度和精度的参数。</p><h5 id="中断服务例程"><a href="#中断服务例程" class="headerlink" title="中断服务例程"></a>中断服务例程</h5><p>中断服务例程负责处理 ADC 转换完成的事件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void ADC3_IRQHandler(void)</span><br><span class="line">&#123;</span><br><span class="line">    if (ADC_GetITStatus(ADC3, ADC_IT_EOC) != RESET)</span><br><span class="line">    &#123;</span><br><span class="line">        adc_value = ADC_GetConversionValue(ADC3);</span><br><span class="line">        adc_ready = 1;</span><br><span class="line">        ADC_ClearITPendingBit(ADC3, ADC_IT_EOC);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>检查 EOC 标志</strong>：如果 EOC 中断被触发，则读取 ADC 转换结果，并将其存储在 <code>adc_value</code> 中</li><li><strong>清除中断标志</strong>：清除中断标志以便下次触发。</li></ul><h4 id="配置过程中，有几个点："><a href="#配置过程中，有几个点：" class="headerlink" title="配置过程中，有几个点："></a>配置过程中，有几个点：</h4><ul><li><p>因为是单次转换，非连续模式，所以想让它持续工作，每次调用函数时都要手动</p><p>ADC_SoftwareStartConvCmd(ADC3, ENABLE)一次</p></li><li><p>因为程序没有用到dma，所以只能使用单通道，否则数据村不过来，因此就用四个通道周期性扫描的方式来完成</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>        <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Timer.h&quot;</span></span></span><br><span class="line"><span class="type">uint32_t</span> mytime = <span class="number">0</span>;</span><br><span class="line"><span class="type">uint32_t</span> last_time = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> adc_value = <span class="number">0</span>; <span class="comment">// 用于保存 ADC 读取的值</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">AD_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC3, ENABLE); <span class="comment">// 开启 ADC3 的时钟</span></span><br><span class="line">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, ENABLE); <span class="comment">// 开启 GPIOC 的时钟</span></span><br><span class="line"></span><br><span class="line">    RCC_ADCCLKConfig(RCC_PCLK2_Div6); <span class="comment">// 选择时钟 6 分频，ADCCLK = 72MHz / 6 = 12MHz</span></span><br><span class="line"></span><br><span class="line">    GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;</span><br><span class="line">    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6 | GPIO_Pin_7 | GPIO_Pin_8 | GPIO_Pin_9;</span><br><span class="line">    GPIO_Init(GPIOC, &amp;GPIO_InitStructure); <span class="comment">// 模拟输入</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ADC 初始化</span></span><br><span class="line">    ADC_InitTypeDef ADC_InitStructure;</span><br><span class="line">    ADC_InitStructure.ADC_Mode = ADC_Mode_Independent; <span class="comment">// 模式，选择独立模式</span></span><br><span class="line">    ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right; <span class="comment">// 数据对齐，选择右对齐</span></span><br><span class="line">    ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None; <span class="comment">// 外部触发，使用软件触发</span></span><br><span class="line">    ADC_InitStructure.ADC_ContinuousConvMode = DISABLE; <span class="comment">// 连续转换，失能</span></span><br><span class="line">    ADC_InitStructure.ADC_ScanConvMode = DISABLE; <span class="comment">// 扫描模式，失能</span></span><br><span class="line">    ADC_InitStructure.ADC_NbrOfChannel = <span class="number">1</span>; <span class="comment">// 通道数为 1</span></span><br><span class="line">    ADC_Init(ADC3, &amp;ADC_InitStructure);</span><br><span class="line"></span><br><span class="line">    ADC_Cmd(ADC3, ENABLE); <span class="comment">// 使能 ADC3</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ADC 校准</span></span><br><span class="line">    ADC_ResetCalibration(ADC3); <span class="comment">// 固定流程</span></span><br><span class="line">    <span class="keyword">while</span> (ADC_GetResetCalibrationStatus(ADC3) == SET);</span><br><span class="line">    ADC_StartCalibration(ADC3);</span><br><span class="line">    <span class="keyword">while</span> (ADC_GetCalibrationStatus(ADC3) == SET);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置 ADC 中断</span></span><br><span class="line">    NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line">    NVIC_InitStructure.NVIC_IRQChannel = ADC3_IRQn;<span class="comment">// 确保是 ADC3 的中断</span></span><br><span class="line">    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">1</span>;</span><br><span class="line">    NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">1</span>;</span><br><span class="line">    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;</span><br><span class="line">    NVIC_Init(&amp;NVIC_InitStructure);</span><br><span class="line"></span><br><span class="line">    ADC_ITConfig(ADC3, ADC_IT_EOC, ENABLE); <span class="comment">// 使能 ADC 的 EOC 中断</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">AD_GetValue</span><span class="params">(<span class="type">int</span> recentchanel)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (recentchanel == <span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ADC_RegularChannelConfig(ADC3, ADC_Channel_4, <span class="number">1</span>, ADC_SampleTime_55Cycles5);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (recentchanel == <span class="number">5</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ADC_RegularChannelConfig(ADC3, ADC_Channel_5, <span class="number">1</span>, ADC_SampleTime_55Cycles5);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (recentchanel == <span class="number">6</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ADC_RegularChannelConfig(ADC3, ADC_Channel_6, <span class="number">1</span>, ADC_SampleTime_55Cycles5);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (recentchanel == <span class="number">7</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ADC_RegularChannelConfig(ADC3, ADC_Channel_7, <span class="number">1</span>, ADC_SampleTime_55Cycles5);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ADC_SoftwareStartConvCmd(ADC3, ENABLE); <span class="comment">// 软件触发 ADC 转换一次</span></span><br><span class="line">    <span class="keyword">return</span> adc_value; <span class="comment">// 返回最新的 ADC 值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC3_IRQHandler</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">// ADC3 中断处理函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (ADC_GetITStatus(ADC3, ADC_IT_EOC) != RESET) <span class="comment">// 检查是否是 EOC 中断</span></span><br><span class="line">    &#123;</span><br><span class="line">        adc_value = ADC_GetConversionValue(ADC3); <span class="comment">// 读取 ADC 值</span></span><br><span class="line">        ADC_ClearITPendingBit(ADC3, ADC_IT_EOC); <span class="comment">// 清除中断标志位</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">get_time_interval</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> current_time = mytime;</span><br><span class="line">    <span class="type">uint32_t</span> interval = current_time - last_time; <span class="comment">// 计算时间间隔</span></span><br><span class="line">    last_time = current_time; <span class="comment">// 更新上次时间</span></span><br><span class="line">    <span class="keyword">return</span> interval/<span class="number">100</span>;<span class="comment">//微秒化成毫秒 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="（技术点介绍，定时器中断）下面是timer-h"><a href="#（技术点介绍，定时器中断）下面是timer-h" class="headerlink" title="（技术点介绍，定时器中断）下面是timer.h"></a>（技术点介绍，定时器中断）下面是timer.h</h4><p>因为要获取时间间隔，所以配置tim定时器</p><p>思路如下:</p><ul><li>定义一个全局变量 mytime</li><li>定义一个变量 last_time</li><li>timer配置分频72-1，自动重装值1</li><li>配置中断，每次中断，mytime都加一，实现微秒级别的计数</li><li>当调用adc相关函数的时候，计算mytime与last_time的差值</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Timer_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2,ENABLE);<span class="comment">//使能时钟</span></span><br><span class="line"></span><br><span class="line">TIM_InternalClockConfig(TIM2);</span><br><span class="line"></span><br><span class="line">TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;</span><br><span class="line">TIM_TimeBaseInitStructure.TIM_ClockDivision=TIM_CKD_DIV1; <span class="comment">//ָ设置时钟分频（1分频）</span></span><br><span class="line">TIM_TimeBaseInitStructure.TIM_CounterMode=TIM_CounterMode_Up; <span class="comment">//向上计数</span></span><br><span class="line">TIM_TimeBaseInitStructure.TIM_Period=<span class="number">10</span><span class="number">-1</span>;<span class="comment">//周期是10微秒</span></span><br><span class="line">TIM_TimeBaseInitStructure.TIM_Prescaler=<span class="number">72</span><span class="number">-1</span>; <span class="comment">//72mzh / 7200 = 10k ,72mhz / 7200 = 10k</span></span><br><span class="line">TIM_TimeBaseInitStructure.TIM_RepetitionCounter=<span class="number">0</span>;<span class="comment">//重复计数（高级计时器有，现在不用）</span></span><br><span class="line">TIM_TimeBaseInit(TIM2,&amp;TIM_TimeBaseInitStructure);</span><br><span class="line"></span><br><span class="line">TIM_ClearFlag(TIM2,TIM_FLAG_Update); <span class="comment">//清除TIM2的更新中断标志位，确保定时器开始时没有残留的中断标志</span></span><br><span class="line"></span><br><span class="line">TIM_ITConfig(TIM2,TIM_IT_Update,ENABLE);<span class="comment">//开启更新中断到nvic通路</span></span><br><span class="line"></span><br><span class="line">NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);</span><br><span class="line"></span><br><span class="line">NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannel= TIM2_IRQn;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelCmd=ENABLE;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=<span class="number">2</span>;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelSubPriority=<span class="number">1</span>;</span><br><span class="line">NVIC_Init(&amp;NVIC_InitStructure);</span><br><span class="line">TIM_Cmd(TIM2,ENABLE);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="主函数："><a href="#主函数：" class="headerlink" title="主函数："></a>主函数：</h4><p>定义一个四个变量的数组，用于标志各个红外对管的状态，只有满足状态改变的判定条件时，再改变状态，防止串口那里一直乱跳</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>      <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;LED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;DELAY.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Serial.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Oled.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;LED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;string.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AD.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Timer.h&quot;</span></span></span><br><span class="line"><span class="type">uint8_t</span> RxData;</span><br><span class="line"><span class="type">int</span> ifblack[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">extern</span> <span class="type">uint32_t</span> mytime;</span><br><span class="line"><span class="type">void</span> <span class="title function_">BlkOrWte</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> recentchanel)</span>;</span><br><span class="line"><span class="type">int</span> recentchanel = <span class="number">4</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">OLED_Init();</span><br><span class="line">AD_Init();</span><br><span class="line">Serial_Init();</span><br><span class="line">Timer_Init();</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">OLED_ShowNum(<span class="number">1</span>,<span class="number">6</span>,mytime,<span class="number">9</span>);</span><br><span class="line"><span class="keyword">if</span>(recentchanel == <span class="number">4</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a = AD_GetValue(recentchanel);</span><br><span class="line">BlkOrWte(a,recentchanel);</span><br><span class="line">recentchanel = <span class="number">5</span>;</span><br><span class="line">OLED_ShowNum(<span class="number">1</span>,<span class="number">1</span>,a,<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(recentchanel == <span class="number">5</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a = AD_GetValue(recentchanel);</span><br><span class="line">BlkOrWte(a,recentchanel);</span><br><span class="line">recentchanel = <span class="number">6</span>;</span><br><span class="line">OLED_ShowNum(<span class="number">2</span>,<span class="number">1</span>,a,<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(recentchanel == <span class="number">6</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a = AD_GetValue(recentchanel);</span><br><span class="line">BlkOrWte(a,recentchanel);</span><br><span class="line">recentchanel = <span class="number">7</span>;</span><br><span class="line">OLED_ShowNum(<span class="number">3</span>,<span class="number">1</span>,a,<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(recentchanel == <span class="number">7</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a = AD_GetValue(recentchanel);</span><br><span class="line">BlkOrWte(a,recentchanel);</span><br><span class="line">recentchanel = <span class="number">4</span>;</span><br><span class="line">OLED_ShowNum(<span class="number">4</span>,<span class="number">1</span>,a,<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">BlkOrWte</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> recentchanel)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a&gt;<span class="number">2000</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(ifblack[recentchanel<span class="number">-4</span>]==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">Serial_SendNumber(recentchanel,<span class="number">1</span>);</span><br><span class="line">Serial_SendString(<span class="string">&quot;:black\r\n&quot;</span>);</span><br><span class="line">Serial_SendNumber(get_time_interval(),<span class="number">1</span>);</span><br><span class="line">Serial_SendString(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">ifblack[recentchanel<span class="number">-4</span>] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(a&lt;<span class="number">500</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(ifblack[recentchanel<span class="number">-4</span>] == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">Serial_SendNumber(recentchanel,<span class="number">1</span>);</span><br><span class="line">Serial_SendString(<span class="string">&quot;white\r\n&quot;</span>);</span><br><span class="line">Serial_SendNumber(get_time_interval(),<span class="number">1</span>);</span><br><span class="line">Serial_SendString(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">ifblack[recentchanel<span class="number">-4</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM2_IRQHandler</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//更新中断函数</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (TIM_GetITStatus(TIM2, TIM_IT_Update) == SET)<span class="comment">//获取TIM3定时器的更新中断标志位</span></span><br><span class="line">&#123;</span><br><span class="line">mytime++;</span><br><span class="line">TIM_ClearITPendingBit(TIM2, TIM_IT_Update);<span class="comment">//清除更新中断标志位</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="视频现象："><a href="#视频现象：" class="headerlink" title="视频现象："></a>视频现象：</h3><h2 id="任务2-——DMA转运数据"><a href="#任务2-——DMA转运数据" class="headerlink" title="任务2 ——DMA转运数据"></a>任务2 ——DMA转运数据</h2><h3 id="dma简介"><a href="#dma简介" class="headerlink" title="dma简介"></a>dma简介</h3><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241102130840765.png" alt="image-20241102130840765"></p><h3 id="技术点介绍"><a href="#技术点介绍" class="headerlink" title="技术点介绍"></a>技术点介绍</h3><h4 id="DMA-配置和使⽤"><a href="#DMA-配置和使⽤" class="headerlink" title="DMA 配置和使⽤"></a>DMA 配置和使⽤</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DMA初始化</span></span><br><span class="line">DMA_InitTypeDef DMA_InitStructure;<span class="comment">//定义结构体变量</span></span><br><span class="line">DMA_InitStructure.DMA_PeripheralBaseAddr = (<span class="type">uint32_t</span>)&amp;ADC3-&gt;DR;<span class="comment">//外设基地址</span></span><br><span class="line">DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;<span class="comment">//外设数据宽度，半字，对应16为的ADC数据寄存器</span></span><br><span class="line">DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;<span class="comment">//外设地址自增，选择失能，始终以ADC数据寄存器为源</span></span><br><span class="line">DMA_InitStructure.DMA_MemoryBaseAddr = (<span class="type">uint32_t</span>)AD_Value;<span class="comment">//存储器基地址，AD_Value</span></span><br><span class="line">DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;<span class="comment">//存储器数据宽度，半字，与源数据宽度对应</span></span><br><span class="line">DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;<span class="comment">//存储器地址自增使能，每次转运后，数组位置下移</span></span><br><span class="line">DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;<span class="comment">//传输方向，选择由外设到存储器，ADC数据寄存器转到数组</span></span><br><span class="line">DMA_InitStructure.DMA_BufferSize = <span class="number">4</span>;<span class="comment">//转运次数，与ADC通道数一致</span></span><br><span class="line">DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;<span class="comment">//循环模式，与ADC的连续转换一致</span></span><br><span class="line">DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;<span class="comment">//存储器到存储器失能</span></span><br><span class="line">DMA_InitStructure.DMA_Priority = DMA_Priority_Medium;<span class="comment">//优先级，中等</span></span><br><span class="line">DMA_Init(DMA2_Channel5, &amp;DMA_InitStructure);<span class="comment">//将结构体变量交给DMA_Init，配置DMA2的通道5</span></span><br></pre></td></tr></table></figure><h5 id="DMA-InitTypeDef-结构体成员"><a href="#DMA-InitTypeDef-结构体成员" class="headerlink" title="DMA_InitTypeDef 结构体成员"></a>DMA_InitTypeDef 结构体成员</h5><ol><li><p><strong>DMA_PeripheralBaseAddr</strong>：</p><p>设置外设的基地址，DMA 传输时的源地址。</p><p>通常是外设寄存器的地址，比如 ADC 的数据寄存器 &amp;ADC3-&gt;DR</p></li><li><p><strong>DMA_PeripheralDataSize</strong>：</p><p>设置外设数据的宽度。</p><p>DMA_PeripheralDataSize_Byte：8位数据宽度</p><p>DMA_PeripheralDataSize_HalfWord：16位数据宽度（通常用于 ADC）</p><p>DMA_PeripheralDataSize_Word：32位数据宽度</p></li><li><p><strong>DMA_PeripheralInc</strong>：</p><p>设置外设地址自增。</p><p>DMA_PeripheralInc_Disable：外设地址不自增（常用于 ADC）。</p><p>DMA_PeripheralInc_Enable：外设地址自增</p></li><li><p><strong>DMA_MemoryBaseAddr</strong>：</p><p>设置存储器的基地址，DMA 将数据写入的目的地</p><p>通常是指向一个数组或内存区域的指针，例如 AD_Value</p></li><li><p><strong>DMA_MemoryDataSize</strong>：</p><p>设置存储器数据的宽度。</p><p>DMA_Memorialized_Byte：8位数据宽度。</p><p>DMA_Memorialized_HalfWord：16位数据宽度。</p><p>DMA_Memorialized_Word：32位数据宽度。</p></li><li><p><strong>DMA_MemoryInc</strong>：</p><p>设置存储器地址自增。</p><p>DMA_MemoryInc_Disable：存储器地址不自增（所有数据写入同一位置）。</p><p>DMA_MemoryInc_Enable：存储器地址自增（每次传输后，指向下一个存储单元）。</p></li><li><p><strong>DMA_DIR</strong>：</p><p>设置数据传输的方向。</p><p>DMA_DIR_PeripheralSRC：从外设到存储器（如 ADC 到内存）。</p><p>DMA_DIR_MemorySRC：从存储器到外设（如内存到 DAC）。</p></li><li><p><strong>DMA_BufferSize</strong>：</p><p>设置传输的数据大小（传输次数）。</p><p>指定传输的样本数量。例如，若你要从 ADC 获取 4 个样本，则设置为 4。</p></li><li><p><strong>DMA_Mode</strong>：</p><p>设置 DMA 的工作模式。</p><p>DMA_Mode_Normal：正常模式，传输一次后停止。</p><p>DMA_Mode_Circular：循环模式，完成一次传输后自动重新开始，适合连续数据采集。</p></li><li><p><strong>DMA_M2M</strong>：</p><p>设置存储器到存储器传输的使能。</p><p>DMA_M2M_Disable：禁用存储器到存储器的传输（通常用于外设到存储器传输）。</p><p>DMA_M2M_Enable：启用存储器到存储器的传输（适用于特定应用）。</p></li><li><p><strong>DMA_Priority</strong>：</p><p>设置 DMA 传输的优先级。</p><p>DMA_Priority_Low：低优先级。</p><p>DMA_Priority_Medium：中优先级。</p><p>DMA_Priority_High：高优先级。</p><p>DMA_Priority_VeryHigh：最高优先级。</p></li></ol><h4 id="ADC-触发-DMA"><a href="#ADC-触发-DMA" class="headerlink" title="ADC 触发 DMA"></a>ADC 触发 DMA</h4><ol><li><p><strong>DMA 配置</strong>：</p><p>在 ADC 初始化中，可以配置 DMA 使能。当 ADC 完成一次转换时，它会自动向 DMA 发送一个信号，指示数据已经准备好进行传输</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADC_DMACmd(ADC3, ENABLE);</span><br></pre></td></tr></table></figure></li><li><p><strong>数据传输</strong>：</p><p>一旦 DMA 接收到来自 ADC 的触发信号，它会从 ADC 的数据寄存器中读取转换结果，并将其存储到指定的内存地址（例如某个数组中）</p></li></ol><h3 id="定时器配置"><a href="#定时器配置" class="headerlink" title="定时器配置"></a>定时器配置</h3><p>10微秒为周期，以便记录微妙级别的DMA过程（也不是很精准，DMA转运太快了）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Timer_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2,ENABLE);<span class="comment">//使能时钟</span></span><br><span class="line"></span><br><span class="line">TIM_InternalClockConfig(TIM2);</span><br><span class="line"></span><br><span class="line">TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;</span><br><span class="line">TIM_TimeBaseInitStructure.TIM_ClockDivision=TIM_CKD_DIV1; <span class="comment">//ָ设置时钟分频（1分频）</span></span><br><span class="line">TIM_TimeBaseInitStructure.TIM_CounterMode=TIM_CounterMode_Up; <span class="comment">//向上计数</span></span><br><span class="line">TIM_TimeBaseInitStructure.TIM_Period=<span class="number">10</span><span class="number">-1</span>;<span class="comment">//周期是10微秒</span></span><br><span class="line">TIM_TimeBaseInitStructure.TIM_Prescaler=<span class="number">72</span><span class="number">-1</span>; <span class="comment">//72mzh / 7200 = 10k ,72mhz / 7200 = 10k</span></span><br><span class="line">TIM_TimeBaseInitStructure.TIM_RepetitionCounter=<span class="number">0</span>;<span class="comment">//重复计数（高级计时器有，现在不用）</span></span><br><span class="line">TIM_TimeBaseInit(TIM2,&amp;TIM_TimeBaseInitStructure);</span><br><span class="line"></span><br><span class="line">TIM_ClearFlag(TIM2,TIM_FLAG_Update); <span class="comment">//清除TIM2的更新中断标志位，确保定时器开始时没有残留的中断标志</span></span><br><span class="line"></span><br><span class="line">TIM_ITConfig(TIM2,TIM_IT_Update,ENABLE);<span class="comment">//开启更新中断到nvic通路</span></span><br><span class="line"></span><br><span class="line">NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);</span><br><span class="line"></span><br><span class="line">NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannel= TIM2_IRQn;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelCmd=ENABLE;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=<span class="number">2</span>;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelSubPriority=<span class="number">1</span>;</span><br><span class="line">NVIC_Init(&amp;NVIC_InitStructure);</span><br><span class="line">TIM_Cmd(TIM2,ENABLE);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="主函数源码"><a href="#主函数源码" class="headerlink" title="主函数源码"></a>主函数源码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>      <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;LED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;DELAY.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Serial.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Oled.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;LED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;string.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AD.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Timer.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> delta_time = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> ifblack[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">extern</span> <span class="type">uint32_t</span> mytime;</span><br><span class="line"><span class="type">int</span> dma_transfer_count =<span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">BlkOrWte</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> recentchanel)</span>;</span><br><span class="line"><span class="type">int</span> recentchanel = <span class="number">4</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">OLED_Init();</span><br><span class="line">AD_Init();</span><br><span class="line">Serial_Init();</span><br><span class="line">Timer_Init();</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">OLED_ShowNum(<span class="number">1</span>,<span class="number">1</span>,mytime,<span class="number">10</span>);</span><br><span class="line">Serial_SendNumber(AD_Value[<span class="number">0</span>],<span class="number">4</span>);</span><br><span class="line">Serial_SendString(<span class="string">&quot;  &quot;</span>);</span><br><span class="line">Serial_SendNumber(AD_Value[<span class="number">1</span>],<span class="number">4</span>);</span><br><span class="line">Serial_SendString(<span class="string">&quot;  &quot;</span>);</span><br><span class="line">Serial_SendNumber(AD_Value[<span class="number">2</span>],<span class="number">4</span>);</span><br><span class="line">Serial_SendString(<span class="string">&quot;  &quot;</span>);</span><br><span class="line">Serial_SendNumber(AD_Value[<span class="number">3</span>],<span class="number">4</span>);</span><br><span class="line">Serial_SendString(<span class="string">&quot;  delta_time:&quot;</span>);</span><br><span class="line">Serial_SendNumber(delta_time,<span class="number">5</span>);</span><br><span class="line">Serial_SendString(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM2_IRQHandler</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//更新中断函数</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (TIM_GetITStatus(TIM2, TIM_IT_Update) == SET)<span class="comment">//获取TIM3定时器的更新中断标志位</span></span><br><span class="line">&#123;</span><br><span class="line">mytime++;</span><br><span class="line">TIM_ClearITPendingBit(TIM2, TIM_IT_Update);<span class="comment">//清除更新中断标志位</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DMA2_Channel4_5_IRQHandler</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//配置一下dma2的中断函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (DMA_GetITStatus(DMA2_IT_TC5)) &#123;</span><br><span class="line">        dma_transfer_count++; <span class="comment">// 增加转运计数</span></span><br><span class="line">        <span class="keyword">if</span> (dma_transfer_count &gt;= <span class="number">1</span>) &#123; <span class="comment">// 每次转运计算时间间隔</span></span><br><span class="line">            delta_time = get_time_interval(); <span class="comment">// 计算时间间隔</span></span><br><span class="line">            dma_transfer_count = <span class="number">0</span>; <span class="comment">// 重置计数器</span></span><br><span class="line">        &#125;</span><br><span class="line">        DMA_ClearITPendingBit(DMA2_IT_TC5); <span class="comment">// 清除中断标志</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="视频现象：-1"><a href="#视频现象：-1" class="headerlink" title="视频现象："></a>视频现象：</h3><h2 id="vofa"><a href="#vofa" class="headerlink" title="vofa"></a>vofa</h2><h3 id="JustFloat-协议的结构"><a href="#JustFloat-协议的结构" class="headerlink" title="JustFloat 协议的结构"></a>JustFloat 协议的结构</h3><ol><li>数据帧：<br> 每个数据帧包含一个浮点数组，数组中的每个元素代表一个通道的数据。例如，有四个通道的数据要传输，数据帧中就要包含四个浮点数</li><li>小端格式：<br>JustFloat 协议使用小端格式存储浮点数，最低有效字节存储在最低的内存地址中</li><li>帧尾：<br>每个数据帧的末尾都有一个固定的帧尾标志，用于标识数据帧的结束： {0x00, 0x00, 0x80, 0x7f}</li></ol><h3 id="数据传输过程"><a href="#数据传输过程" class="headerlink" title="数据传输过程"></a>数据传输过程</h3><ol><li><p>数据准备：</p><p>需要传输的数据首先被转换成浮点数，并按照小端格式存储在数组中。</p></li><li><p>数据发送：<br> 将浮点数组和帧尾标志一起发送到接收端。接收端通过识别帧尾标志来确定数据帧的结束，并解析浮点数组中的数据。</p></li><li><p>数据解析：</p><p>接收端接收到数据帧后，解析浮点数组中的数据，并根据需要进行处理或显示。</p></li></ol><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>适合多通道数据采集，例如正在做的循迹小车有多个红外对管，每个红外对管代表一个通道的数据。</p><h3 id="图形控件的使用"><a href="#图形控件的使用" class="headerlink" title="图形控件的使用"></a>图形控件的使用</h3><p>以最常用的示波器为例</p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241103190053878.png" alt="image-20241103190053878" style="zoom: 33%;" /><p>在左侧选择控件示波器并把它拖进去</p><ul><li>右键可以选择填充方式</li><li>下面三个圈可以调整波形范围，包含点数等</li><li>auto可以让波形以最佳方式自动呈现</li></ul><h3 id="具体使用方法"><a href="#具体使用方法" class="headerlink" title="具体使用方法"></a>具体使用方法</h3><h4 id="配置一下这个能用这个协议的函数"><a href="#配置一下这个能用这个协议的函数" class="headerlink" title="配置一下这个能用这个协议的函数"></a>配置一下这个能用这个协议的函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;string.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;serial.h&quot;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Vofa_JustFloat</span><span class="params">(<span class="type">float</span> *data, <span class="type">uint8_t</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> tempData[<span class="number">100</span>];</span><br><span class="line">    <span class="type">uint8_t</span> temp_end[<span class="number">4</span>] = &#123;<span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x80</span>, <span class="number">0x7f</span>&#125;;</span><br><span class="line">    <span class="type">float</span> temp_copy[num];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;temp_copy, data, <span class="keyword">sizeof</span>(<span class="type">float</span>) * num);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(tempData, (<span class="type">uint8_t</span> *)&amp;temp_copy, <span class="keyword">sizeof</span>(temp_copy));</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;tempData[num * <span class="number">4</span>], &amp;temp_end[<span class="number">0</span>], <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//串口发送函数</span></span><br><span class="line">    Serial_SendArray(tempData,(num + <span class="number">1</span>) * <span class="number">4</span>);</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>这个函数中，前几行都是在进行数据处理，处理完成后得到tempdata，是一个uint8_t类型的数组</li><li>得到数组之后，用江科大的串口发送函数直接发到送即可</li><li>使用方法：输入（浮点数数组，数组长度）</li></ul><h3 id="配置ADC-DMA"><a href="#配置ADC-DMA" class="headerlink" title="配置ADC&amp;&amp;DMA"></a>配置ADC&amp;&amp;DMA</h3><p>依然采用上面的配置，并将ADC数据接入拓展到12？个（咱只发了10个红外对管）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>        <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Timer.h&quot;</span></span></span><br><span class="line"><span class="type">uint32_t</span> mytime = <span class="number">0</span>;</span><br><span class="line"><span class="type">uint32_t</span> last_time = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> AD_Value_for_DMA2[<span class="number">5</span>];</span><br><span class="line"><span class="type">uint16_t</span> AD_Value_for_DMA1[<span class="number">5</span>];<span class="comment">//用于存放AD转换结果的全局数组</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">AD_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC3, ENABLE);<span class="comment">//开启ADC3的时钟</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOF, ENABLE);<span class="comment">//开启GPIOF的时钟</span></span><br><span class="line">RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA2, ENABLE);<span class="comment">//开启DMA2的时钟</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RCC_ADCCLKConfig(RCC_PCLK2_Div6);<span class="comment">//选择时钟6分频，ADCCLK = 72MHz / 6 = 12MHz</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6 | GPIO_Pin_7 | GPIO_Pin_8 | GPIO_Pin_9 |GPIO_Pin_10;</span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOF, &amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line"><span class="comment">//剩下的</span></span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_2 | GPIO_Pin_3 | GPIO_Pin_4 |GPIO_Pin_5;</span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOC, &amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ADC_RegularChannelConfig(ADC3, ADC_Channel_4, <span class="number">1</span>, ADC_SampleTime_55Cycles5);</span><br><span class="line">ADC_RegularChannelConfig(ADC3, ADC_Channel_5, <span class="number">2</span>, ADC_SampleTime_55Cycles5);</span><br><span class="line">ADC_RegularChannelConfig(ADC3, ADC_Channel_6, <span class="number">3</span>, ADC_SampleTime_55Cycles5);</span><br><span class="line">ADC_RegularChannelConfig(ADC3, ADC_Channel_7, <span class="number">4</span>, ADC_SampleTime_55Cycles5);</span><br><span class="line">ADC_RegularChannelConfig(ADC3, ADC_Channel_8, <span class="number">5</span>, ADC_SampleTime_55Cycles5);</span><br><span class="line"></span><br><span class="line">ADC_RegularChannelConfig(ADC1, ADC_Channel_11, <span class="number">6</span>, ADC_SampleTime_55Cycles5);</span><br><span class="line">ADC_RegularChannelConfig(ADC1, ADC_Channel_12, <span class="number">7</span>, ADC_SampleTime_55Cycles5);</span><br><span class="line">ADC_RegularChannelConfig(ADC1, ADC_Channel_13, <span class="number">8</span>, ADC_SampleTime_55Cycles5);</span><br><span class="line">ADC_RegularChannelConfig(ADC1, ADC_Channel_14, <span class="number">9</span>, ADC_SampleTime_55Cycles5);</span><br><span class="line">ADC_RegularChannelConfig(ADC1, ADC_Channel_15, <span class="number">10</span>, ADC_SampleTime_55Cycles5);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ADC_InitTypeDef ADC_InitStructure;</span><br><span class="line">ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;</span><br><span class="line">ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;<span class="comment">//这里好像还要改一个独立模式？</span></span><br><span class="line">ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;</span><br><span class="line">ADC_InitStructure.ADC_ContinuousConvMode = ENABLE;</span><br><span class="line">ADC_InitStructure.ADC_ScanConvMode = ENABLE;</span><br><span class="line">ADC_InitStructure.ADC_NbrOfChannel = <span class="number">10</span>;</span><br><span class="line">ADC_Init(ADC3, &amp;ADC_InitStructure);</span><br><span class="line"></span><br><span class="line"><span class="comment">//DMA初始化</span></span><br><span class="line">DMA_InitTypeDef DMA_InitStructure;<span class="comment">//定义结构体变量</span></span><br><span class="line">DMA_InitStructure.DMA_PeripheralBaseAddr = (<span class="type">uint32_t</span>)&amp;ADC3-&gt;DR;<span class="comment">//外设基地址</span></span><br><span class="line">DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;<span class="comment">//外设数据宽度，半字，对应16为的ADC数据寄存器</span></span><br><span class="line">DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;<span class="comment">//外设地址自增，选择失能，始终以ADC数据寄存器为源</span></span><br><span class="line">DMA_InitStructure.DMA_MemoryBaseAddr = (<span class="type">uint32_t</span>)AD_Value_for_DMA2;<span class="comment">//存储器基地址</span></span><br><span class="line">DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;<span class="comment">//存储器数据宽度，半字，与源数据宽度对应</span></span><br><span class="line">DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;<span class="comment">//存储器地址自增使能，每次转运后，数组位置下移</span></span><br><span class="line">DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;<span class="comment">//传输方向，选择由外设到存储器，ADC数据寄存器转到数组</span></span><br><span class="line">DMA_InitStructure.DMA_BufferSize =<span class="number">5</span>;<span class="comment">//转运次数</span></span><br><span class="line">DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;<span class="comment">//循环模式，与ADC的连续转换一致</span></span><br><span class="line">DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;<span class="comment">//存储器到存储器失能</span></span><br><span class="line">DMA_InitStructure.DMA_Priority = DMA_Priority_Medium;<span class="comment">//优先级，中等</span></span><br><span class="line">DMA_Init(DMA2_Channel5, &amp;DMA_InitStructure);<span class="comment">//将结构体变量交给DMA_Init，配置DMA2的通道5</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DMA_InitStructure.DMA_PeripheralBaseAddr = (<span class="type">uint32_t</span>)&amp;ADC1-&gt;DR;<span class="comment">//外设基地址</span></span><br><span class="line">DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;<span class="comment">//外设数据宽度，半字，对应16为的ADC数据寄存器</span></span><br><span class="line">DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;<span class="comment">//外设地址自增，选择失能，始终以ADC数据寄存器为源</span></span><br><span class="line">DMA_InitStructure.DMA_MemoryBaseAddr = (<span class="type">uint32_t</span>)AD_Value_for_DMA1;<span class="comment">//存储器基地址</span></span><br><span class="line">DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;<span class="comment">//存储器数据宽度，半字，与源数据宽度对应</span></span><br><span class="line">DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;<span class="comment">//存储器地址自增使能，每次转运后，数组位置下移</span></span><br><span class="line">DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;<span class="comment">//传输方向，选择由外设到存储器，ADC数据寄存器转到数组</span></span><br><span class="line">DMA_InitStructure.DMA_BufferSize =<span class="number">5</span>;<span class="comment">//转运次数</span></span><br><span class="line">DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;<span class="comment">//循环模式，与ADC的连续转换一致</span></span><br><span class="line">DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;<span class="comment">//存储器到存储器失能</span></span><br><span class="line">DMA_InitStructure.DMA_Priority = DMA_Priority_Medium;<span class="comment">//优先级，中等</span></span><br><span class="line">DMA_Init(DMA1_Channel1, &amp;DMA_InitStructure);<span class="comment">//将结构体变量交给DMA_Init，配置DMA1的通道1</span></span><br><span class="line"></span><br><span class="line">DMA_Cmd(DMA1_Channel1, ENABLE);</span><br><span class="line">DMA_Cmd(DMA2_Channel5, ENABLE);</span><br><span class="line">ADC_DMACmd(ADC3, ENABLE);<span class="comment">//ADC3触发DMA2的信号使能</span></span><br><span class="line">ADC_DMACmd(ADC1, ENABLE);</span><br><span class="line">ADC_Cmd(ADC1, ENABLE);</span><br><span class="line">ADC_Cmd(ADC3, ENABLE);</span><br><span class="line"></span><br><span class="line">DMA_ITConfig(DMA2_Channel5, DMA_IT_TC, ENABLE);  <span class="comment">// 启用传输完成中断</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置 DMA 中断</span></span><br><span class="line">NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line">    NVIC_InitStructure.NVIC_IRQChannel = DMA2_Channel4_5_IRQn; <span class="comment">//45共享中断</span></span><br><span class="line">    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">1</span>; <span class="comment">// 先占优先级</span></span><br><span class="line">    NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">1</span>; <span class="comment">// 从优先级</span></span><br><span class="line">    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; <span class="comment">// 使能中断</span></span><br><span class="line">    NVIC_Init(&amp;NVIC_InitStructure);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DMA_ITConfig(DMA1_Channel1, DMA_IT_TC, ENABLE);  <span class="comment">// 启用传输完成中断</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置 DMA 中断</span></span><br><span class="line"></span><br><span class="line">    NVIC_InitStructure.NVIC_IRQChannel = DMA1_Channel1_IRQn; </span><br><span class="line">    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">1</span>; <span class="comment">// 先占优先级</span></span><br><span class="line">    NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">1</span>; <span class="comment">// 从优先级</span></span><br><span class="line">    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; <span class="comment">// 使能中断</span></span><br><span class="line">    NVIC_Init(&amp;NVIC_InitStructure);</span><br><span class="line"></span><br><span class="line"><span class="comment">//ADC校准</span></span><br><span class="line">ADC_ResetCalibration(ADC3);<span class="comment">//固定流程，内部有电路会自动执行校准</span></span><br><span class="line"><span class="keyword">while</span> (ADC_GetResetCalibrationStatus(ADC3) == SET);</span><br><span class="line">ADC_StartCalibration(ADC3);</span><br><span class="line"><span class="keyword">while</span> (ADC_GetCalibrationStatus(ADC3) == SET);</span><br><span class="line"></span><br><span class="line">ADC_ResetCalibration(ADC1);<span class="comment">//固定流程，内部有电路会自动执行校准</span></span><br><span class="line"><span class="keyword">while</span> (ADC_GetResetCalibrationStatus(ADC3) == SET);</span><br><span class="line">ADC_StartCalibration(ADC1);</span><br><span class="line"><span class="keyword">while</span> (ADC_GetCalibrationStatus(ADC3) == SET);</span><br><span class="line"></span><br><span class="line"><span class="comment">//ADC触发</span></span><br><span class="line">ADC_SoftwareStartConvCmd(ADC3, ENABLE);</span><br><span class="line">ADC_SoftwareStartConvCmd(ADC1, ENABLE);<span class="comment">//软件触发ADC开始工作，由于ADC处于连续转换模式，故触发一次后ADC就可以一直连续不断地工作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="main函数调用"><a href="#main函数调用" class="headerlink" title="main函数调用"></a>main函数调用</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>      <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;LED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;DELAY.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Serial.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Oled.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;LED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;string.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AD.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Timer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;vofa.h&quot;</span></span></span><br><span class="line"><span class="type">float</span> mydata[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">Serial_Init();</span><br><span class="line">OLED_Init();</span><br><span class="line">AD_Init();</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以dma2为主，dma2触发以后，顺便把dma1和dam2的一块发出去，当然dma1的自己也存一遍</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DMA2_Channel4_5_IRQHandler</span><span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (DMA_GetITStatus(DMA2_IT_TC5)) &#123;</span><br><span class="line">        mydata[<span class="number">0</span>] = AD_Value_for_DMA2[<span class="number">0</span>];</span><br><span class="line">mydata[<span class="number">1</span>] = AD_Value_for_DMA2[<span class="number">1</span>];</span><br><span class="line">mydata[<span class="number">2</span>] = AD_Value_for_DMA2[<span class="number">2</span>];</span><br><span class="line">mydata[<span class="number">3</span>] = AD_Value_for_DMA2[<span class="number">3</span>];</span><br><span class="line">         mydata[<span class="number">4</span>] = AD_Value_for_DMA2[<span class="number">4</span>];</span><br><span class="line">mydata[<span class="number">5</span>] = AD_Value_for_DMA1[<span class="number">0</span>];</span><br><span class="line">mydata[<span class="number">6</span>] = AD_Value_for_DMA1[<span class="number">1</span>];</span><br><span class="line">mydata[<span class="number">7</span>] = AD_Value_for_DMA1[<span class="number">2</span>];        </span><br><span class="line">mydata[<span class="number">8</span>] = AD_Value_for_DMA1[<span class="number">3</span>];</span><br><span class="line">mydata[<span class="number">9</span>] = AD_Value_for_DMA1[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">Vofa_JustFloat(mydata,<span class="number">10</span>);</span><br><span class="line">        DMA_ClearITPendingBit(DMA2_IT_TC5); <span class="comment">// 清除中断标志</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">DMA1_Channel1_IRQHandler</span><span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (DMA_GetITStatus(DMA1_IT_TC1)) &#123;</span><br><span class="line">mydata[<span class="number">5</span>] = AD_Value_for_DMA1[<span class="number">0</span>];</span><br><span class="line">mydata[<span class="number">6</span>] = AD_Value_for_DMA1[<span class="number">1</span>];</span><br><span class="line">mydata[<span class="number">7</span>] = AD_Value_for_DMA1[<span class="number">2</span>];        </span><br><span class="line">mydata[<span class="number">8</span>] = AD_Value_for_DMA1[<span class="number">3</span>];</span><br><span class="line">mydata[<span class="number">9</span>] = AD_Value_for_DMA1[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">        DMA_ClearITPendingBit(DMA1_IT_TC1); <span class="comment">// 清除中断标志</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="视频现象：-2"><a href="#视频现象：-2" class="headerlink" title="视频现象："></a>视频现象：</h3><h2 id="任务四：进行简单的循迹"><a href="#任务四：进行简单的循迹" class="headerlink" title="任务四：进行简单的循迹"></a>任务四：进行简单的循迹</h2><h2 id="外设原理"><a href="#外设原理" class="headerlink" title="外设原理"></a>外设原理</h2><p><strong>红外对管</strong>：红外对管循迹的原理主要是利用了不同颜色物体对红外线的反射和吸收能力不同。其基本工作过程如下：</p><p> 红外发射：红外对管由一个红外发射管和一个红外接收管组成。红外发射管通电后会持续向外发射特定波长的红外线。</p><p>光线反射：当红外光线照射到物体表面时，根据物体的颜色和材质特性，会对红外线产生不同的反射情况。白色物体对光线的反射能力较强，能够将大部分照射到其表面的红外线反射出去；而黑色物体对光线的吸收能力较强，反射的红外线则较少。</p><p>接收与转换：红外接收管是一种对红外线敏感的光敏元件。当接收管接收到反射回来的红外线时，其内部的物理特性会发生变化，从而产生电流或电压的变化。如果接收到的红外光强度较大，接收管产生的电流或电压就会相应较大；反之，如果接收到的红外光很弱或几乎没有，接收管产生的电流或电压就会非常小。</p><p> 信号输出与判断：通常会将红外接收管的输出信号连接到一个比较电路或信号处理电路。该电路会将接收管输出的信号与一个预设的阈值进行比较。如果接收管输出的信号大于阈值，说明接收到的红外光较强，此时判断为红外对管处于白色区域；如果接收管输出的信号小于阈值，说明接收到的红外光较弱，此时判断为红外对管处于黑色轨迹上。</p><p>基于以上原理，将红外对管安装在移动的物体（如智能小车）上，并合理设置多个红外对管的位置，就可以通过检测不同位置的红外对管信号，判断物体相对于黑线轨迹的位置，从而实现循迹功能。例如，当小车的左侧红外对管检测到黑色轨迹，而右侧红外对管检测到白色区域时，说明小车向左偏离了轨迹，控制系统就可以控制小车向右转，以保持在黑色轨迹上行驶。</p><p><strong>循迹模块</strong>：根据红外对管反射回的信息，来判断小车行走的状态</p><p>5个红外对管安装在小车的对应位置</p><p>将ADC值转换为黑线1或者没有线0,红外对管从左往右分别为IPT0,IPT1，IPT2，IPT3，IPT4</p><p>我们根据反射回的信息将小车运动分为几种情况</p><p><strong>PID：</strong>比例-积分-微分控制器，是一种常用的反馈控制算法，广泛应用于工业控制、自动化等领域。</p><p> 基本原理</p><ol><li>比例控制（P）</li></ol><p> 比例控制是根据当前的误差值与一个比例系数相乘来计算控制量。误差值是设定值与实际值之间的差值。</p><p>例如，如果设定温度为 50℃，当前实际温度为 45℃，误差为 5℃。假设比例系数为 2，那么比例控制的输出为 5×2 &#x3D; 10。</p><p>比例控制的作用是对误差进行快速响应，但不能消除稳态误差，即当系统达到稳定状态时，可能仍然存在一定的误差。</p><ol start="2"><li>积分控制（I）</li></ol><p> 积分控制是对误差进行累积求和，并将累积的误差与一个积分系数相乘来计算控制量。</p><p>随着时间的推移，积分项会不断增大，直到误差为零。积分控制的作用是消除稳态误差，但积分作用过强可能会导致系统响应变慢或出现超调。</p><p>例如，在温度控制中，如果误差一直存在，积分项会不断累积，使得控制量逐渐增大，直到温度达到设定值。</p><ol start="3"><li>微分控制（D）</li></ol><p> 微分控制是根据误差的变化率（即当前误差与上一时刻误差的差值）与一个微分系数相乘来计算控制量。</p><p>微分控制的作用是预测误差的变化趋势，提前给出控制信号，从而减小超调量和提高系统的稳定性。</p><p>例如，如果温度上升速度很快，微分控制会产生一个较大的负控制量，以抑制温度的快速上升。</p><p> 工作过程</p><p>  首先，测量系统的实际输出值。</p><p>然后，计算实际输出值与设定值之间的误差。</p><p>分别计算比例、积分和微分三个部分的控制量：</p><p>比例控制量 &#x3D; 比例系数 × 误差</p><p>积分控制量 &#x3D; 积分系数 × 误差的累积和</p><p>微分控制量 &#x3D; 微分系数 × 误差的变化率</p><p>将三个部分的控制量相加，得到总的控制量。</p><p> 根据控制量来调整系统的输入，使系统的输出逐渐接近设定值。</p><h2 id="外设应用"><a href="#外设应用" class="headerlink" title="外设应用"></a>外设应用</h2><p>我们根据反射回的信息将小车运动分为以下几种情况</p><ol><li>直行</li></ol><p>此时五个红外对管反射回的信息为00100</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(IPT[<span class="number">0</span>]==<span class="number">0</span>&amp;&amp;IPT[<span class="number">1</span>]==<span class="number">0</span>&amp;&amp;IPT[<span class="number">2</span>]==<span class="number">1</span>&amp;&amp;IPT[<span class="number">3</span>]==<span class="number">0</span>&amp;&amp;IPT[<span class="number">4</span>]==<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">qianjin();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ol><li>左转90度</li></ol><p>此时五个红外对管反射回的信息为11000或者11100</p><p>开始左转</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(IPT[<span class="number">0</span>]==<span class="number">1</span>&amp;&amp;IPT[<span class="number">1</span>]==<span class="number">1</span>&amp;&amp;IPT[<span class="number">3</span>]==<span class="number">0</span>&amp;&amp;IPT[<span class="number">4</span>]==<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">turnleft(<span class="number">90</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>右转90度</li></ol><p>此时五个红外对管反射回的信息为00011或者00111</p><p>开始右转</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(IPT[<span class="number">0</span>]==<span class="number">0</span>&amp;&amp;IPT[<span class="number">1</span>]==<span class="number">0</span>&amp;&amp;IPT[<span class="number">3</span>]==<span class="number">1</span>&amp;&amp;IPT[<span class="number">4</span>]==<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">turnright(<span class="number">90</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>向左偏一些</li></ol><p>此时五个红外对管反射回的信息为01000</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(IPT[<span class="number">0</span>]==<span class="number">0</span>&amp;&amp;IPT[<span class="number">1</span>]==<span class="number">1</span>&amp;&amp;IPT[<span class="number">2</span>]==<span class="number">0</span>&amp;&amp;IPT[<span class="number">3</span>]==<span class="number">0</span>&amp;&amp;IPT[<span class="number">4</span>]==<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">turnleft(<span class="number">30</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>向右偏一些</li></ol><p>此时五个红外对管反射回的信息为00010</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(IPT[<span class="number">0</span>]==<span class="number">0</span>&amp;&amp;IPT[<span class="number">1</span>]==<span class="number">0</span>&amp;&amp;IPT[<span class="number">2</span>]==<span class="number">0</span>&amp;&amp;IPT[<span class="number">3</span>]==<span class="number">1</span>&amp;&amp;IPT[<span class="number">4</span>]==<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">turnright(<span class="number">30</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>掉头</li></ol><p>此时五个红外对管反射回的信息为00000</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(IPT[<span class="number">0</span>]==<span class="number">0</span>&amp;&amp;IPT[<span class="number">1</span>]==<span class="number">0</span>&amp;&amp;IPT[<span class="number">2</span>]==<span class="number">0</span>&amp;&amp;IPT[<span class="number">3</span>]==<span class="number">0</span>&amp;&amp;IPT[<span class="number">4</span>]==<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">turnright(<span class="number">180</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>在遇见岔路时，选择右转</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(IPT[<span class="number">0</span>]==<span class="number">1</span>&amp;&amp;IPT[<span class="number">1</span>]==<span class="number">1</span>&amp;&amp;IPT[<span class="number">2</span>]==<span class="number">1</span>&amp;&amp;IPT[<span class="number">3</span>]==<span class="number">1</span>&amp;&amp;IPT[<span class="number">4</span>]==<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">turnright(<span class="number">90</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用直流电机作为动力源，通过电机驱动电路来控制电机的转速和方向。</p><p>通过控制左右两个电机的转速和方向，可以使小车实现前进、后退、转弯等动作。例如，当左侧电机转速高于右侧电机转速时，小车会向右转；当右侧电机转速高于左侧电机转速时，小车会向左转。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">leftforward</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">PDout(<span class="number">12</span>,<span class="number">1</span>);</span><br><span class="line">PDout(<span class="number">13</span>,<span class="number">0</span>);</span><br><span class="line">PDout(<span class="number">14</span>,<span class="number">1</span>);</span><br><span class="line">PDout(<span class="number">15</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rightforward</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">PEout(<span class="number">9</span>,<span class="number">1</span>);</span><br><span class="line">PEout(<span class="number">11</span>,<span class="number">0</span>);</span><br><span class="line">PBout(<span class="number">10</span>,<span class="number">1</span>);</span><br><span class="line">PBout(<span class="number">11</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">leftbackward</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">PDout(<span class="number">12</span>,<span class="number">0</span>);</span><br><span class="line">PDout(<span class="number">13</span>,<span class="number">1</span>);</span><br><span class="line">PDout(<span class="number">14</span>,<span class="number">0</span>);</span><br><span class="line">PDout(<span class="number">15</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rightbackward</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">PEout(<span class="number">9</span>,<span class="number">0</span>);</span><br><span class="line">PEout(<span class="number">11</span>,<span class="number">1</span>);</span><br><span class="line">PBout(<span class="number">10</span>,<span class="number">0</span>);</span><br><span class="line">PBout(<span class="number">11</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">turnright</span><span class="params">(<span class="type">uint16_t</span> angle)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> dt = (<span class="number">8</span>*angle);</span><br><span class="line">leftforward();</span><br><span class="line">rightbackward();</span><br><span class="line">Delay_ms(dt);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">turnleft</span><span class="params">(<span class="type">uint16_t</span> angle)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> dt = (<span class="number">8</span>*angle);</span><br><span class="line">leftbackward();</span><br><span class="line">rightforward();</span><br><span class="line">Delay_ms(dt);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用PWM改变速度</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">my_set_tim_compare</span><span class="params">(<span class="type">uint16_t</span> brr)</span></span><br><span class="line">&#123;</span><br><span class="line">TIM_SetCompare2(TIM4,brr);</span><br><span class="line">TIM_SetCompare1(TIM4,brr);</span><br><span class="line">TIM_SetCompare2(TIM2,brr);</span><br><span class="line">TIM_SetCompare1(TIM2,brr);</span><br><span class="line">TIM_SetCompare2(TIM1,brr);</span><br><span class="line">TIM_SetCompare1(TIM1,brr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PDout</span><span class="params">(<span class="type">uint8_t</span> pin, <span class="type">uint8_t</span> value)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (value) &#123;</span><br><span class="line">        GPIO_SetBits(GPIOD, <span class="number">1</span> &lt;&lt; pin); <span class="comment">// Set the pin high</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        GPIO_ResetBits(GPIOD, <span class="number">1</span> &lt;&lt; pin); <span class="comment">// Set the pin low</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PEout</span><span class="params">(<span class="type">uint8_t</span> pin, <span class="type">uint8_t</span> value)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (value) &#123;</span><br><span class="line">        GPIO_SetBits(GPIOE, <span class="number">1</span> &lt;&lt; pin); <span class="comment">// Set the pin high</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        GPIO_ResetBits(GPIOE, <span class="number">1</span> &lt;&lt; pin); <span class="comment">// Set the pin low</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PBout</span><span class="params">(<span class="type">uint8_t</span> pin, <span class="type">uint8_t</span> value)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (value) &#123;</span><br><span class="line">        GPIO_SetBits(GPIOB, <span class="number">1</span> &lt;&lt; pin); <span class="comment">// Set the pin high</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        GPIO_ResetBits(GPIOB, <span class="number">1</span> &lt;&lt; pin); <span class="comment">// Set the pin low</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM4_PWM_Init</span><span class="params">(u16 arr,u16 psc)</span></span><br><span class="line">&#123;  </span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;</span><br><span class="line">TIM_OCInitTypeDef  TIM_OCInitStructure;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM4, ENABLE);</span><br><span class="line"> RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOD,ENABLE); </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_7; <span class="comment">//</span></span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;  <span class="comment">//复用推挽输出</span></span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOA, &amp;GPIO_InitStructure);<span class="comment">//TIM4通道2</span></span><br><span class="line"></span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6; <span class="comment">//</span></span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;  <span class="comment">//</span></span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOA, &amp;GPIO_InitStructure);<span class="comment">//TIM4通道1</span></span><br><span class="line"></span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; </span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOD, &amp;GPIO_InitStructure); </span><br><span class="line">GPIO_ResetBits(GPIOD,GPIO_Pin_12);</span><br><span class="line"></span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; </span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; </span><br><span class="line">GPIO_Init(GPIOD, &amp;GPIO_InitStructure);</span><br><span class="line">GPIO_ResetBits(GPIOD,GPIO_Pin_13);</span><br><span class="line"></span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_14; </span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; </span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; </span><br><span class="line">GPIO_Init(GPIOD, &amp;GPIO_InitStructure); </span><br><span class="line">GPIO_ResetBits(GPIOD,GPIO_Pin_14);</span><br><span class="line"></span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_15;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; </span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; </span><br><span class="line">GPIO_Init(GPIOD, &amp;GPIO_InitStructure); </span><br><span class="line">GPIO_ResetBits(GPIOD,GPIO_Pin_15);</span><br><span class="line"> </span><br><span class="line">TIM_TimeBaseStructure.TIM_Period = arr; </span><br><span class="line">TIM_TimeBaseStructure.TIM_Prescaler =psc; </span><br><span class="line">TIM_TimeBaseStructure.TIM_ClockDivision = <span class="number">0</span>; </span><br><span class="line">TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;  </span><br><span class="line">TIM_TimeBaseInit(TIM4, &amp;TIM_TimeBaseStructure);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM2; </span><br><span class="line"> TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable; </span><br><span class="line">TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High; </span><br><span class="line">TIM_OC2Init(TIM4, &amp;TIM_OCInitStructure);  </span><br><span class="line"> </span><br><span class="line">TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM2; </span><br><span class="line"> TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable; </span><br><span class="line">TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High; </span><br><span class="line">TIM_OC1Init(TIM4, &amp;TIM_OCInitStructure);  </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">TIM_Cmd(TIM4, ENABLE);  </span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM2_PWM_Init</span><span class="params">(u16 arr,u16 psc)</span></span><br><span class="line">&#123;  </span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;</span><br><span class="line">TIM_OCInitTypeDef  TIM_OCInitStructure;</span><br><span class="line"> </span><br><span class="line">RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);</span><br><span class="line"> RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOE,ENABLE); </span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE); </span><br><span class="line"></span><br><span class="line">  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; </span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; </span><br><span class="line">GPIO_Init(GPIOE, &amp;GPIO_InitStructure);</span><br><span class="line">GPIO_ResetBits(GPIOE,GPIO_Pin_9);</span><br><span class="line"></span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; </span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; </span><br><span class="line">GPIO_Init(GPIOE, &amp;GPIO_InitStructure);</span><br><span class="line">GPIO_ResetBits(GPIOE,GPIO_Pin_11);</span><br><span class="line"></span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10; </span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; </span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; </span><br><span class="line">GPIO_Init(GPIOB, &amp;GPIO_InitStructure); </span><br><span class="line">GPIO_ResetBits(GPIOB,GPIO_Pin_10);</span><br><span class="line"></span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; </span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; </span><br><span class="line">GPIO_Init(GPIOB, &amp;GPIO_InitStructure); </span><br><span class="line">GPIO_ResetBits(GPIOB,GPIO_Pin_11);</span><br><span class="line"> </span><br><span class="line">TIM_TimeBaseStructure.TIM_Period = arr; </span><br><span class="line">TIM_TimeBaseStructure.TIM_Prescaler =psc; </span><br><span class="line">TIM_TimeBaseStructure.TIM_ClockDivision = <span class="number">0</span>; </span><br><span class="line">TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;  </span><br><span class="line">TIM_TimeBaseInit(TIM2, &amp;TIM_TimeBaseStructure);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM2; </span><br><span class="line"> TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable; </span><br><span class="line">TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High; </span><br><span class="line">TIM_OC2Init(TIM2, &amp;TIM_OCInitStructure);  </span><br><span class="line"> </span><br><span class="line">TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM2; </span><br><span class="line"> TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable; </span><br><span class="line">TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High; </span><br><span class="line">TIM_OC1Init(TIM2, &amp;TIM_OCInitStructure);  </span><br><span class="line"></span><br><span class="line"> TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM2;</span><br><span class="line"> TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable; </span><br><span class="line">TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High; </span><br><span class="line">TIM_OC1Init(TIM1, &amp;TIM_OCInitStructure);</span><br><span class="line"> </span><br><span class="line">TIM_Cmd(TIM2, ENABLE); </span><br><span class="line">TIM_Cmd(TIM1, ENABLE);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">qianjin</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">PDout(<span class="number">12</span>,<span class="number">1</span>);</span><br><span class="line">PDout(<span class="number">13</span>,<span class="number">0</span>);</span><br><span class="line">PDout(<span class="number">14</span>,<span class="number">1</span>);</span><br><span class="line">PDout(<span class="number">15</span>,<span class="number">0</span>);</span><br><span class="line">PEout(<span class="number">9</span>,<span class="number">1</span>);</span><br><span class="line">PEout(<span class="number">11</span>,<span class="number">0</span>);</span><br><span class="line">PBout(<span class="number">10</span>,<span class="number">1</span>);</span><br><span class="line">PBout(<span class="number">11</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">houtui</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">PDout(<span class="number">12</span>,<span class="number">0</span>);</span><br><span class="line">PDout(<span class="number">13</span>,<span class="number">1</span>);</span><br><span class="line">PDout(<span class="number">14</span>,<span class="number">0</span>);</span><br><span class="line">PDout(<span class="number">15</span>,<span class="number">1</span>);</span><br><span class="line">PEout(<span class="number">9</span>,<span class="number">0</span>);</span><br><span class="line">PEout(<span class="number">11</span>,<span class="number">1</span>);</span><br><span class="line">PBout(<span class="number">10</span>,<span class="number">0</span>);</span><br><span class="line">PBout(<span class="number">11</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">stop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">PDout(<span class="number">12</span>,<span class="number">0</span>);</span><br><span class="line">PDout(<span class="number">13</span>,<span class="number">0</span>);</span><br><span class="line">PDout(<span class="number">14</span>,<span class="number">0</span>);</span><br><span class="line">PDout(<span class="number">15</span>,<span class="number">0</span>);</span><br><span class="line">PEout(<span class="number">9</span>,<span class="number">0</span>);</span><br><span class="line">PEout(<span class="number">11</span>,<span class="number">0</span>);</span><br><span class="line">PBout(<span class="number">10</span>,<span class="number">0</span>);</span><br><span class="line">PBout(<span class="number">11</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结合任务二的部分，设计出简单的循迹算法</p><h2 id="任务实现"><a href="#任务实现" class="headerlink" title="任务实现"></a>任务实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AD.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;contral car.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;PWM.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;OLED.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">TIM4_PWM_Init(<span class="number">450</span>,<span class="number">7199</span>);</span><br><span class="line">TIM2_PWM_Init(<span class="number">450</span>,<span class="number">7199</span>);</span><br><span class="line">AD_Init();</span><br><span class="line">OLED_Init();</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">  AD_GetValue();</span><br><span class="line">  OLED_ShowNum(<span class="number">1</span>,<span class="number">1</span>,IPT[<span class="number">0</span>],<span class="number">1</span>);</span><br><span class="line">  OLED_ShowNum(<span class="number">2</span>,<span class="number">1</span>,IPT[<span class="number">1</span>],<span class="number">1</span>);</span><br><span class="line">  OLED_ShowNum(<span class="number">3</span>,<span class="number">1</span>,IPT[<span class="number">2</span>],<span class="number">1</span>);</span><br><span class="line">  OLED_ShowNum(<span class="number">4</span>,<span class="number">1</span>,IPT[<span class="number">3</span>],<span class="number">1</span>);</span><br><span class="line">  OLED_ShowNum(<span class="number">1</span>,<span class="number">4</span>,IPT[<span class="number">4</span>],<span class="number">1</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//直行</span></span><br><span class="line">  <span class="keyword">if</span>(IPT[<span class="number">0</span>]==<span class="number">0</span>&amp;&amp;IPT[<span class="number">1</span>]==<span class="number">0</span>&amp;&amp;IPT[<span class="number">2</span>]==<span class="number">1</span>&amp;&amp;IPT[<span class="number">3</span>]==<span class="number">0</span>&amp;&amp;IPT[<span class="number">4</span>]==<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">qianjin();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//左偏一点点</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(IPT[<span class="number">0</span>]==<span class="number">0</span>&amp;&amp;IPT[<span class="number">1</span>]==<span class="number">1</span>&amp;&amp;IPT[<span class="number">2</span>]==<span class="number">0</span>&amp;&amp;IPT[<span class="number">3</span>]==<span class="number">0</span>&amp;&amp;IPT[<span class="number">4</span>]==<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">turnleft(<span class="number">30</span>);</span><br><span class="line">&#125;<span class="comment">//右偏一点点</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(IPT[<span class="number">0</span>]==<span class="number">0</span>&amp;&amp;IPT[<span class="number">1</span>]==<span class="number">0</span>&amp;&amp;IPT[<span class="number">2</span>]==<span class="number">0</span>&amp;&amp;IPT[<span class="number">3</span>]==<span class="number">1</span>&amp;&amp;IPT[<span class="number">4</span>]==<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">turnright(<span class="number">30</span>);</span><br><span class="line">&#125;<span class="comment">//左转</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(IPT[<span class="number">0</span>]==<span class="number">1</span>&amp;&amp;IPT[<span class="number">1</span>]==<span class="number">1</span>&amp;&amp;IPT[<span class="number">3</span>]==<span class="number">0</span>&amp;&amp;IPT[<span class="number">4</span>]==<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">turnleft(<span class="number">90</span>);</span><br><span class="line">&#125;<span class="comment">//右转</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(IPT[<span class="number">0</span>]==<span class="number">0</span>&amp;&amp;IPT[<span class="number">1</span>]==<span class="number">0</span>&amp;&amp;IPT[<span class="number">3</span>]==<span class="number">1</span>&amp;&amp;IPT[<span class="number">4</span>]==<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">turnright(<span class="number">90</span>);</span><br><span class="line">&#125;<span class="comment">//转弯</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(IPT[<span class="number">0</span>]==<span class="number">0</span>&amp;&amp;IPT[<span class="number">1</span>]==<span class="number">0</span>&amp;&amp;IPT[<span class="number">2</span>]==<span class="number">0</span>&amp;&amp;IPT[<span class="number">3</span>]==<span class="number">0</span>&amp;&amp;IPT[<span class="number">4</span>]==<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">turnright(<span class="number">180</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(IPT[<span class="number">0</span>]==<span class="number">1</span>&amp;&amp;IPT[<span class="number">1</span>]==<span class="number">1</span>&amp;&amp;IPT[<span class="number">2</span>]==<span class="number">1</span>&amp;&amp;IPT[<span class="number">3</span>]==<span class="number">1</span>&amp;&amp;IPT[<span class="number">4</span>]==<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">turnright(<span class="number">90</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> AD_Value[<span class="number">5</span>];</span><br><span class="line"><span class="type">uint16_t</span> tixed_value1=<span class="number">1000</span>;</span><br><span class="line"><span class="type">uint16_t</span> tixed_value2=<span class="number">500</span>;</span><br><span class="line"><span class="type">uint16_t</span> IPT[<span class="number">5</span>];</span><br><span class="line"><span class="type">void</span> <span class="title function_">AD_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC3,ENABLE);<span class="comment">//开启ADC1和GPIOC的时钟</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC|RCC_APB2Periph_GPIOF,ENABLE);</span><br><span class="line">RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA2,ENABLE);<span class="comment">//开启时钟</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RCC_ADCCLKConfig(RCC_PCLK2_Div6);<span class="comment">//分频，分频之后ADCCLK=72MHz/6=12</span></span><br><span class="line"></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line"> GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;</span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;</span><br><span class="line">GPIO_Init(GPIOC, &amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;</span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6|GPIO_Pin_8|GPIO_Pin_10|GPIO_Pin_9;</span><br><span class="line">GPIO_Init(GPIOF, &amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ADC_RegularChannelConfig(ADC3,ADC_Channel_4,<span class="number">1</span>,ADC_SampleTime_13Cycles5);<span class="comment">//规则组序列3的位置，配置为通道</span></span><br><span class="line"></span><br><span class="line">ADC_RegularChannelConfig(ADC3,ADC_Channel_6,<span class="number">2</span>,ADC_SampleTime_13Cycles5);<span class="comment">//规则组序列3的位置，配置为通道</span></span><br><span class="line">ADC_RegularChannelConfig(ADC3,ADC_Channel_7,<span class="number">3</span>,ADC_SampleTime_13Cycles5);<span class="comment">//规则组序列3的位置，配置为通道</span></span><br><span class="line">ADC_RegularChannelConfig(ADC3,ADC_Channel_8,<span class="number">4</span>,ADC_SampleTime_13Cycles5);<span class="comment">//规则组序列3的位置，配置为通道</span></span><br><span class="line"></span><br><span class="line">    ADC_RegularChannelConfig(ADC3,ADC_Channel_12,<span class="number">5</span>,ADC_SampleTime_13Cycles5);<span class="comment">//规则组序列1的位置，配置为通道</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ADC_InitTypeDef ADC_InitStructure;</span><br><span class="line">ADC_InitStructure.ADC_ContinuousConvMode=DISABLE ;</span><br><span class="line">ADC_InitStructure.ADC_DataAlign=ADC_DataAlign_Right;<span class="comment">//数据对齐，选择右对齐</span></span><br><span class="line">ADC_InitStructure.ADC_ExternalTrigConv=ADC_ExternalTrigConv_None;<span class="comment">//外部触发，使用软件触发，不需要外部触发</span></span><br><span class="line">ADC_InitStructure.ADC_Mode=ADC_Mode_Independent;<span class="comment">//模式，选择独立模式，即单独使用ADC1</span></span><br><span class="line">ADC_InitStructure.ADC_NbrOfChannel=<span class="number">5</span> ;<span class="comment">//通道数，为1，仅在扫描模式下，才需要指定大于1的数，在非扫描模式下，只能是1</span></span><br><span class="line">ADC_InitStructure.ADC_ScanConvMode=ENABLE ;<span class="comment">//扫描模式</span></span><br><span class="line">ADC_Init(ADC3,&amp;ADC_InitStructure);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DMA_InitTypeDef DMA_InitStructure;</span><br><span class="line">DMA_InitStructure.DMA_BufferSize=<span class="number">5</span>;<span class="comment">//转运的数据大小（转运次数）</span></span><br><span class="line">DMA_InitStructure.DMA_DIR=DMA_DIR_PeripheralSRC;<span class="comment">//数据传输方向，选择由外设到存储器</span></span><br><span class="line">DMA_InitStructure.DMA_M2M=DMA_M2M_Disable;<span class="comment">//硬件触发或者软件触发,该处选择软件触发</span></span><br><span class="line">DMA_InitStructure.DMA_MemoryBaseAddr=(<span class="type">uint32_t</span>)AD_Value;<span class="comment">//存储器初始地址，给定形参AddrB</span></span><br><span class="line">DMA_InitStructure.DMA_MemoryDataSize=DMA_MemoryDataSize_HalfWord;<span class="comment">//存储器数据宽度，选择字节</span></span><br><span class="line">DMA_InitStructure.DMA_MemoryInc=DMA_MemoryInc_Enable;<span class="comment">//存储器地址自增，选择使能</span></span><br><span class="line">DMA_InitStructure.DMA_Mode=DMA_Mode_Normal;<span class="comment">//模式，选择正常模式</span></span><br><span class="line">DMA_InitStructure.DMA_PeripheralBaseAddr=(<span class="type">uint32_t</span>)&amp;ADC3-&gt;DR;<span class="comment">//外设初始地址，给定形参AddrA</span></span><br><span class="line">DMA_InitStructure.DMA_PeripheralDataSize=DMA_PeripheralDataSize_HalfWord;<span class="comment">//外设数据宽度，选择字节</span></span><br><span class="line">DMA_InitStructure.DMA_PeripheralInc=DMA_PeripheralInc_Disable;<span class="comment">//外设地址自增，选择使能</span></span><br><span class="line">DMA_InitStructure.DMA_Priority=DMA_Priority_Medium;<span class="comment">//优先级，选择中等</span></span><br><span class="line">DMA_Init(DMA2_Channel5,&amp;DMA_InitStructure);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DMA_Cmd(DMA2_Channel5,ENABLE);</span><br><span class="line">ADC_DMACmd(ADC3 ,ENABLE );</span><br><span class="line">ADC_Cmd(ADC3,ENABLE);</span><br><span class="line"></span><br><span class="line">ADC_ResetCalibration(ADC3);<span class="comment">//校准</span></span><br><span class="line"><span class="keyword">while</span>(ADC_GetResetCalibrationStatus(ADC3)==SET);</span><br><span class="line">ADC_StartCalibration(ADC3);</span><br><span class="line"><span class="keyword">while</span>(ADC_GetCalibrationStatus(ADC3)==SET);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>  <span class="title function_">AD_GetValue</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">DMA_Cmd(DMA2_Channel5,DISABLE);</span><br><span class="line">DMA_SetCurrDataCounter (DMA2_Channel5,<span class="number">5</span>);</span><br><span class="line">DMA_Cmd(DMA2_Channel5,ENABLE);</span><br><span class="line"></span><br><span class="line">ADC_SoftwareStartConvCmd(ADC3,ENABLE);<span class="comment">//软件触发AD转换一次</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(DMA_GetFlagStatus(DMA2_FLAG_TC5)==RESET);</span><br><span class="line">DMA_ClearFlag(DMA2_FLAG_TC5);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将ADC值转换为黑线1或者没有线0,红外对管从左往右分别为IPT0,IPT1，IPT2，IPT3，IPT4</span></span><br><span class="line"><span class="type">uint8_t</span> i;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;=<span class="number">7</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(AD_Value[i]&gt;=tixed_value1)</span><br><span class="line">&#123;</span><br><span class="line">IPT[i]=<span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (AD_Value[i]&lt;=tixed_value2) &#123;</span><br><span class="line">   IPT[i]=<span class="number">0</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> IPT[i]=<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">my_set_tim_compare</span><span class="params">(<span class="type">uint16_t</span> brr)</span></span><br><span class="line">&#123;</span><br><span class="line">TIM_SetCompare2(TIM4,brr);</span><br><span class="line">TIM_SetCompare1(TIM4,brr);</span><br><span class="line">TIM_SetCompare2(TIM2,brr);</span><br><span class="line">TIM_SetCompare1(TIM2,brr);</span><br><span class="line">TIM_SetCompare2(TIM1,brr);</span><br><span class="line">TIM_SetCompare1(TIM1,brr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PDout</span><span class="params">(<span class="type">uint8_t</span> pin, <span class="type">uint8_t</span> value)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (value) &#123;</span><br><span class="line">        GPIO_SetBits(GPIOD, <span class="number">1</span> &lt;&lt; pin); <span class="comment">// Set the pin high</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        GPIO_ResetBits(GPIOD, <span class="number">1</span> &lt;&lt; pin); <span class="comment">// Set the pin low</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PEout</span><span class="params">(<span class="type">uint8_t</span> pin, <span class="type">uint8_t</span> value)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (value) &#123;</span><br><span class="line">        GPIO_SetBits(GPIOE, <span class="number">1</span> &lt;&lt; pin); <span class="comment">// Set the pin high</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        GPIO_ResetBits(GPIOE, <span class="number">1</span> &lt;&lt; pin); <span class="comment">// Set the pin low</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PBout</span><span class="params">(<span class="type">uint8_t</span> pin, <span class="type">uint8_t</span> value)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (value) &#123;</span><br><span class="line">        GPIO_SetBits(GPIOB, <span class="number">1</span> &lt;&lt; pin); <span class="comment">// Set the pin high</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        GPIO_ResetBits(GPIOB, <span class="number">1</span> &lt;&lt; pin); <span class="comment">// Set the pin low</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM4_PWM_Init</span><span class="params">(u16 arr,u16 psc)</span></span><br><span class="line">&#123;  </span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;</span><br><span class="line">TIM_OCInitTypeDef  TIM_OCInitStructure;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM4, ENABLE);</span><br><span class="line"> RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOD,ENABLE); </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_7; <span class="comment">//</span></span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;  <span class="comment">//复用推挽输出</span></span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOA, &amp;GPIO_InitStructure);<span class="comment">//TIM4通道2</span></span><br><span class="line"></span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6; <span class="comment">//</span></span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;  <span class="comment">//</span></span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOA, &amp;GPIO_InitStructure);<span class="comment">//TIM4通道1</span></span><br><span class="line"></span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; </span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOD, &amp;GPIO_InitStructure); </span><br><span class="line">GPIO_ResetBits(GPIOD,GPIO_Pin_12);</span><br><span class="line"></span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; </span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; </span><br><span class="line">GPIO_Init(GPIOD, &amp;GPIO_InitStructure);</span><br><span class="line">GPIO_ResetBits(GPIOD,GPIO_Pin_13);</span><br><span class="line"></span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_14; </span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; </span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; </span><br><span class="line">GPIO_Init(GPIOD, &amp;GPIO_InitStructure); </span><br><span class="line">GPIO_ResetBits(GPIOD,GPIO_Pin_14);</span><br><span class="line"></span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_15;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; </span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; </span><br><span class="line">GPIO_Init(GPIOD, &amp;GPIO_InitStructure); </span><br><span class="line">GPIO_ResetBits(GPIOD,GPIO_Pin_15);</span><br><span class="line"> </span><br><span class="line">TIM_TimeBaseStructure.TIM_Period = arr; </span><br><span class="line">TIM_TimeBaseStructure.TIM_Prescaler =psc; </span><br><span class="line">TIM_TimeBaseStructure.TIM_ClockDivision = <span class="number">0</span>; </span><br><span class="line">TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;  </span><br><span class="line">TIM_TimeBaseInit(TIM4, &amp;TIM_TimeBaseStructure);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM2; </span><br><span class="line"> TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable; </span><br><span class="line">TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High; </span><br><span class="line">TIM_OC2Init(TIM4, &amp;TIM_OCInitStructure);  </span><br><span class="line"> </span><br><span class="line">TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM2; </span><br><span class="line"> TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable; </span><br><span class="line">TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High; </span><br><span class="line">TIM_OC1Init(TIM4, &amp;TIM_OCInitStructure);  </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">TIM_Cmd(TIM4, ENABLE);  </span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM2_PWM_Init</span><span class="params">(u16 arr,u16 psc)</span></span><br><span class="line">&#123;  </span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;</span><br><span class="line">TIM_OCInitTypeDef  TIM_OCInitStructure;</span><br><span class="line"> </span><br><span class="line">RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);</span><br><span class="line"> RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOE,ENABLE); </span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE); </span><br><span class="line"></span><br><span class="line">  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; </span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; </span><br><span class="line">GPIO_Init(GPIOE, &amp;GPIO_InitStructure);</span><br><span class="line">GPIO_ResetBits(GPIOE,GPIO_Pin_9);</span><br><span class="line"></span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; </span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; </span><br><span class="line">GPIO_Init(GPIOE, &amp;GPIO_InitStructure);</span><br><span class="line">GPIO_ResetBits(GPIOE,GPIO_Pin_11);</span><br><span class="line"></span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10; </span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; </span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; </span><br><span class="line">GPIO_Init(GPIOB, &amp;GPIO_InitStructure); </span><br><span class="line">GPIO_ResetBits(GPIOB,GPIO_Pin_10);</span><br><span class="line"></span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; </span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; </span><br><span class="line">GPIO_Init(GPIOB, &amp;GPIO_InitStructure); </span><br><span class="line">GPIO_ResetBits(GPIOB,GPIO_Pin_11);</span><br><span class="line"> </span><br><span class="line">TIM_TimeBaseStructure.TIM_Period = arr; </span><br><span class="line">TIM_TimeBaseStructure.TIM_Prescaler =psc; </span><br><span class="line">TIM_TimeBaseStructure.TIM_ClockDivision = <span class="number">0</span>; </span><br><span class="line">TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;  </span><br><span class="line">TIM_TimeBaseInit(TIM2, &amp;TIM_TimeBaseStructure);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM2; </span><br><span class="line"> TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable; </span><br><span class="line">TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High; </span><br><span class="line">TIM_OC2Init(TIM2, &amp;TIM_OCInitStructure);  </span><br><span class="line"> </span><br><span class="line">TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM2; </span><br><span class="line"> TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable; </span><br><span class="line">TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High; </span><br><span class="line">TIM_OC1Init(TIM2, &amp;TIM_OCInitStructure);  </span><br><span class="line"></span><br><span class="line"> TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM2;</span><br><span class="line"> TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable; </span><br><span class="line">TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High; </span><br><span class="line">TIM_OC1Init(TIM1, &amp;TIM_OCInitStructure);</span><br><span class="line"> </span><br><span class="line">TIM_Cmd(TIM2, ENABLE); </span><br><span class="line">TIM_Cmd(TIM1, ENABLE);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">qianjin</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">PDout(<span class="number">12</span>,<span class="number">1</span>);</span><br><span class="line">PDout(<span class="number">13</span>,<span class="number">0</span>);</span><br><span class="line">PDout(<span class="number">14</span>,<span class="number">1</span>);</span><br><span class="line">PDout(<span class="number">15</span>,<span class="number">0</span>);</span><br><span class="line">PEout(<span class="number">9</span>,<span class="number">1</span>);</span><br><span class="line">PEout(<span class="number">11</span>,<span class="number">0</span>);</span><br><span class="line">PBout(<span class="number">10</span>,<span class="number">1</span>);</span><br><span class="line">PBout(<span class="number">11</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">houtui</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">PDout(<span class="number">12</span>,<span class="number">0</span>);</span><br><span class="line">PDout(<span class="number">13</span>,<span class="number">1</span>);</span><br><span class="line">PDout(<span class="number">14</span>,<span class="number">0</span>);</span><br><span class="line">PDout(<span class="number">15</span>,<span class="number">1</span>);</span><br><span class="line">PEout(<span class="number">9</span>,<span class="number">0</span>);</span><br><span class="line">PEout(<span class="number">11</span>,<span class="number">1</span>);</span><br><span class="line">PBout(<span class="number">10</span>,<span class="number">0</span>);</span><br><span class="line">PBout(<span class="number">11</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">stop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">PDout(<span class="number">12</span>,<span class="number">0</span>);</span><br><span class="line">PDout(<span class="number">13</span>,<span class="number">0</span>);</span><br><span class="line">PDout(<span class="number">14</span>,<span class="number">0</span>);</span><br><span class="line">PDout(<span class="number">15</span>,<span class="number">0</span>);</span><br><span class="line">PEout(<span class="number">9</span>,<span class="number">0</span>);</span><br><span class="line">PEout(<span class="number">11</span>,<span class="number">0</span>);</span><br><span class="line">PBout(<span class="number">10</span>,<span class="number">0</span>);</span><br><span class="line">PBout(<span class="number">11</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;PWM.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">leftforward</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">PDout(<span class="number">12</span>,<span class="number">1</span>);</span><br><span class="line">PDout(<span class="number">13</span>,<span class="number">0</span>);</span><br><span class="line">PDout(<span class="number">14</span>,<span class="number">1</span>);</span><br><span class="line">PDout(<span class="number">15</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rightforward</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">PEout(<span class="number">9</span>,<span class="number">1</span>);</span><br><span class="line">PEout(<span class="number">11</span>,<span class="number">0</span>);</span><br><span class="line">PBout(<span class="number">10</span>,<span class="number">1</span>);</span><br><span class="line">PBout(<span class="number">11</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">leftbackward</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">PDout(<span class="number">12</span>,<span class="number">0</span>);</span><br><span class="line">PDout(<span class="number">13</span>,<span class="number">1</span>);</span><br><span class="line">PDout(<span class="number">14</span>,<span class="number">0</span>);</span><br><span class="line">PDout(<span class="number">15</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rightbackward</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">PEout(<span class="number">9</span>,<span class="number">0</span>);</span><br><span class="line">PEout(<span class="number">11</span>,<span class="number">1</span>);</span><br><span class="line">PBout(<span class="number">10</span>,<span class="number">0</span>);</span><br><span class="line">PBout(<span class="number">11</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">turnright</span><span class="params">(<span class="type">uint16_t</span> angle)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> dt = (<span class="number">8</span>*angle);</span><br><span class="line">leftforward();</span><br><span class="line">rightbackward();</span><br><span class="line">Delay_ms(dt);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">turnleft</span><span class="params">(<span class="type">uint16_t</span> angle)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> dt = (<span class="number">8</span>*angle);</span><br><span class="line">leftbackward();</span><br><span class="line">rightforward();</span><br><span class="line">Delay_ms(dt);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="视频："><a href="#视频：" class="headerlink" title="视频："></a>视频：</h3><h2 id="任务五"><a href="#任务五" class="headerlink" title="任务五"></a>任务五</h2><h3 id="并联比较型ADC概述"><a href="#并联比较型ADC概述" class="headerlink" title="并联比较型ADC概述"></a>并联比较型ADC概述</h3><p>并联比较型ADC是通过并行比较多个电压输入值，将输入模拟信号转换为数字信号的一种方式，基本思想是同时将输入电压与多个参考电压进行比较，从而快速确定输入电压的数字表示。</p><h3 id="各部分功能"><a href="#各部分功能" class="headerlink" title="各部分功能"></a>各部分功能</h3><ol><li><strong>比较器</strong>：主要功能是将输入的模拟信号与一组预设的参考电压进行比较。比较器输出高电平或低电平，表示输入信号高于或低于参考电压。</li><li><strong>参考电压源</strong>：提供一组稳定的参考电压，通常是从0V到最高输入电压（例如，3.3V或5V）。这组参考电压可以是均匀分布的，帮助比较器进行比较。</li><li><strong>编码器</strong>：根据比较器的输出，将比较结果转换为相应的二进制数字。如果比较器的输出表示有几个高电平，编码器就会确定输入信号的数值。</li><li><strong>触发器</strong>：在完成比较后，触发器用来锁存比较器的结果，确保在ADC转换完成之前，不会受到输入信号变化的影响。</li><li><strong>门电路</strong>：控制ADC的工作状态，例如使能和禁用ADC的功能。</li></ol><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><ol><li><strong>输入信号采样</strong>：首先，ADC从输入信号（模拟电压）进行采样。</li><li><strong>并行比较</strong>：模拟信号会同时与多个参考电压进行比较，由多个比较器并行处理。</li><li><strong>输出编码</strong>：根据比较器的结果，编码器将输出对应的数字信号。</li><li><strong>结果输出</strong>：最终，转换后的数字信号被输出，通常是二进制格式，以供后续数字处理。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>stm32学习笔记003</title>
      <link href="/2024/10/21/stm3203/"/>
      <url>/2024/10/21/stm3203/</url>
      
        <content type="html"><![CDATA[<h2 id="任务（1）：串⼝中断接收回显"><a href="#任务（1）：串⼝中断接收回显" class="headerlink" title="任务（1）：串⼝中断接收回显"></a>任务（1）：串⼝中断接收回显</h2><h3 id="知识学习（技术点介绍——-通信协议-双工模式）"><a href="#知识学习（技术点介绍——-通信协议-双工模式）" class="headerlink" title="知识学习（技术点介绍——&gt;通信协议&#x2F;双工模式）"></a>知识学习（技术点介绍——&gt;通信协议&#x2F;双工模式）</h3><h4 id="通信的目的-协议"><a href="#通信的目的-协议" class="headerlink" title="通信的目的&#x2F;协议"></a>通信的目的&#x2F;协议</h4><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241021105006393.png" alt="image-20241021105006393"></p><ul><li><p>在stm32内部，pwm输出，定时器计数等功能，都是在单片机内部的输出寄存器，数据寄存器实现的</p></li><li><p>在stm32外部，想要使用其他的外挂的芯片，就要与stm32<strong>进行通信</strong></p></li><li><p>协议：双方约定的用于通信的规则</p></li><li><p>USART     TX： Transmit Exchange 数据发送    RX: Receive Exchange 数据接收 </p></li><li><p>I2C            SCL： 时钟          SDA：数据</p></li><li><p>SPI            SCLK：时钟         MOSI：主机输出数据脚       MISO： 主机输入数据脚       CS：片选，用于指定通信对象</p></li><li><p>CAN          CAN-H   CAN_L：两个差分数据脚，用两个引脚表示一个差分的数据</p></li><li><p>USB          DP  DM，或者脚D+   D-, 也是一对差分数据脚</p></li></ul><h4 id="双工模式的区别："><a href="#双工模式的区别：" class="headerlink" title="双工模式的区别："></a>双工模式的区别：</h4><ul><li>全双工：是指通信双方能够同时进行双向通信，一般来说都有两根通信线</li><li>半双工：同一时刻 只能进行单方向的通信 （同一时间下只能进行单向传输，但是不同的时间传输的方向可以不同）</li><li>单工： 无论什么时刻，都只能由一个设备传到另一个设备，不能反着来 （比如把串口的rx引脚去掉，那串口就退化成单工了）</li></ul><h4 id="时钟特性"><a href="#时钟特性" class="headerlink" title="时钟特性"></a>时钟特性</h4><ul><li>如果有单独的时钟信号线，就是同步的，没有就是异步的</li><li>异步相比于同步，只是说两个设备之间时钟的信息（采样频率）不能传递罢了，所以在开始前设置好两者约定的采样频率，并添加帧头帧尾等，进行采样位置的对齐</li></ul><h4 id="电平特性"><a href="#电平特性" class="headerlink" title="电平特性"></a>电平特性</h4><ul><li>单端：单端电平所谓的高低电平，都是相对于gnd的，因此单端通信的双方必须<strong>共地</strong>，因此，前三个通信协议严格来说引脚一栏还要加上GND引脚</li><li>差分：差分信号是通过两个信号的电压差来进行通信的，因此不需要接地（主要是说can，因为usb里面有些东西也是单端信号，还是得接地）</li></ul><h4 id="设备"><a href="#设备" class="headerlink" title="设备"></a>设备</h4><ul><li>点对点：两个设备之间点对点，直接传输就行了</li><li>多设备：支持不止有两个设备之间的通信，可以挂载多个设备，在通信前要进行<strong>寻址</strong>操作，来确定要进行通信的对象</li></ul><h3 id="技术点介绍——-串口通信"><a href="#技术点介绍——-串口通信" class="headerlink" title="技术点介绍——&gt;串口通信"></a>技术点介绍——&gt;串口通信</h3><h5 id="硬件电路接法："><a href="#硬件电路接法：" class="headerlink" title="硬件电路接法："></a>硬件电路接法：</h5><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241021112612894.png" alt="image-20241021112612894" style="zoom: 33%;" /><p>电平标准（使用的主要都是ttl电平）</p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241021112838627.png" alt="image-20241021112838627" style="zoom: 33%;" /><h5 id="串口参数和时序"><a href="#串口参数和时序" class="headerlink" title="串口参数和时序"></a>串口参数和时序</h5><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241021113332364.png" alt="image-20241021113332364"></p><ul><li><p>注意，当串口空闲的时候，始终是高电平，起始位和终止位的作用就是：</p><p>起始位——产生一个下降沿，告诉设备要开始发数据了         </p><p>终止位——产生一个上升沿，标志着这个字节传输完成，同时将电平拉回高电平</p></li><li><p>数据位——低位先行的含义</p><p>假设要发送一个0x0F，第一步，首先把他转化成二进制 00001111 ，然后从低位开始传入，即传入顺序为11110000，产生的波形就是</p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241021113946893.png" alt="image-20241021113946893" style="zoom: 67%;" /><p>当然，接收的一方也是低位先行，产生的波形就是00001111，还是回到了0 x0F</p></li><li><p>校验位：</p><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241021114145525.png" alt="image-20241021114145525"></p></li></ul><p>校验分为奇校验和偶校验，奇校验就是自动补全最后一位，使<strong>数据位</strong>所有位置上的1为奇数个，偶校验是偶数个</p><h5 id="USTAR"><a href="#USTAR" class="headerlink" title="USTAR"></a>USTAR</h5><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241021130136230.png" alt="image-20241021130136230"></p><ul><li><p>最常使用配置：收发器：异步波特率：9600&#x2F;115200数据位长度：8停止位长度：1无校验</p></li><li><p>硬件流控制的意思，就是在rx和tx中还有一根线用于通信，这条线的的信号发射端是接收端设备，默认高电平</p><p>当接收端设备准备好接收的时候，就置低电平，发送端就开始发信号，这样能避免接如果收端性能比较低，还没准备好就接受一堆数据从而出错 ，但是硬件控制流一般也不用</p></li><li><p>usatr资源： usatr1在apb2总线上，usatr2，usatr3在apb1总线上</p></li></ul><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241021181937363.png" alt="image-20241021181937363"></p><p>USTAR基本结构：</p><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241021184406936.png" alt="image-20241021184406936"></p><h5 id="串口通信中的hex模式和文本模式"><a href="#串口通信中的hex模式和文本模式" class="headerlink" title="串口通信中的hex模式和文本模式"></a>串口通信中的hex模式和文本模式</h5><p>hex模式：以原始数据的形式展示</p><p>文本模式：以原始数据编码后的形式显示</p><p>示意图：</p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241022001324298.png" alt="image-20241022001324298" style="zoom: 67%;" /><h3 id="技术点介绍：串⼝-RXNE-中断（如何配置，如何使⽤）"><a href="#技术点介绍：串⼝-RXNE-中断（如何配置，如何使⽤）" class="headerlink" title="技术点介绍：串⼝ RXNE 中断（如何配置，如何使⽤）"></a>技术点介绍：串⼝ RXNE 中断（如何配置，如何使⽤）</h3><h4 id="配置exne中断："><a href="#配置exne中断：" class="headerlink" title="配置exne中断："></a>配置exne中断：</h4><p>配置中断，无非就是把当前蕴含某个可以当做中断事件的外设连接通路到nvic</p><p>比如之前的tim中断，就是使用tim2_it_config函数连接到nvic通路以配置中断</p><p>所以类似的，配置中断的第一步也是，配置usart1到nvic的通路</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">USART_ITConfig(USART1,USART_IT_RXNE,ENABLE);<span class="comment">//这句usatr1的itconfig配置了usatr1到nvic的通路</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>下面就是常规的配置nvic</p><ul><li>先分组，默认一般使用group2</li><li>创建一个nvic初始化结构体，结构体包含channel，cmd，响应优先级和抢占优先级</li><li>channel（通道）：就具体通道而定，配置谁的nvic，就用谁的nvic到自身的通道，比如对于tim2来说，通道就是tim2_irqn,这里对于usart1来说，通道就是usart1_irqn</li><li>cmd：就是个开关，enable即可，两个优先级视情况而定</li><li>最后初始化nvic结构体，并开启usart开关</li></ul><p>关键代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面配置接收中断</span></span><br><span class="line">USART_ITConfig(USART1,USART_IT_RXNE,ENABLE);<span class="comment">//这句usatr1的itconfig配置了usatr1到nvic的通路</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面配置nvic</span></span><br><span class="line">NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);<span class="comment">//先分组</span></span><br><span class="line">NVIC_InitTypeDef NVIC_InitSturcture;</span><br><span class="line">NVIC_InitSturcture.NVIC_IRQChannel = USART1_IRQn; <span class="comment">//配置nvic的irqn通道</span></span><br><span class="line">NVIC_InitSturcture.NVIC_IRQChannelCmd = ENABLE;</span><br><span class="line">NVIC_InitSturcture.NVIC_IRQChannelPreemptionPriority = <span class="number">1</span>;</span><br><span class="line">NVIC_InitSturcture.NVIC_IRQChannelSubPriority = <span class="number">1</span>;</span><br><span class="line">NVIC_Init(&amp;NVIC_InitSturcture);</span><br><span class="line"></span><br><span class="line">USART_Cmd(USART1,ENABLE);<span class="comment">//打开开关</span></span><br></pre></td></tr></table></figure><p>这样，nvic就会自动调用中断函数，当中断函数里我们给出的条件为真时，就能只想我们想要的操作</p><h4 id="使用exne中断："><a href="#使用exne中断：" class="headerlink" title="使用exne中断："></a>使用exne中断：</h4><p>中断执行时最核心的代码就是中断执行函数：USART1_IRQHandler</p><p>因此我们配置一个判断条件，这里想用exne是否为真来进行判断，所以条件应设为</p><p>if(USART_GetITStatus(USART1,USART_IT_RXNE)&#x3D;&#x3D; SET)</p><p>如果这个条件为真，那么说明计算机向单片机发送了数据，我们此时的任务是<strong>接受这个数据，并把它回显到计算机上</strong>，那在中断函数中，我们可以设置一个标志位来标志单片机接收到了数据，再设置一个临时变量用于存储接收到的数据，在主函数中，如果标志位为真，那就把数据拿出来并发送到计算机上</p><p>在serial.c中，设置两个临时变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint8_t</span> Serial_RxData;</span><br><span class="line"><span class="type">uint8_t</span> Serial_RxFlag;</span><br></pre></td></tr></table></figure><p>两个封装函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint8_t</span> <span class="title function_">Serial_GetRxFlag</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(Serial_RxFlag == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">Serial_RxFlag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">Serial_GetRxData</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> Serial_RxData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并按照我们的设想配置中断函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">USART1_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(USART_GetITStatus(USART1,USART_IT_RXNE)== SET)</span><br><span class="line">&#123;</span><br><span class="line">Serial_RxData = USART_ReceiveData(USART1);</span><br><span class="line">Serial_RxFlag = <span class="number">1</span>;</span><br><span class="line">USART_ClearITPendingBit(USART1,USART_IT_RXNE);<span class="comment">//清除标志位</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们就只需要在主函数中不断检查flag是否为1，如果为1，设置一个临时变量，并将它赋值为getrxdata函数的返回值，然后将这个返回值发回计算机，即可完成</p><p>主函数内关键代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint8_t</span> RxData;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">OLED_Init();</span><br><span class="line">Serial_Init();</span><br><span class="line">Serial_Printf(<span class="string">&quot;num is %d&quot;</span>,<span class="number">10</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(Serial_GetRxFlag() == <span class="number">1</span>)<span class="comment">//判断flag是否为1</span></span><br><span class="line">&#123;</span><br><span class="line">RxData = Serial_GetRxData();<span class="comment">//是的话，获取信息</span></span><br><span class="line">Serial_Printf(<span class="string">&quot;%c&quot;</span>,RxData);<span class="comment">//回显</span></span><br><span class="line">OLED_ShowHexNum(<span class="number">1</span>,<span class="number">1</span>,RxData,<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>serial.c总代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> Serial_RxData;</span><br><span class="line"><span class="type">uint8_t</span> Serial_RxFlag;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1,ENABLE);<span class="comment">//USATR1在APB2总线上</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line"></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; <span class="comment">//tx设置为复用推挽输出</span></span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;</span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU; <span class="comment">//rx设置为上拉输入（输入不存在复用不复用的，因为输出只能有一个，但是输入可以有多个）</span></span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;</span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">USART_InitTypeDef USART_InitStructure;</span><br><span class="line">USART_InitStructure.USART_BaudRate = <span class="number">9600</span>; <span class="comment">//设置波特率</span></span><br><span class="line">USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None; <span class="comment">//设置没有硬件流控制</span></span><br><span class="line">USART_InitStructure.USART_Mode = USART_Mode_Rx|USART_Mode_Tx; <span class="comment">//设置模式为rx和tx都用</span></span><br><span class="line">USART_InitStructure.USART_Parity = USART_Parity_No; <span class="comment">//设置不进行奇偶校验</span></span><br><span class="line">USART_InitStructure.USART_StopBits = USART_StopBits_1;<span class="comment">//设置终止位长度位1</span></span><br><span class="line">USART_InitStructure.USART_WordLength = USART_WordLength_8b;<span class="comment">//设置数据长度为8位</span></span><br><span class="line"></span><br><span class="line">USART_Init(USART1,&amp;USART_InitStructure);<span class="comment">//初始化</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面配置接收中断</span></span><br><span class="line">USART_ITConfig(USART1,USART_IT_RXNE,ENABLE);<span class="comment">//这句usatr1的itconfig配置了usatr1到nvic的通路</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面配置nvic</span></span><br><span class="line">NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);<span class="comment">//先分组</span></span><br><span class="line">NVIC_InitTypeDef NVIC_InitSturcture;</span><br><span class="line">NVIC_InitSturcture.NVIC_IRQChannel = USART1_IRQn; <span class="comment">//配置nvic的irqn通道</span></span><br><span class="line">NVIC_InitSturcture.NVIC_IRQChannelCmd = ENABLE;</span><br><span class="line">NVIC_InitSturcture.NVIC_IRQChannelPreemptionPriority = <span class="number">1</span>;</span><br><span class="line">NVIC_InitSturcture.NVIC_IRQChannelSubPriority = <span class="number">1</span>;</span><br><span class="line">NVIC_Init(&amp;NVIC_InitSturcture);</span><br><span class="line"></span><br><span class="line">USART_Cmd(USART1,ENABLE);<span class="comment">//打开开关</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">Serial_GetRxFlag</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(Serial_RxFlag == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">Serial_RxFlag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">Serial_GetRxData</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> Serial_RxData;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART1_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(USART_GetITStatus(USART1,USART_IT_RXNE)== SET)</span><br><span class="line">&#123;</span><br><span class="line">Serial_RxData = USART_ReceiveData(USART1);</span><br><span class="line">Serial_RxFlag = <span class="number">1</span>;</span><br><span class="line">USART_ClearITPendingBit(USART1,USART_IT_RXNE);<span class="comment">//清除标志位</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendByte</span><span class="params">(<span class="type">uint8_t</span> Byte)</span></span><br><span class="line">&#123;</span><br><span class="line">USART_SendData(USART1,Byte);</span><br><span class="line"><span class="keyword">while</span>(USART_GetFlagStatus(USART1,USART_FLAG_TXE) == RESET);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendArray</span><span class="params">(<span class="type">uint8_t</span> *Array,<span class="type">uint16_t</span> length)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint16_t</span> i;</span><br><span class="line"><span class="keyword">for</span>(i =<span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">&#123;</span><br><span class="line">Serial_SendByte(Array[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendString</span><span class="params">(<span class="type">char</span>* String)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint8_t</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;String[i]!=<span class="number">0</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">Serial_SendByte(String[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">Serial_Pow</span><span class="params">(<span class="type">uint32_t</span> X, <span class="type">uint32_t</span> Y)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint32_t</span> Result = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (Y --)</span><br><span class="line">&#123;</span><br><span class="line">Result *= X;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> Result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendNumber</span><span class="params">(<span class="type">uint32_t</span> Number, <span class="type">uint8_t</span> Length)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint8_t</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; Length; i ++)</span><br><span class="line">&#123;</span><br><span class="line">Serial_SendByte(Number / Serial_Pow(<span class="number">10</span>, Length - i - <span class="number">1</span>) % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> ch, FILE *f)</span></span><br><span class="line">&#123;</span><br><span class="line">Serial_SendByte(ch);<span class="comment">//将printf的底层重定向到自己的发送字节函数</span></span><br><span class="line"><span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_Printf</span><span class="params">(<span class="type">char</span> *format, ...)</span><span class="comment">//多参数</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> String[<span class="number">100</span>];</span><br><span class="line">va_list arg;</span><br><span class="line">va_start(arg, format);</span><br><span class="line"><span class="built_in">vsprintf</span>(String, format, arg);</span><br><span class="line">va_end(arg);</span><br><span class="line">Serial_SendString(String);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="视频演示："><a href="#视频演示：" class="headerlink" title="视频演示："></a>视频演示：</h3><h2 id="2-任务二：串口控制LED亮灭"><a href="#2-任务二：串口控制LED亮灭" class="headerlink" title="(2)任务二：串口控制LED亮灭"></a>(2)任务二：串口控制LED亮灭</h2><h3 id="技术点介绍-：串⼝-RXNE-中断（如何利⽤读取到的数据）"><a href="#技术点介绍-：串⼝-RXNE-中断（如何利⽤读取到的数据）" class="headerlink" title="技术点介绍 ：串⼝ RXNE 中断（如何利⽤读取到的数据）"></a>技术点介绍 ：串⼝ RXNE 中断（如何利⽤读取到的数据）</h3><h4 id="使用数据包获取输入的数据："><a href="#使用数据包获取输入的数据：" class="headerlink" title="使用数据包获取输入的数据："></a>使用数据包获取输入的数据：</h4><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241023161552791.png" alt="image-20241023161552791"></p><h5 id="1-什么是数据包？"><a href="#1-什么是数据包？" class="headerlink" title="1. 什么是数据包？"></a>1. 什么是数据包？</h5><p>在串口通信中，数据包是用来传输有结构的数据的一种“包装”。它就像寄快递一样，把我们要传输的信息（比如控制命令或传感器数据）装进一个“包裹”里，再通过串口把这个包裹从上位机（比如电脑）发到单片机（STM32）。数据包是为了让双方清楚地知道，传过来的这些数据是什么意思，如何处理，如何检查有没有出错。</p><h5 id="2-数据包的基本组成"><a href="#2-数据包的基本组成" class="headerlink" title="2. 数据包的基本组成"></a>2. 数据包的基本组成</h5><p>一个标准的数据包一般包括以下部分：</p><ol><li><strong>起始符</strong>：告诉接收端，“数据要开始了！”。这是一个特殊的字符或字节</li><li><strong>数据字段</strong>：这里才是实际有用的信息，可能是传感器的数据、控制命令或者状态反馈。数据字段可以是一个字节或多个字节。</li><li><strong>结束符</strong>：告诉接收端，“数据传完了！”。常用的结束符也是一个特定字符，</li><li>有时候，结束符前面还可以加个校验符</li></ol><p><strong>例子</strong>：假设你想通过串口传递两个字节的数据，我们可以构造一个简单的数据包：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">起始符@| 数据<span class="number">1</span>| 数据<span class="number">2</span>| 结束符 $</span><br></pre></td></tr></table></figure><p>在这个例子中：</p><ul><li><strong>@</strong> 是起始符</li><li>数据1 和 数据2 是实际要传输的数据</li><li><strong>$</strong> 是结束符</li></ul><h5 id="3-为什么要使用数据包？有什么好处？"><a href="#3-为什么要使用数据包？有什么好处？" class="headerlink" title="3. 为什么要使用数据包？有什么好处？"></a>3. 为什么要使用数据包？有什么好处？</h5><ul><li><strong>数据有序传输，避免混乱</strong>,串口通信是<strong>逐个字节</strong>地传输数据。如果没有数据包的概念，单片机无法知道接收到的某些字节到底是什么——是开始的命令还是中途传过来的数据？使用数据包后，起始符和结束符让STM32清楚地知道数据从哪里开始、哪里结束，避免了数据混乱。</li></ul><h5 id="4-使用数据包的步骤"><a href="#4-使用数据包的步骤" class="headerlink" title="4. 使用数据包的步骤"></a>4. 使用数据包的步骤</h5><p><strong>(1) 构造数据包并发送</strong></p><ul><li>上位机（比如电脑）根据预定好的格式，构造一个数据包。假如你想控制一个灯的亮灭，可以构造一个数据包，里面包括：设备ID（代表灯）、控制命令（开或关），以及校验位来保证数据没有出错。</li></ul><p><strong>(2) 接收数据包</strong></p><ul><li>STM32 会通过串口接收数据。在接收到数据时，它首先要找到起始符，确定这是一个新的数据包，然后开始接收后面的数据字段。如果有校验位，还能通过他来检查数据是否正确。</li></ul><p><strong>(4) 执行相应操作</strong></p><ul><li>解析完成后，STM32可以根据数据字段中的命令，执行对应的操作，比如打开或关闭灯，读取传感器数据等。</li></ul><h4 id="画状态机进行程序设计"><a href="#画状态机进行程序设计" class="headerlink" title="画状态机进行程序设计"></a>画状态机进行程序设计</h4><p><strong>在设计程序的时候，可以利用状态机来画出程序的流程，来理清逻辑</strong>，如下便是文本数据包接收的状态机示意图:</p><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241023162516302.png" alt="image-20241023162516302"></p><h4 id="rxne中断的实现："><a href="#rxne中断的实现：" class="headerlink" title="rxne中断的实现："></a>rxne中断的实现：</h4><p><strong>核心：</strong></p><p>同任务一，中断执行时最核心的代码依然是是中断执行函数：USART1_IRQHandler，我们所需要的中断后引发的功能要在这里面配置</p><p><strong>方法：</strong></p><p>要想让stm32通过接收 ledoff 和ledon 来进行相应的操作，无非是把任务1接收数字的地方改成接收字符串数据包即可，接收数据包的程序按照状态机的画法设计，接收到数据以后，与LEDOFF LEDON这两个字符串进行比对，如果是同一个字符串，那就执行相应操作，对不上号的话就返回error</p><h5 id="总结一下步骤："><a href="#总结一下步骤：" class="headerlink" title="总结一下步骤："></a>总结一下步骤：</h5><ol><li>使能usart1时钟，gpio时钟，配置好gpio和usatr1的初始化结构体</li><li>使用usatr的itconfig函数打通rxne到nvic的通路</li><li>配置好nvic，设置好中断参数</li><li>编写USART1_IRQHandler函数，把中断函数执行步骤写好</li></ol><h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><h4 id="库函数："><a href="#库函数：" class="headerlink" title="库函数："></a>库函数：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> Serial_RxPacket[<span class="number">100</span>];<span class="comment">//数据包数组</span></span><br><span class="line"><span class="type">uint8_t</span> Serial_RxFlag;<span class="comment">//数据包接受标志位</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1,ENABLE);<span class="comment">//USATR1在APB2总线上</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line"></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; <span class="comment">//tx设置为复用推挽输出</span></span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;</span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU; <span class="comment">//rx设置为上拉输入（输入不存在复用不复用的，因为输出只能有一个，但是输入可以有多个）</span></span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;</span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">USART_InitTypeDef USART_InitStructure;</span><br><span class="line">USART_InitStructure.USART_BaudRate = <span class="number">9600</span>; <span class="comment">//设置波特率</span></span><br><span class="line">USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None; <span class="comment">//设置没有硬件流控制</span></span><br><span class="line">USART_InitStructure.USART_Mode = USART_Mode_Rx|USART_Mode_Tx; <span class="comment">//设置模式为rx和tx都用</span></span><br><span class="line">USART_InitStructure.USART_Parity = USART_Parity_No; <span class="comment">//设置不进行奇偶校验</span></span><br><span class="line">USART_InitStructure.USART_StopBits = USART_StopBits_1;<span class="comment">//设置终止位长度位1</span></span><br><span class="line">USART_InitStructure.USART_WordLength = USART_WordLength_8b;<span class="comment">//设置数据长度为8位</span></span><br><span class="line"></span><br><span class="line">USART_Init(USART1,&amp;USART_InitStructure);<span class="comment">//初始化</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面配置接收中断</span></span><br><span class="line">USART_ITConfig(USART1,USART_IT_RXNE,ENABLE);<span class="comment">//这句usatr1的itconfig配置了usatr1到nvic的通路</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面配置nvic</span></span><br><span class="line">NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);<span class="comment">//先分组</span></span><br><span class="line">NVIC_InitTypeDef NVIC_InitSturcture;</span><br><span class="line">NVIC_InitSturcture.NVIC_IRQChannel = USART1_IRQn; <span class="comment">//配置nvic的irqn通道</span></span><br><span class="line">NVIC_InitSturcture.NVIC_IRQChannelCmd = ENABLE;</span><br><span class="line">NVIC_InitSturcture.NVIC_IRQChannelPreemptionPriority = <span class="number">1</span>;</span><br><span class="line">NVIC_InitSturcture.NVIC_IRQChannelSubPriority = <span class="number">1</span>;</span><br><span class="line">NVIC_Init(&amp;NVIC_InitSturcture);</span><br><span class="line"></span><br><span class="line">USART_Cmd(USART1,ENABLE);<span class="comment">//打开开关</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">Serial_GetRxFlag</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(Serial_RxFlag == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">Serial_RxFlag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART1_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> RxState = <span class="number">0</span>;<span class="comment">//当前状态机状态的静态变量，出函数之后不会销毁，下次用的时候保持上次用最后的值</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> pRxPacket = <span class="number">0</span>;<span class="comment">//当前接收数据位置的静态变量</span></span><br><span class="line"><span class="keyword">if</span> (USART_GetITStatus(USART1, USART_IT_RXNE) == SET)<span class="comment">//是否是USART1的接收触发中断</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint8_t</span> RxData = USART_ReceiveData(USART1);<span class="comment">//读取数据寄存器，存放在接收的数据变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//根据状态机画的图编写下面的程序：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//rxstate为0，接收数据包包头</span></span><br><span class="line"><span class="keyword">if</span> (RxState == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (RxData == <span class="string">&#x27;@&#x27;</span> &amp;&amp; Serial_RxFlag == <span class="number">0</span>)<span class="comment">//数据是包头，并且上一个数据包已处理完了</span></span><br><span class="line">&#123;</span><br><span class="line">RxState = <span class="number">1</span>;<span class="comment">//下面接受数据</span></span><br><span class="line">pRxPacket = <span class="number">0</span>;<span class="comment">//数据包的位置归零，开始挨个往里塞</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//restate为1，接收数据包数据，同时判断是否接收到了第一个包尾</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (RxState == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (RxData == <span class="string">&#x27;\r&#x27;</span>)<span class="comment">//如果收到第一个包尾</span></span><br><span class="line">&#123;</span><br><span class="line">RxState = <span class="number">2</span>;<span class="comment">//置下一个状态</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//接收到了正常的数据</span></span><br><span class="line">&#123;</span><br><span class="line">Serial_RxPacket[pRxPacket] = RxData;<span class="comment">//数据存入数据包数组的对应的位置</span></span><br><span class="line">pRxPacket ++;<span class="comment">//标记下一次该存放的位置</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//rxstate为2，接收数据包第二个包尾</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (RxState == <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (RxData == <span class="string">&#x27;\n&#x27;</span>)<span class="comment">//如果收到第二个包尾</span></span><br><span class="line">&#123;</span><br><span class="line">RxState = <span class="number">0</span>;<span class="comment">//状态归0</span></span><br><span class="line">Serial_RxPacket[pRxPacket] = <span class="string">&#x27;\0&#x27;</span>;<span class="comment">//将收到的字符数据包添加一个字符串结束标志（不然不会自带）</span></span><br><span class="line">Serial_RxFlag = <span class="number">1</span>;<span class="comment">//rxflag为1，成功接收一个数据包</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">USART_ClearITPendingBit(USART1, USART_IT_RXNE);<span class="comment">//清除标志位</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="主函数"><a href="#主函数" class="headerlink" title="主函数;"></a>主函数;</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>      <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;LED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;DELAY.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Serial.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Oled.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;LED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;string.h&quot;</span></span></span><br><span class="line"><span class="type">uint8_t</span> RxData;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">OLED_Init();</span><br><span class="line">LED_Init(<span class="number">1</span>);</span><br><span class="line">Serial_Init();</span><br><span class="line">Serial_Printf(<span class="string">&quot;num is %d&quot;</span>,<span class="number">10</span>);</span><br><span class="line">OLED_ShowString(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;TxPacket&quot;</span>);</span><br><span class="line">OLED_ShowString(<span class="number">3</span>, <span class="number">1</span>, <span class="string">&quot;RxPacket&quot;</span>);</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (Serial_RxFlag == <span class="number">1</span>)<span class="comment">//如果接收到数据包</span></span><br><span class="line">&#123;</span><br><span class="line">OLED_ShowString(<span class="number">4</span>, <span class="number">1</span>, <span class="string">&quot;                &quot;</span>);<span class="comment">//OLED清除原有的显示</span></span><br><span class="line">OLED_ShowString(<span class="number">4</span>, <span class="number">1</span>, Serial_RxPacket);<span class="comment">//显示接收到的数据包</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将收到的数据包进行字符串比对，执行对应操作</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(Serial_RxPacket, <span class="string">&quot;LEDON&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">LED_ON(<span class="number">1</span>);</span><br><span class="line">Serial_SendString(<span class="string">&quot;LEDONOK\r\n&quot;</span>);</span><br><span class="line">OLED_ShowString(<span class="number">2</span>, <span class="number">1</span>, <span class="string">&quot;                &quot;</span>);</span><br><span class="line">OLED_ShowString(<span class="number">2</span>, <span class="number">1</span>, <span class="string">&quot;LEDONOK&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(Serial_RxPacket, <span class="string">&quot;LEDOFF&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">LED_OFF(<span class="number">1</span>);</span><br><span class="line">Serial_SendString(<span class="string">&quot;LEDOFFOK\r\n&quot;</span>);</span><br><span class="line">OLED_ShowString(<span class="number">2</span>, <span class="number">1</span>, <span class="string">&quot;                &quot;</span>);</span><br><span class="line">OLED_ShowString(<span class="number">2</span>, <span class="number">1</span>, <span class="string">&quot;LEDOFFOK&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//输入不是我们指定的格式</span></span><br><span class="line">&#123;</span><br><span class="line">Serial_SendString(<span class="string">&quot;ERROR\r\n&quot;</span>);</span><br><span class="line">OLED_ShowString(<span class="number">2</span>, <span class="number">1</span>, <span class="string">&quot;                &quot;</span>);</span><br><span class="line">OLED_ShowString(<span class="number">2</span>, <span class="number">1</span>, <span class="string">&quot;ERROR&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Serial_RxFlag = <span class="number">0</span>;<span class="comment">//将接收数据包标志位清零，否则无法接收后续数据包</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="实现视频："><a href="#实现视频：" class="headerlink" title="实现视频："></a>实现视频：</h3><h2 id="任务（3）：通过串⼝调整LED闪烁频率"><a href="#任务（3）：通过串⼝调整LED闪烁频率" class="headerlink" title="任务（3）：通过串⼝调整LED闪烁频率"></a>任务（3）：通过串⼝调整LED闪烁频率</h2><h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p><strong>相比于任务二，无非是改变一下中断事件，这个事件就是改变一个float变量而已</strong></p><p>这个float变量范围取值0-3，精度0.1</p><p>当然，涉及到时间就要配置一下tim计时器来结合使用</p><p>我们搬出之前秒计时器的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Timer_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2,ENABLE);<span class="comment">//使能时钟</span></span><br><span class="line"></span><br><span class="line">TIM_InternalClockConfig(TIM2);</span><br><span class="line"></span><br><span class="line">TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;</span><br><span class="line">TIM_TimeBaseInitStructure.TIM_ClockDivision=TIM_CKD_DIV1; <span class="comment">//ָ设置时钟分频（1分频）</span></span><br><span class="line">TIM_TimeBaseInitStructure.TIM_CounterMode=TIM_CounterMode_Up; <span class="comment">//向上计数</span></span><br><span class="line">TIM_TimeBaseInitStructure.TIM_Period=<span class="number">10000</span><span class="number">-1</span>;</span><br><span class="line">TIM_TimeBaseInitStructure.TIM_Prescaler=<span class="number">7200</span><span class="number">-1</span>; <span class="comment">//72mzh / 7200 = 10k ,72mhz / 7200 = 10k</span></span><br><span class="line">TIM_TimeBaseInitStructure.TIM_RepetitionCounter=<span class="number">0</span>;<span class="comment">//重复计数（高级计时器有，现在不用）</span></span><br><span class="line">TIM_TimeBaseInit(TIM2,&amp;TIM_TimeBaseInitStructure);</span><br><span class="line"></span><br><span class="line">TIM_ClearFlag(TIM2,TIM_FLAG_Update); <span class="comment">//清除TIM2的更新中断标志位，确保定时器开始时没有残留的中断标志</span></span><br><span class="line"></span><br><span class="line">TIM_ITConfig(TIM2,TIM_IT_Update,ENABLE);<span class="comment">//开启更新中断到nvic通路</span></span><br><span class="line"></span><br><span class="line">NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);</span><br><span class="line">NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line"><span class="comment">//省略</span></span><br><span class="line">NVIC_Init(&amp;NVIC_InitStructure);</span><br><span class="line">TIM_Cmd(TIM2,ENABLE);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于周期的设定，<strong>核心代码</strong>就是这两个：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TIM_TimeBaseInitStructure.TIM_Period=<span class="number">10000</span><span class="number">-1</span>;</span><br><span class="line">TIM_TimeBaseInitStructure.TIM_Prescaler=<span class="number">7200</span><span class="number">-1</span>; <span class="comment">//72mzh / 7200 = 10k ,72mhz / 7200 = 10k</span></span><br></pre></td></tr></table></figure><p>上面一行是arr（自动重装计数值），下面一行是把72mhz<strong>分成7200份</strong></p><p>如果说上面是10000的话，那周期就是1秒，如果把上面改成5k，那周期就是0.5秒</p><p><strong>因此，我们可以通过只修改arr来实现改变周期</strong></p><p>修改arr的函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_SetAutoreload</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> Autoreload)</span>;</span><br></pre></td></tr></table></figure><p>动态修改 TIM_Period：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 修改自动重装载值</span><br><span class="line">TIM_SetAutoreload(TIM2, new_arr);</span><br><span class="line"></span><br><span class="line">// 触发更新事件，让新的ARR值立即生效</span><br><span class="line">TIM_GenerateEvent(TIM2, TIM_EventSource_Update);</span><br></pre></td></tr></table></figure><h4 id="串口中断，tim中断："><a href="#串口中断，tim中断：" class="headerlink" title="串口中断，tim中断："></a>串口中断，tim中断：</h4><p>串口中断：</p><p>源于上位机的信息输入，中断后引起事件——tim2计时器周期修改</p><p>tim中断：</p><p>源于自增计数器达到预设值，中断后引起事件——开关led</p><h3 id="二者的配合："><a href="#二者的配合：" class="headerlink" title="二者的配合："></a>二者的配合：</h3><p>将这个程序的执行过程提炼出来，就是：</p><p>启用tim2计时器，启用usart1</p><p>——&gt;把tim2的自动重装计数事件连接到NVIC，把usart1的rxne事件连接到NVIC</p><p>——&gt;配置tim2的中断事件为亮灯灭灯，rxne的中断事件配置为 <strong>更改tim2计数器的周期</strong></p><p>——&gt;配置usart1的串口输入参数，配置好它的接收数据包格式</p><p>——&gt;在主函数中整合计算，分拣数据，实现功能</p><p>serial.c:</p><h3 id="代码实现：-1"><a href="#代码实现：-1" class="headerlink" title="代码实现："></a>代码实现：</h3><h4 id="库函数"><a href="#库函数" class="headerlink" title="库函数"></a>库函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> Serial_RxPacket[<span class="number">100</span>];<span class="comment">//数据包数组</span></span><br><span class="line"><span class="type">uint8_t</span> Serial_RxFlag;<span class="comment">//数据包接受标志位</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1,ENABLE);<span class="comment">//USATR1在APB2总线上</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line"></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; <span class="comment">//tx设置为复用推挽输出</span></span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;</span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU; <span class="comment">//rx设置为上拉输入（输入不存在复用不复用的，因为输出只能有一个，但是输入可以有多个）</span></span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;</span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">USART_InitTypeDef USART_InitStructure;</span><br><span class="line">USART_InitStructure.USART_BaudRate = <span class="number">9600</span>; <span class="comment">//设置波特率</span></span><br><span class="line">USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None; <span class="comment">//设置没有硬件流控制</span></span><br><span class="line">USART_InitStructure.USART_Mode = USART_Mode_Rx|USART_Mode_Tx; <span class="comment">//设置模式为rx和tx都用</span></span><br><span class="line">USART_InitStructure.USART_Parity = USART_Parity_No; <span class="comment">//设置不进行奇偶校验</span></span><br><span class="line">USART_InitStructure.USART_StopBits = USART_StopBits_1;<span class="comment">//设置终止位长度位1</span></span><br><span class="line">USART_InitStructure.USART_WordLength = USART_WordLength_8b;<span class="comment">//设置数据长度为8位</span></span><br><span class="line"></span><br><span class="line">USART_Init(USART1,&amp;USART_InitStructure);<span class="comment">//初始化</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面配置接收中断</span></span><br><span class="line">USART_ITConfig(USART1,USART_IT_RXNE,ENABLE);<span class="comment">//这句usatr1的itconfig配置了usatr1到nvic的通路</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面配置nvic</span></span><br><span class="line">NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);<span class="comment">//先分组</span></span><br><span class="line">NVIC_InitTypeDef NVIC_InitSturcture;</span><br><span class="line">NVIC_InitSturcture.NVIC_IRQChannel = USART1_IRQn; <span class="comment">//配置nvic的irqn通道</span></span><br><span class="line">NVIC_InitSturcture.NVIC_IRQChannelCmd = ENABLE;</span><br><span class="line">NVIC_InitSturcture.NVIC_IRQChannelPreemptionPriority = <span class="number">1</span>;</span><br><span class="line">NVIC_InitSturcture.NVIC_IRQChannelSubPriority = <span class="number">1</span>;</span><br><span class="line">NVIC_Init(&amp;NVIC_InitSturcture);</span><br><span class="line"></span><br><span class="line">USART_Cmd(USART1,ENABLE);<span class="comment">//打开开关</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">Serial_GetRxFlag</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(Serial_RxFlag == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">Serial_RxFlag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART1_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> RxState = <span class="number">0</span>;<span class="comment">//当前状态机状态的静态变量，出函数之后不会销毁，下次用的时候保持上次用最后的值</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> pRxPacket = <span class="number">0</span>;<span class="comment">//当前接收数据位置的静态变量</span></span><br><span class="line"><span class="keyword">if</span> (USART_GetITStatus(USART1, USART_IT_RXNE) == SET)<span class="comment">//是否是USART1的接收触发中断</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint8_t</span> RxData = USART_ReceiveData(USART1);<span class="comment">//读取数据寄存器，存放在接收的数据变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//根据状态机画的图编写下面的程序：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//rxstate为0，接收数据包包头</span></span><br><span class="line"><span class="keyword">if</span> (RxState == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (RxData == <span class="string">&#x27;@&#x27;</span> &amp;&amp; Serial_RxFlag == <span class="number">0</span>)<span class="comment">//数据是包头，并且上一个数据包已处理完了</span></span><br><span class="line">&#123;</span><br><span class="line">RxState = <span class="number">1</span>;<span class="comment">//下面接受数据</span></span><br><span class="line">pRxPacket = <span class="number">0</span>;<span class="comment">//数据包的位置归零，开始挨个往里塞</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//restate为1，接收数据包数据，同时判断是否接收到了第一个包尾</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (RxState == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (RxData == <span class="string">&#x27;\r&#x27;</span>)<span class="comment">//如果收到第一个包尾</span></span><br><span class="line">&#123;</span><br><span class="line">RxState = <span class="number">2</span>;<span class="comment">//置下一个状态</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//接收到了正常的数据</span></span><br><span class="line">&#123;</span><br><span class="line">Serial_RxPacket[pRxPacket] = RxData;<span class="comment">//数据存入数据包数组的对应的位置</span></span><br><span class="line">pRxPacket ++;<span class="comment">//标记下一次该存放的位置</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//rxstate为2，接收数据包第二个包尾</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (RxState == <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (RxData == <span class="string">&#x27;\n&#x27;</span>)<span class="comment">//如果收到第二个包尾</span></span><br><span class="line">&#123;</span><br><span class="line">RxState = <span class="number">0</span>;<span class="comment">//状态归0</span></span><br><span class="line">Serial_RxPacket[pRxPacket] = <span class="string">&#x27;\0&#x27;</span>;<span class="comment">//将收到的字符数据包添加一个字符串结束标志（不然不会自带）</span></span><br><span class="line">Serial_RxFlag = <span class="number">1</span>;<span class="comment">//rxflag为1，成功接收一个数据包</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">USART_ClearITPendingBit(USART1, USART_IT_RXNE);<span class="comment">//清除标志位</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="主函数："><a href="#主函数：" class="headerlink" title="主函数："></a>主函数：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>      <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;LED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;DELAY.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Serial.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Oled.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;LED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;string.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Timer.h&quot;</span></span></span><br><span class="line"><span class="type">uint8_t</span> RxData;</span><br><span class="line"><span class="type">uint8_t</span> ledstate = <span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM2_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(TIM_GetITStatus(TIM2,TIM_IT_Update) == SET)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(ledstate == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">ledstate = <span class="number">1</span>;</span><br><span class="line">LED_ON(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">ledstate = <span class="number">0</span>;</span><br><span class="line">LED_OFF(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">TIM_ClearITPendingBit(TIM2,TIM_IT_Update);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">OLED_Init();</span><br><span class="line">LED_Init(<span class="number">1</span>);</span><br><span class="line">Serial_Init();</span><br><span class="line">Timer_Init();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (Serial_RxFlag == <span class="number">1</span>)<span class="comment">//如果接收到数据包</span></span><br><span class="line">&#123;</span><br><span class="line">OLED_ShowString(<span class="number">1</span>,<span class="number">1</span>,<span class="string">&quot;num:&quot;</span>);</span><br><span class="line">OLED_ShowString(<span class="number">1</span>,<span class="number">6</span>,Serial_RxPacket);</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> tempint = Serial_RxPacket[<span class="number">0</span>]<span class="number">-48</span>;</span><br><span class="line"><span class="type">float</span> tempflo = Serial_RxPacket[<span class="number">2</span>]<span class="number">-48</span>;</span><br><span class="line"><span class="type">int</span> arraylength = <span class="built_in">strlen</span>(Serial_RxPacket);</span><br><span class="line"><span class="keyword">if</span>(((Serial_RxPacket[<span class="number">1</span>]!=<span class="string">&#x27;.&#x27;</span> &amp;&amp; Serial_RxPacket[<span class="number">1</span>]==<span class="string">&#x27;0&#x27;</span>)&amp;&amp;(arraylength&gt;<span class="number">1</span>))||arraylength&gt;<span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line">OLED_ShowString(<span class="number">3</span>,<span class="number">1</span>,<span class="string">&quot;error input&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> arrtemp = <span class="number">10000</span>*(tempint + tempflo*<span class="number">0.1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(arrtemp&gt;<span class="number">0</span>&amp;&amp;arrtemp&lt;=<span class="number">30000</span>)</span><br><span class="line">&#123;OLED_ShowNum(<span class="number">2</span>,<span class="number">1</span>,arrtemp,<span class="number">8</span>);</span><br><span class="line">OLED_ShowString(<span class="number">3</span>,<span class="number">1</span>,<span class="string">&quot;valid input&quot;</span>);</span><br><span class="line"><span class="comment">// 修改自动重装载值</span></span><br><span class="line">TIM_SetAutoreload(TIM2, arrtemp<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发更新事件，让新的ARR值立即生效</span></span><br><span class="line">TIM_GenerateEvent(TIM2, TIM_EventSource_Update);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">OLED_ShowString(<span class="number">3</span>,<span class="number">1</span>,<span class="string">&quot;error input&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Serial_RxFlag = <span class="number">0</span>;<span class="comment">//将接收数据包标志位清零，否则无法接收后续数据包</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="视频效果："><a href="#视频效果：" class="headerlink" title="视频效果："></a>视频效果：</h3><h2 id="任务-4-Debug-功能和使⽤"><a href="#任务-4-Debug-功能和使⽤" class="headerlink" title="任务(4) Debug 功能和使⽤"></a>任务(4) Debug 功能和使⽤</h2><h3 id="debug功能简记"><a href="#debug功能简记" class="headerlink" title="debug功能简记"></a>debug功能简记</h3><h4 id="1-进入-Debug-模式"><a href="#1-进入-Debug-模式" class="headerlink" title="1. 进入 Debug 模式"></a>1. 进入 Debug 模式</h4><ol><li><strong>编译项目</strong>：<ul><li>在菜单栏中，点击 <strong>“Project”</strong> -&gt; **”Build Target”**（或直接点击工具栏中的小锤子图标）。</li></ul></li><li><strong>进入 Debug 模式</strong>：<ul><li>点击工具栏中的 <strong>“Debug”</strong> 按钮（一个带有小虫子的图标），或从菜单中选择 <strong>“Debug”</strong> -&gt; **”Start&#x2F;Stop Debug Session”**。</li></ul></li></ol><h4 id="2-复位-MCU"><a href="#2-复位-MCU" class="headerlink" title="2. 复位 MCU"></a>2. 复位 MCU</h4><ul><li><p>复位</p><p>在 Debug 界面上，找到工具栏中的 <strong>“Reset”</strong> 按钮<img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241023222235399.png" alt="image-20241023222235399">，点击该按钮即可复位</p></li></ul><h4 id="3-调试运行模式"><a href="#3-调试运行模式" class="headerlink" title="3. 调试运行模式"></a>3. 调试运行模式</h4><p>在调试模式下，有以下按钮在上方工具栏：</p><ul><li><p><strong>全速运行（F5）</strong>：</p><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241023222252338.png" alt="image-20241023222252338">这个按钮将使程序一直处于运行状态,或者直接运行到设置的断点处。</p></li><li><p><strong>单步执行</strong>：</p><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241023222301550.png" alt="image-20241023222301550">点每点一次按钮，程序运行一步，遇到函数会进入函数执行</p></li><li><p><strong>逐行调试</strong>：</p><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241023222336782.png" alt="image-20241023222336782">每点一次按钮，程序运行一行，遇到函数<strong>跳过函数执行</strong></p></li><li><p><strong>跳出调试</strong>：</p><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241023222437618.png" alt="image-20241023222437618">在代码中找到你想运行到的行，右键点击该行，然后选择 **”Run to Cursor”**。</p></li><li><p><strong>运行到光标处</strong>：</p><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241023222526194.png" alt="image-20241023222526194">直接运行到光标处</p></li><li><p>前进后退</p><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241023222957219.png" alt="image-20241023222957219">返回上一步调试，进行下一步调试</p></li></ul><h4 id="4-断点-Breakpoint"><a href="#4-断点-Breakpoint" class="headerlink" title="4. 断点 (Breakpoint)"></a>4. 断点 (Breakpoint)</h4><ul><li><p>设置断点</p><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241023222555566.png" alt="image-20241023222555566">设置当前光标处是断点</p></li><li><p>失能断点</p><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241023222641250.png" alt="image-20241023222641250">失能当前光标处的断点<img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241023222703855.png" alt="image-20241023222703855">失能所有断点<img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241023222739694.png" alt="image-20241023222739694">删除所有断点</p></li></ul><h3 id="debug用法示例"><a href="#debug用法示例" class="headerlink" title="debug用法示例"></a>debug用法示例</h3><h4 id="设置断点"><a href="#设置断点" class="headerlink" title="设置断点"></a><strong>设置断点</strong></h4><ul><li><strong>行断点</strong>：在源代码窗口，选择需要暂停的代码行，双击行号或右键选择 <strong>“Insert&#x2F;Remove Breakpoint”</strong></li><li><strong>条件断点</strong>：右键断点，选择 **”Edit Breakpoint”**，设置条件（例如变量的值或特定的表达式）</li></ul><h4 id="逐步执行代码"><a href="#逐步执行代码" class="headerlink" title="逐步执行代码"></a>逐步执行代码</h4><ul><li><strong>单步执行（Step Over）</strong>：点击 <strong>F10</strong>，跳过函数调用但执行完整的单条语句。</li><li><strong>单步跳入（Step Into）</strong>：点击 <strong>F11</strong>，进入当前行的函数体内，逐行查看函数的内部执行流程。</li><li><strong>跳出函数（Step Out）</strong>：点击 <strong>Shift + F11</strong>，继续执行至函数结束并返回。</li><li><strong>运行到光标处（Run to Cursor）</strong>：右键选择 “Run to Cursor”，代码将从当前执行位置直接运行到你选择的行。</li></ul><h4 id="观察变量和寄存器"><a href="#观察变量和寄存器" class="headerlink" title="观察变量和寄存器"></a><strong>观察变量和寄存器</strong></h4><ul><li><p>观察变量</p><p>在 <strong>Watch 窗口</strong>（右键变量，选择 <strong>Add to Watch Window</strong>），可以查看变量值的动态变化。</p><p>通过“Memory”窗口，可以直接查看并修改特定内存地址的内容。</p></li><li><p>观察寄存器</p><p>在 <strong>“Registers”窗口</strong> 中查看 CPU 寄存器的状态，跟踪数据处理和寄存器值的变化。</p></li></ul><h4 id="观察和修改内存内容"><a href="#观察和修改内存内容" class="headerlink" title="观察和修改内存内容"></a><strong>观察和修改内存内容</strong></h4><ul><li><p>Memory 窗口</p><p>通过 <strong>“View” &gt; “Memory Windows” &gt; “Memory 1&#x2F;2”</strong> 来打开内存观察窗口。</p><p>输入内存地址，可以实时查看数据。窗口支持查看 <strong>ASCII</strong> 和 <strong>Hex</strong> 格式的数据。</p></li><li><p>实时修改</p><p>右键内存窗口中的值，选择“Modify Memory”可实时更改特定内存位置的值，以测试程序对不同数据的响应。</p></li></ul><h4 id="使用调试信息窗口"><a href="#使用调试信息窗口" class="headerlink" title="使用调试信息窗口"></a><strong>使用调试信息窗口</strong></h4><ul><li><p>**调用堆栈 (Call Stack + Locals)**：显示函数调用堆栈，跟踪代码执行路径。适用于调试递归或多层函数嵌套的问题。</p></li><li><p>硬件外设窗口 (Peripherals)</p><p>在调试过程中查看和配置硬件外设（如 GPIO、串口、定时器）的状态。</p><p>打开 <strong>“View” &gt; “System Viewer”</strong> 查看不同外设的寄存器和状态。</p></li></ul><h3 id="Advance-project任务"><a href="#Advance-project任务" class="headerlink" title="Advance_project任务"></a>Advance_project任务</h3><ul><li>进入debug模式，单步执行至LED_Flashes_Init后，两个灯全部亮起，为正常现象，</li><li>GPIO_EXIT_Init函数为按键控制外部中断，和bug展示的现象无关，故跳过即可</li><li>进入到最有可能有问题的函数：TIM_Flashes_Init</li></ul><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241025183756295.png" alt="image-20241025183756295"></p><ul><li><p>进入到TIM_Flashes_Init函数中，可以发现，这个函数仅调用了一个函数指针：handler</p><p>除此之外，剩下的全是常规的tim计时器初始化以及nvic配置，尚未发现错误</p></li></ul><p>​此时，<strong>handler指针所指向的函数现已被列为重大嫌疑函数😡</strong></p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241025184110670.png" alt="image-20241025184110670" style="zoom:50%;" /><ul><li>追根溯源handler：</li></ul><p>回退到上一步，发现handler指针指向了嫌疑人<img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241025184323222.png" alt="image-20241025184323222" style="zoom:33%;" /></p><p>tick_handler函数依存于Flashes_TIM_IRQHandler（中断处理）函数,后者执行，前者就执行，因此我们找到后者，直接设置断点并转到，或者选中中断处理函数使用ctrl+F10，直接执行到他那里，会发现程序卡在了</p><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241025185037967.png" alt="image-20241025185037967"></p><p>看名字也知道，这个函数的作用是清空time，而不是time自减</p><p>当然为了严谨，我们还是验证一下：</p><p>转到调用它的函数的定义：</p><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241025184456370.png" alt="image-20241025184456370"></p><p>简单计算验证一下，这个函数自己的逻辑是没有问题的</p><p>那问题就出在他调用的别的函数中</p><ul><li>函数一：get_tick()</li><li>函数二：clare_tick()</li></ul><p>get_tick函数的逻辑是，获取当前自增计数达到阈值产生的中断次数</p><p>clare_tick函数的逻辑是，定期清除中断次数防止int存不下了</p><p>因此get函数的实现就应该是return中断次数，经检查没问题</p><p>clare函数的实现就应该是把中断次数置0，就是他的问题</p><p>把 time– 改成 time &#x3D; 0；bug已修复</p><h3 id="演示视频："><a href="#演示视频：" class="headerlink" title="演示视频："></a>演示视频：</h3>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>近世代数-005-有限群和子群</title>
      <link href="/2024/10/18/%E8%BF%91%E4%B8%96%E4%BB%A3%E6%95%B0-%E6%9C%89%E9%99%90%E7%BE%A4%E5%92%8C%E5%AD%90%E7%BE%A4/"/>
      <url>/2024/10/18/%E8%BF%91%E4%B8%96%E4%BB%A3%E6%95%B0-%E6%9C%89%E9%99%90%E7%BE%A4%E5%92%8C%E5%AD%90%E7%BE%A4/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="主要内容："><a href="#主要内容：" class="headerlink" title="主要内容："></a>主要内容：</h2><p>有限群的定义及性质(补充)</p><p>子群的定义</p><p>子群的性质</p><p>子群的判别 </p><p>典型子群</p><h2 id="有限群的定义及性质-补充"><a href="#有限群的定义及性质-补充" class="headerlink" title="有限群的定义及性质(补充)"></a>有限群的定义及性质(补充)</h2><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241018204835303.png" alt="image-20241018204835303"></p><p>令A&#x3D;{0,1,-1}，请问集合A关于普通乘法* 能否作成一个(有限)群？为什么？</p><ul><li>答：不行，有零元，和单位元冲突</li></ul><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241018205115002.png" alt="image-20241018205115002"></p><p>证明：</p><p>​</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 近世代数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>近世代数-003-群的定义及性质</title>
      <link href="/2024/10/18/%E8%BF%91%E4%B8%96%E4%BB%A3%E6%95%B0-%E7%BE%A4%E7%9A%84%E5%AE%9A%E4%B9%89%E5%8F%8A%E6%80%A7%E8%B4%A8/"/>
      <url>/2024/10/18/%E8%BF%91%E4%B8%96%E4%BB%A3%E6%95%B0-%E7%BE%A4%E7%9A%84%E5%AE%9A%E4%B9%89%E5%8F%8A%E6%80%A7%E8%B4%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><ol><li>群的定义</li><li>群的基本性质</li><li>群的实例</li><li>群中的术语</li></ol><h2 id="群的定义"><a href="#群的定义" class="headerlink" title="群的定义"></a>群的定义</h2><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241018165805648.png" alt="image-20241018165805648"></p><ul><li><p>**&#x3D;&#x3D;代数系统&#x3D;&#x3D;  ——结合律——&gt; &#x3D;&#x3D;半群&#x3D;&#x3D; —有单位元—&gt;  &#x3D;&#x3D;幺半群&#x3D;&#x3D;  **—两条路—&gt;</p></li><li><p><strong>——交换律——&gt;  &#x3D;&#x3D;可换幺半群&#x3D;&#x3D;</strong></p><p><strong>——如果每个元素都有逆元——&gt; &#x3D;&#x3D;群&#x3D;&#x3D;</strong></p></li></ul><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241018170724752.png" alt="image-20241018170724752"></p><p><img src="C:/Users/29111/AppData/Roaming/Typora/typora-user-images/image-20241018170702011.png" alt="image-20241018170702011"></p><ul><li><strong>对于IV  ，可以这么考虑：直接让a&#x3D;b，那么运算的左单位元和右单位元都存在，即单位元存在，然后再让b等于单位元e，那么就能推出逆元也存在</strong></li></ul><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241018171414327.png" alt="image-20241018171414327"></p><ul><li>答案是否定的</li></ul><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241018173248517.png" alt="image-20241018173248517"></p><h2 id="群的性质"><a href="#群的性质" class="headerlink" title="群的性质"></a>群的性质</h2><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241018173338024.png" alt="image-20241018173338024"></p><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241018173355154.png" alt="image-20241018173355154"></p><h4 id="讨论群中特异元素的性质"><a href="#讨论群中特异元素的性质" class="headerlink" title="讨论群中特异元素的性质"></a>讨论群中特异元素的性质</h4><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241018173458748.png" alt="image-20241018173458748"></p><ul><li>逆一遍，再逆一遍，还等于自身</li><li>先运算再逆，等于先逆，再交换过来算</li></ul><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241018190900808.png" alt="image-20241018190900808"></p><ul><li>0元不存在，因为只要是群，就一定有逆元，如果有0元，就冲突了</li></ul><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241018191220599.png" alt="image-20241018191220599"></p><ul><li><strong>这两个性质都是利用了群的性质中的可逆性</strong></li></ul><h2 id="群的实例"><a href="#群的实例" class="headerlink" title="群的实例"></a>群的实例</h2><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241018191555819.png" alt="image-20241018191555819"></p><h2 id="群中的术语"><a href="#群中的术语" class="headerlink" title="群中的术语"></a>群中的术语</h2><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241018191955947.png" alt="image-20241018191955947"></p><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241018192004215.png" alt="image-20241018192004215"></p><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241018192144706.png" alt="image-20241018192144706"></p><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241018192737213.png" alt="image-20241018192737213"></p><p>在这个问题中，群运算是<strong>对称差</strong> ⊕⊕，我们可以利用以下性质：</p><ol><li><p><strong>对称差的逆元</strong>：对称差运算的一个特点是，每个元素的逆元就是它本身。也就是说，对于任意 X∈P({a,b})<em>X</em>∈<em>P</em>({<em>a</em>,<em>b</em>})，有：</p><p>X⊕X&#x3D;∅<em>X</em>⊕<em>X</em>&#x3D;∅</p><p>因为对称差只保留不重叠的元素，因此两个相同的集合进行对称差操作时，结果是空集。</p></li><li><p><strong>单位元</strong>：在对称差运算下，单位元是<strong>空集</strong> ∅∅，因为对于任意集合 X<em>X</em>，有：</p><p>X⊕∅&#x3D;X<em>X</em>⊕∅&#x3D;<em>X</em></p><p>所以我们可以把对称差的运算当作某种“加法”操作，其中每个元素的“逆元”是它自己。</p></li></ol><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241018193708168.png" alt="image-20241018193708168"></p><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241018193743149.png" alt="image-20241018193743149"></p><h3 id="群中元素的幂"><a href="#群中元素的幂" class="headerlink" title="群中元素的幂"></a>群中元素的幂</h3><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241018194011084.png" alt="image-20241018194011084"></p><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241018194044829.png" alt="image-20241018194044829"></p><ul><li>注意，必须是可交换群才满足第三条性质</li></ul><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241018194316830.png" alt="image-20241018194316830"></p><h3 id="模-n运算中的元素的阶"><a href="#模-n运算中的元素的阶" class="headerlink" title="模 n运算中的元素的阶"></a>模 n运算中的元素的阶</h3><p>例子中提到的群 ⟨Z6,⊕⟩ 是指模 6下的加法群。这个群的元素是 Z6&#x3D;{[0],[1],[2],[3],[4],[5]}，其中每个元素是整数对 6 取模的等价类（即余数）。</p><p>在这个群中，运算 ⊕⊕ 是指<strong>模 6 加法</strong>，例如：</p><ul><li>[2]⊕[3]&#x3D;[5]</li><li>[4]⊕[4]&#x3D;[2] （因为 4+4&#x3D;8，模 6 后得到 2）</li><li>[3]⊕[3]&#x3D;[0] （因为 3+3&#x3D;6，模 6 后得到 0）</li></ul><p>群的单位元是 [0]，因为对于任意元素 [a]∈Z6，我们有 [a]⊕[0]&#x3D;[<em>a</em>]。</p><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241018194624206.png" alt="image-20241018194624206"></p><p>r∣k：这个符号表示<strong>整除</strong>。读作“r 整除 k”，意思是 k 可以被 r整除，即存在一个整数 m，使得 k&#x3D;mr。例如：</p><ul><li>3∣6，因为 6 可以被 3 整除，且 6&#x3D;3×26&#x3D;3×2。</li><li>4∤6，因为 6 不能被 4 整除。</li></ul><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241018195442637.png" alt="image-20241018195442637"></p><p>设 ∣a∣&#x3D;r，即a^r^&#x3D;<em>e</em>。我们希望证明 a^−1^ 的阶也是 <em>r</em>，即 (a^−1^)^r^&#x3D;e</p><p>通过群的性质，(a^−1^)^r^&#x3D;(a^r^)^−1^由于 a^r^&#x3D;e，我们有：</p><p>(a^r^)^−1^&#x3D;e^−1^&#x3D;e</p><p>因此，(a^−1^)^r^&#x3D;e，说明 a^−1^ 的阶不大于 r</p><p>另一方面，假设 (a^−1^)^k^&#x3D;e 对某个 <em>k</em> 成立。我们通过逆元的性质得到：</p><p>a^k^&#x3D;(a^−1^)^−k^&#x3D;e^−1^&#x3D;e</p><p>由于 a的阶是 <em>r</em>，因此 <em>k</em> 必须是 <em>r</em> 的倍数，即<em>k</em>&#x3D;<em>r</em>。这说明 <em>a</em>^−1^ 的阶恰好是 <em>r</em>。</p><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241018200226504.png" alt="image-20241018200226504"></p><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241018200434602.png" alt="image-20241018200434602"></p><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241018200634225.png" alt="image-20241018200634225"></p><ul><li>首先要讨论是不是无限集</li><li>对于一坨东西来说，左右各自添一个元素和一个元素的逆和原来一坨的基数相等</li></ul><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241018200840462.png" alt="image-20241018200840462"></p><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241018202449239.png" alt="image-20241018202449239"></p><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241018204452162.png" alt="image-20241018204452162"></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 近世代数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>stm32学习笔记002</title>
      <link href="/2024/10/16/stm3202/"/>
      <url>/2024/10/16/stm3202/</url>
      
        <content type="html"><![CDATA[<h2 id="任务一：GPIO输入输出"><a href="#任务一：GPIO输入输出" class="headerlink" title="任务一：GPIO输入输出"></a>任务一：GPIO输入输出</h2><h3 id="原理（实现步骤）"><a href="#原理（实现步骤）" class="headerlink" title="原理（实现步骤）"></a>原理（实现步骤）</h3><ul><li>选择两个GPIO引脚，PB0负责输出，PB1作为输入端。</li></ul><ol><li><strong>GPIO配置</strong><ul><li>设置GPIOB0,B1为推挽输出模式</li></ul></li><li><strong>控制逻辑</strong><ul><li>第一个gpio输出高低电平，控制第一个灯亮灭</li><li>每次循环开始时，ReadInputDataBit函数<strong>读取GPIOB0的输入寄存器（IDR）</strong>，记为int led1_status</li><li>根据led1_status，延时200ms将GPIOB1调整为与GPIO0 一致</li><li>调整一致以后，延时200ms将GPIO0的状态反过来，看起来就是led1先灭了</li><li>如此往复，产生led2跟着led1跑的的感觉</li></ul></li></ol><h3 id="代码如下：（lLEDD-ON-和LED-OFF为我自定义的函数，详见任务三——代码模块化）"><a href="#代码如下：（lLEDD-ON-和LED-OFF为我自定义的函数，详见任务三——代码模块化）" class="headerlink" title="代码如下：（lLEDD_ON 和LED_OFF为我自定义的函数，详见任务三——代码模块化）"></a>代码如下：（lLEDD_ON 和LED_OFF为我自定义的函数，详见任务三——代码模块化）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>      <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;LED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;DELAY.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">LED_Init(<span class="number">1</span>);</span><br><span class="line">LED_Init(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> led1_status = GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_0);</span><br><span class="line"><span class="keyword">if</span>(led1_status)</span><br><span class="line">&#123;</span><br><span class="line">Delay_ms(<span class="number">200</span>);<span class="comment">//ÑÓÊ±Ò»ÏÂ</span></span><br><span class="line">LED_OFF(<span class="number">2</span>);</span><br><span class="line">Delay_ms(<span class="number">200</span>);</span><br><span class="line">LED_ON(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">Delay_ms(<span class="number">200</span>);</span><br><span class="line">LED_ON(<span class="number">2</span>);</span><br><span class="line">Delay_ms(<span class="number">200</span>);</span><br><span class="line">LED_OFF(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="视频："><a href="#视频：" class="headerlink" title="视频："></a>视频：</h3><p><a href="https://cloud.video.taobao.com/play/u/44392709/p/1/d/ld/e/6/t/1/487344496185.mp4?auth_key=YXBwX2tleT04MDAwMDAwMTImYXV0aF9pbmZvPXsidGltZXN0YW1wRW5jcnlwdGVkIjoiMzc2ZDk2YzdjNGRhNGMyMTA4MjMwODNhYmFmNDc3YzQifSZkdXJhdGlvbj0mdGltZXN0YW1wPTE3Mjk2OTgxOTc=">点击查看视频</a></p><h2 id="任务二-PWM控制舵机"><a href="#任务二-PWM控制舵机" class="headerlink" title="任务二 PWM控制舵机"></a>任务二 PWM控制舵机</h2><h5 id="1-pwm驱动呼吸灯"><a href="#1-pwm驱动呼吸灯" class="headerlink" title="1.pwm驱动呼吸灯"></a>1.pwm驱动呼吸灯</h5><p>概念：（oc为输出比较，oi为输入捕获，cc为输入捕获和输出比较的单元）</p><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241017103420122.png" alt="image-20241017103420122"></p><p><strong>原理</strong></p><p>ccr为我们自己设定的一个数值，cnt为周期自增的，每当cnt结束一个周期，就触发一次事件（重新自增），在这个周期内，比较cnt和ccr的大小，来调控pwm输出<img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241017104240355.png" alt="image-20241017104240355"></p><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241017104928031.png" alt="image-20241017104928031"></p><p>输出模式控制器的不同状态：</p><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241017105149834.png" alt="image-20241017105149834"></p><ul><li><p>冻结：用于暂停</p></li><li><p>置有效电平 &#x3D;&#x3D; 置高电平      置无效电平 &#x3D;&#x3D; 置低电平</p></li><li><p>电平反转：方便的输出一个频率可调，占空比为50%的pwm波</p></li><li><p>强制：可调高低的冻结</p></li><li><p>pwm模式：最常用<img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241017105859083.png" alt="image-20241017105859083"></p><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241017105938711.png" alt="image-20241017105938711"></p></li></ul><p>代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PWM_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2,ENABLE);<span class="comment">//使能时钟</span></span><br><span class="line"></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line"></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE);<span class="comment">//使能afio时钟</span></span><br><span class="line">GPIO_PinRemapConfig(GPIO_PartialRemap1_TIM2,ENABLE);<span class="comment">//重映射（如果是jatg调试端口，再加上下面一句）</span></span><br><span class="line">GPIO_PinRemapConfig(GPIO_Remap_SWJ_JTAGDisable,ENABLE); <span class="comment">//用afio将jtag解除</span></span><br><span class="line"></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;<span class="comment">//注意这个位置设置为复用推挽输出</span></span><br><span class="line">GPIO_InitStructure.GPIO_Pin=GPIO_Pin_15;</span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">TIM_InternalClockConfig(TIM2);</span><br><span class="line"></span><br><span class="line">TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;</span><br><span class="line">TIM_TimeBaseInitStructure.TIM_ClockDivision=TIM_CKD_DIV1; <span class="comment">//ָ设置时钟分频（1分频）</span></span><br><span class="line">TIM_TimeBaseInitStructure.TIM_CounterMode=TIM_CounterMode_Up; <span class="comment">//向上计数</span></span><br><span class="line">TIM_TimeBaseInitStructure.TIM_Period=<span class="number">100</span><span class="number">-1</span>;   <span class="comment">//ARR</span></span><br><span class="line">TIM_TimeBaseInitStructure.TIM_Prescaler=<span class="number">720</span><span class="number">-1</span>; <span class="comment">//72mzh / 7200 = 10k ,72mhz / 7200 = 10k   //PSC</span></span><br><span class="line">TIM_TimeBaseInitStructure.TIM_RepetitionCounter=<span class="number">0</span>;<span class="comment">//重复计数（高级计时器有，现在不用）</span></span><br><span class="line">TIM_TimeBaseInit(TIM2,&amp;TIM_TimeBaseInitStructure);</span><br><span class="line"></span><br><span class="line">TIM_OCInitTypeDef TIM_OCInitStructure; </span><br><span class="line"></span><br><span class="line">TIM_OCStructInit(&amp;TIM_OCInitStructure);<span class="comment">//默认给所有变量一个初始值，防止出错</span></span><br><span class="line"><span class="comment">//下面再改自己想改的</span></span><br><span class="line">TIM_OCInitStructure.TIM_OCMode=TIM_OCMode_PWM1;<span class="comment">//设置输出比较的模式</span></span><br><span class="line">TIM_OCInitStructure.TIM_OCPolarity=TIM_OCPolarity_High;<span class="comment">//设置输出比较的极性</span></span><br><span class="line">TIM_OCInitStructure.TIM_OutputState=TIM_OutputState_Enable;<span class="comment">//设置输出使能</span></span><br><span class="line">TIM_OCInitStructure.TIM_Pulse=<span class="number">0</span>;<span class="comment">//设置ccr寄存器值</span></span><br><span class="line">TIM_OC1Init(TIM2,&amp;TIM_OCInitStructure);</span><br><span class="line"></span><br><span class="line">TIM_Cmd(TIM2,ENABLE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PWM_SetCompare1</span><span class="params">(<span class="type">uint16_t</span> Compare)</span></span><br><span class="line">&#123;</span><br><span class="line">TIM_SetCompare1(TIM2,Compare);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面是mian函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>      <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;LED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;DELAY.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;OLED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Timer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;PWM.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> i;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">PWM_Init();</span><br><span class="line">OLED_Init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=<span class="number">100</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">OLED_ShowNum(<span class="number">2</span>,<span class="number">1</span>,i,<span class="number">3</span>);</span><br><span class="line">PWM_SetCompare1(i);</span><br><span class="line">Delay_ms(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="视频：-1"><a href="#视频：-1" class="headerlink" title="视频："></a>视频：</h4><p><a href="https://cloud.video.taobao.com/play/u/44392709/p/1/d/sd_265/e/6/t/1/487638019397.mp4?auth_key=YXBwX2tleT04MDAwMDAwMTImYXV0aF9pbmZvPXsidGltZXN0YW1wRW5jcnlwdGVkIjoiZGQ1MTM5ZThmZmIyYzhkMzY3ODlkYjhiYjRlZjM5YmYifSZkdXJhdGlvbj0mdGltZXN0YW1wPTE3Mjk2OTgxOTg=">点击查看视频</a></p><h5 id="2-pwm驱动舵机（主任务2）"><a href="#2-pwm驱动舵机（主任务2）" class="headerlink" title="2.pwm驱动舵机（主任务2）"></a>2.pwm驱动舵机（主任务2）</h5><p><strong>技术点介绍</strong>：</p><p>定时器的比较输出：</p><p>原理：主要依靠cnt（自增计数器）和ccr（我们自己设定的一个值）进行比较，当cnt等于ccr的时候，触发事件–重新计数（详见pwm驱动呼吸点灯中的图片）</p><h6 id="详细过程："><a href="#详细过程：" class="headerlink" title="详细过程："></a><strong>详细过程：</strong></h6><p><strong>计数器（CNT）</strong>根据定时器的时钟频率和预分频器的设置自动增加（或减少）。当计数器达到 ARR（自动重装载寄存器）的值时，计数器会重置，并从头开始计数。</p><p><strong>比较值（CCR）</strong>每个定时器通道都有一个比较寄存器（CCRx），它存储定时器的比较值。当计数器的值（CNT）与比较寄存器的值相等时，定时器会触发一个事件，改变输出引脚的状态</p><p><strong>ARR（自动重装载寄存器）</strong>设置了计数器的最大值，也就是 PWM 信号的<strong>周期</strong>。计数器在每次达到 ARR的值后会自动重置，开始新的周期。</p><p><strong>CCR（捕获比较寄存器）</strong>用于设置比较值，也就是定时器在这个值时改变输出状态</p><h6 id="pwm是什么："><a href="#pwm是什么：" class="headerlink" title="pwm是什么："></a>pwm是什么：</h6><p>在一个很短的周期内，我们规定一定一定时间高电平，一段时间的低电平（即占空比），这样电平就会以较高的频率进行高低变化，输出一个方波，这个波就是pwm波，可以用来驱动舵机</p><h6 id="pwm的实现："><a href="#pwm的实现：" class="headerlink" title="pwm的实现："></a>pwm的实现：</h6><p>就像上面说的那样，pwm的实现首先要规定一个很小的周期，以舵机为例，想要控制舵机，周期就要设置为20ms,对应的arr和psc要符合20ms的周期</p><h5 id="核心代码："><a href="#核心代码：" class="headerlink" title="核心代码："></a><strong>核心代码：</strong></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">TIM_TimeBaseInitStructure.TIM_Period=<span class="number">20000</span><span class="number">-1</span>;   <span class="comment">//ARR</span></span><br><span class="line">TIM_TimeBaseInitStructure.TIM_Prescaler=<span class="number">72</span><span class="number">-1</span>; <span class="comment">//PSC</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">计算定时器的计数频率</span></span><br><span class="line"><span class="comment">定时器计数频率由 系统时钟频率 / (PSC + 1) 决定。</span></span><br><span class="line"><span class="comment">比如，如果 PSC = 71，那么定时器的计数频率为：</span></span><br><span class="line"><span class="comment">计数频率=72MHz除以（71+1）=1MHz</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">这意味着定时器每微秒计数一次。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">设置 ARR 值</span></span><br><span class="line"><span class="comment">在 1MHz 计数频率下，20ms 对应的计数值为：</span></span><br><span class="line"><span class="comment">ARR=20ms×1MHz=20000</span></span><br><span class="line"><span class="comment">因此，将 ARR 设置为 20000-1 就可以产生一个 20ms 周期的 PWM 信号。*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PWM_SetCompare2</span><span class="params">(<span class="type">uint16_t</span> Compare)</span><span class="comment">//初始化哪个通道，就compare几</span></span><br><span class="line">&#123;</span><br><span class="line">TIM_SetCompare2(TIM5,Compare); <span class="comment">//占空比</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Servo_SetAngle</span><span class="params">(<span class="type">float</span> Angele)</span></span><br><span class="line">&#123;</span><br><span class="line">PWM_SetCompare2(Angele/<span class="number">180</span>*<span class="number">2000</span>+<span class="number">500</span>); <span class="comment">//把角度线性映射到占空比</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="总代码"><a href="#总代码" class="headerlink" title="总代码"></a>总代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>      <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;LED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;DELAY.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;OLED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Timer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Servo.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Key.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> KeyNumAfter = <span class="number">0</span>;</span><br><span class="line"><span class="type">uint8_t</span> KeyNumBefore = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> Angle = <span class="number">90</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">Servo_Init();</span><br><span class="line">OLED_Init();</span><br><span class="line">OLED_ShowString(<span class="number">1</span>,<span class="number">1</span>,<span class="string">&quot;Angle:&quot;</span>);</span><br><span class="line">OLED_ShowString(<span class="number">2</span>,<span class="number">1</span>,<span class="string">&quot;KNum:&quot;</span>);</span><br><span class="line">Key_Init();</span><br><span class="line"></span><br><span class="line">Servo_SetAngle(Angle);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">KeyNumAfter = Key_GetNum();<span class="comment">//设置一个中间缓冲变量，防止oled上的key标识一闪而过</span></span><br><span class="line"><span class="keyword">if</span>(KeyNumAfter!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">KeyNumBefore = KeyNumAfter;</span><br><span class="line">&#125;</span><br><span class="line">OLED_ShowNum(<span class="number">2</span>,<span class="number">7</span>,KeyNumBefore,<span class="number">5</span>);</span><br><span class="line"><span class="keyword">if</span>(KeyNumAfter)</span><br><span class="line">&#123;</span><br><span class="line">Angle+=<span class="number">30</span>;</span><br><span class="line"><span class="keyword">if</span>(Angle&gt;<span class="number">180</span>)</span><br><span class="line">&#123;</span><br><span class="line">Angle = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">Delay_ms(<span class="number">30</span>);</span><br><span class="line">&#125;</span><br><span class="line">Servo_SetAngle(Angle);</span><br><span class="line">OLED_ShowNum(<span class="number">1</span>,<span class="number">7</span>,Angle,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="视频现象："><a href="#视频现象：" class="headerlink" title="视频现象："></a>视频现象：</h3><p><a href="https://cloud.video.taobao.com/play/u/44392709/p/1/d/sd_265/e/6/t/1/487432637028.mp4?auth_key=YXBwX2tleT04MDAwMDAwMTImYXV0aF9pbmZvPXsidGltZXN0YW1wRW5jcnlwdGVkIjoiZGQ1MTM5ZThmZmIyYzhkMzY3ODlkYjhiYjRlZjM5YmYifSZkdXJhdGlvbj0mdGltZXN0YW1wPTE3Mjk2OTgxOTg=">点击查看视频</a></p><h2 id="任务三：阅读参考手册"><a href="#任务三：阅读参考手册" class="headerlink" title="任务三：阅读参考手册"></a>任务三：阅读参考手册</h2><h3 id="gpio原理："><a href="#gpio原理：" class="headerlink" title="gpio原理："></a>gpio原理：</h3><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/5d9aacdc3cbe0d2f22295cf8c98733d.png" alt="5d9aacdc3cbe0d2f22295cf8c98733d"></p><h6 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h6><ol><li>图中上半部分是输入示意图，信号从io引脚进入后，先经过<img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241017202833215.png" alt="image-20241017202833215" style="zoom:33%;" />这个结构（用于控制是上拉输入还是下拉输入的结构），然后下面是这个结构<img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241017203040197.png" alt="image-20241017203040197" style="zoom:33%;" />这个肖特基结构的作用是把信号分为高低电平（<strong>模拟信号转化为数字信号（当然更有可能是把数字信号处理一下变得更稳定）</strong>），如果在这个结构直接就直接输入，那就是直接输入模拟信号（走最上面一路）（记为模拟输入），经过肖特基触发器以后的信号就被转化为了稳定的数字信号</li><li>从肖特基触发器出来以后，有两条路，一条是复用（使用remap函数）输入，一条是直接放入输入数据寄存器，直接输入了</li></ol><h6 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h6><ol><li>下面有两条路径进入，一条是进入位设置&#x2F;清除寄存器，这个寄存器的作用是单独设置某位，而不影响其他位</li><li>第二条直接控制输出数据寄存器，这个是直接控制整个gpio口的所有位</li><li>最下面一条是来自片上外设的<strong>复用功能</strong>输入，例子可以看前面的pwm控制led（将gpioa15复用）</li></ol><h3 id="tim计时器相关"><a href="#tim计时器相关" class="headerlink" title="tim计时器相关"></a>tim计时器相关</h3><p>详见文末  其他——tim定时器学习笔记</p><h2 id="进阶任务–函数封装–流水灯"><a href="#进阶任务–函数封装–流水灯" class="headerlink" title="进阶任务–函数封装–流水灯"></a>进阶任务–函数封装–流水灯</h2><h3 id="技术介绍"><a href="#技术介绍" class="headerlink" title="技术介绍"></a>技术介绍</h3><h4 id="跨文件调用"><a href="#跨文件调用" class="headerlink" title="跨文件调用"></a>跨文件调用</h4><p>在主函数中include头文件，这个头文件用来存放函数声明</p><p>他所声明的函数存放于同名的.c文件中</p><h4 id="封装的意义"><a href="#封装的意义" class="headerlink" title="封装的意义"></a>封装的意义</h4><p>代码的封装能使代码更加简洁，更重要的是，它可以实现编程的模块化，对各个功能的增添，修补等更方便，如果工程较大的话，代码的封装是必不可少的</p><h4 id="条件编译的使用"><a href="#条件编译的使用" class="headerlink" title="条件编译的使用"></a>条件编译的使用</h4><p>以刚刚写的 waterfall.h为例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __WATERFALL_H <span class="comment">//如果没有定义这个头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __WATERFALL_H<span class="comment">//那么定义它</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">led_waterfall</span><span class="params">(<span class="type">uint8_t</span> leds)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span><span class="comment">//定义结束标志</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>条件编译的使用，能够防止重复定义导致错误，因为c语言引入头文件的方式就是直接把代码块复制粘贴到相应位置，如果同一个头文件在程序中粘贴两次，那就会出现大量重复定义的错误</p><h3 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h3><ol><li><p>首先，定义一个枚举类型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">led1 = <span class="number">0x01</span> &lt;&lt; <span class="number">0</span>,</span><br><span class="line">led2 = <span class="number">0x01</span> &lt;&lt; <span class="number">1</span>,</span><br><span class="line">led3 = <span class="number">0x01</span> &lt;&lt; <span class="number">2</span>,</span><br><span class="line">led4 = <span class="number">0x01</span> &lt;&lt; <span class="number">3</span>,</span><br><span class="line">led5 = <span class="number">0x01</span> &lt;&lt; <span class="number">4</span>,</span><br><span class="line">led6 = <span class="number">0x01</span> &lt;&lt; <span class="number">5</span></span><br><span class="line">&#125;leds;</span><br></pre></td></tr></table></figure></li><li><p>创建一个头文件，一个库文件</p></li><li><p>首先，定义最关键的函数，也是唯一和main函数链接的函数led_waterfall（uint8_t leds）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">led_waterfall</span><span class="params">(<span class="type">uint8_t</span> leds)</span></span><br><span class="line">&#123;</span><br><span class="line">LED_Init();</span><br><span class="line">TIM_Init();</span><br><span class="line"><span class="keyword">if</span> ((leds &amp; <span class="number">0x01</span>) == <span class="number">0x01</span>)</span><br><span class="line">&#123;</span><br><span class="line">led_should_on[led_count] = <span class="number">1</span>;</span><br><span class="line">led_count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((leds &amp; (<span class="number">0x01</span> &lt;&lt; <span class="number">1</span>)) == (<span class="number">0x01</span> &lt;&lt; <span class="number">1</span>))</span><br><span class="line">&#123;</span><br><span class="line">led_should_on[led_count] = <span class="number">2</span>;</span><br><span class="line">led_count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((leds &amp; (<span class="number">0x01</span> &lt;&lt; <span class="number">2</span>)) == (<span class="number">0x01</span> &lt;&lt; <span class="number">2</span>))</span><br><span class="line">&#123;</span><br><span class="line">led_should_on[led_count] = <span class="number">3</span>;</span><br><span class="line">led_count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((leds &amp; (<span class="number">0x01</span> &lt;&lt; <span class="number">3</span>)) == (<span class="number">0x01</span> &lt;&lt; <span class="number">3</span>))</span><br><span class="line">&#123;</span><br><span class="line">led_should_on[led_count] = <span class="number">4</span>;</span><br><span class="line">led_count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((leds &amp; (<span class="number">0x01</span> &lt;&lt; <span class="number">4</span>)) == (<span class="number">0x01</span> &lt;&lt; <span class="number">4</span>))</span><br><span class="line">&#123;</span><br><span class="line">led_should_on[led_count] = <span class="number">5</span>;</span><br><span class="line">led_count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((leds &amp; (<span class="number">0x01</span> &lt;&lt; <span class="number">5</span>)) == (<span class="number">0x01</span> &lt;&lt; <span class="number">5</span>))</span><br><span class="line">&#123;</span><br><span class="line">led_should_on[led_count] = <span class="number">6</span>;</span><br><span class="line">led_count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这个函数巧妙地运用了<strong>二进制的位运算</strong>，函数的形参看上去只能传入一个整数，实际上通过之前的枚举类型，再结合二进制的按位或运算，可以<strong>只用一个二进制数把多个信息传递进函数</strong>（每位的0和1代表每个灯的参数）</li><li>进入函数后，再把mix得到的一个二进制数和各自<strong>只有自己为1的二进制数进行按位与</strong>操作，就能把自身从按位或之后的二进制数中<strong>剥离</strong>出来</li></ul></li><li><p>接着，初始化led灯，配置tim2计时器，配置nvic</p><p>（其中包含对pb4的复用）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化GPIO</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOF,ENABLE);</span><br><span class="line"></span><br><span class="line"><span class="comment">//给pb4 remap</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE);<span class="comment">//afio (to remap pb4)</span></span><br><span class="line">GPIO_PinRemapConfig(GPIO_Remap_SWJ_JTAGDisable, ENABLE); <span class="comment">//用afio将jtag解除</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;</span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line"><span class="comment">//pb0</span></span><br><span class="line">GPIO_Init(GPIOB,&amp;GPIO_InitStructure);</span><br><span class="line">GPIO_SetBits(GPIOB,GPIO_Pin_0);</span><br><span class="line"><span class="comment">//pb1</span></span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1;</span><br><span class="line">GPIO_Init(GPIOB,&amp;GPIO_InitStructure);</span><br><span class="line">GPIO_SetBits(GPIOB,GPIO_Pin_1);</span><br><span class="line"><span class="comment">//pb5</span></span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5;</span><br><span class="line">GPIO_Init(GPIOB,&amp;GPIO_InitStructure);</span><br><span class="line">GPIO_SetBits(GPIOB,GPIO_Pin_5);</span><br><span class="line"><span class="comment">//pf11</span></span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;</span><br><span class="line">GPIO_Init(GPIOF,&amp;GPIO_InitStructure);</span><br><span class="line">GPIO_SetBits(GPIOF,GPIO_Pin_11);</span><br><span class="line"><span class="comment">//pf12</span></span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;</span><br><span class="line">GPIO_Init(GPIOF,&amp;GPIO_InitStructure);</span><br><span class="line">GPIO_SetBits(GPIOF,GPIO_Pin_12);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//pb4</span></span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line">GPIO_Init(GPIOB,&amp;GPIO_InitStructure);</span><br><span class="line">GPIO_SetBits(GPIOB,GPIO_Pin_4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//===============================</span></span><br><span class="line"><span class="comment">//开启tim定时器</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2,ENABLE);</span><br><span class="line">TIM_TimeBaseInitTypeDef TIM_InitStructure;</span><br><span class="line">TIM_InitStructure.TIM_ClockDivision = TIM_CKD_DIV1;</span><br><span class="line">TIM_InitStructure.TIM_CounterMode = TIM_CounterMode_Up;</span><br><span class="line">TIM_InitStructure.TIM_Period = <span class="number">10000</span><span class="number">-1</span>;</span><br><span class="line">TIM_InitStructure.TIM_Prescaler = <span class="number">7200</span><span class="number">-1</span>;</span><br><span class="line">TIM_InitStructure.TIM_RepetitionCounter = <span class="number">0</span>;</span><br><span class="line">TIM_TimeBaseInit(TIM2,&amp;TIM_InitStructure);</span><br><span class="line"></span><br><span class="line">TIM_ClearFlag(TIM2,TIM_FLAG_Update);<span class="comment">//清空中断标志位</span></span><br><span class="line">TIM_ITConfig(TIM2,TIM_FLAG_Update,ENABLE);<span class="comment">//开启中断到nvic的通路</span></span><br><span class="line"></span><br><span class="line">NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannel = TIM2_IRQn;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority =<span class="number">2</span>;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">1</span>;</span><br><span class="line">NVIC_Init(&amp;NVIC_InitStructure);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">TIM_Cmd(TIM2,ENABLE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>最后一步，事件函数的编写</p><ul><li>每秒钟进行一次操作，先打开当前要开的灯，再根据上一个灯的位置坝上一个灯熄灭</li><li>根据数组中下一个元素是否为0来判断i应该加一还是清零</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM2_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(TIM_GetITStatus(TIM2,TIM_IT_Update) == SET)</span><br><span class="line">&#123;</span><br><span class="line">LED_ON(led_should_on[i]);</span><br><span class="line"><span class="keyword">if</span>(i&gt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">LED_OFF(led_should_on[i<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> j = led_count<span class="number">-1</span>;</span><br><span class="line">LED_OFF(led_should_on[j]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(led_should_on[i+<span class="number">1</span>]==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">i = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">TIM_ClearITPendingBit(TIM2,TIM_IT_Update);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="完整代码："><a href="#完整代码：" class="headerlink" title="完整代码："></a>完整代码：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//============================</span></span><br><span class="line"><span class="comment">//初始化GPIO</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOF,ENABLE);</span><br><span class="line"></span><br><span class="line"><span class="comment">//给pb4 remap</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE);<span class="comment">//afio (to remap pb4)</span></span><br><span class="line">GPIO_PinRemapConfig(GPIO_Remap_SWJ_JTAGDisable, ENABLE); <span class="comment">//用afio将jtag解除</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;</span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line"><span class="comment">//pb0</span></span><br><span class="line">GPIO_Init(GPIOB,&amp;GPIO_InitStructure);</span><br><span class="line">GPIO_SetBits(GPIOB,GPIO_Pin_0);</span><br><span class="line"><span class="comment">//pb1</span></span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1;</span><br><span class="line">GPIO_Init(GPIOB,&amp;GPIO_InitStructure);</span><br><span class="line">GPIO_SetBits(GPIOB,GPIO_Pin_1);</span><br><span class="line"><span class="comment">//pb5</span></span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5;</span><br><span class="line">GPIO_Init(GPIOB,&amp;GPIO_InitStructure);</span><br><span class="line">GPIO_SetBits(GPIOB,GPIO_Pin_5);</span><br><span class="line"><span class="comment">//pf11</span></span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;</span><br><span class="line">GPIO_Init(GPIOF,&amp;GPIO_InitStructure);</span><br><span class="line">GPIO_SetBits(GPIOF,GPIO_Pin_11);</span><br><span class="line"><span class="comment">//pf12</span></span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;</span><br><span class="line">GPIO_Init(GPIOF,&amp;GPIO_InitStructure);</span><br><span class="line">GPIO_SetBits(GPIOF,GPIO_Pin_12);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//pb4</span></span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line">GPIO_Init(GPIOB,&amp;GPIO_InitStructure);</span><br><span class="line">GPIO_SetBits(GPIOB,GPIO_Pin_4);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//=================================================</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//=================================================</span></span><br><span class="line"><span class="comment">//设置开关led的函数</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_ON</span><span class="params">(<span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">switch</span>(i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">GPIO_ResetBits(GPIOB,GPIO_Pin_0);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">GPIO_ResetBits(GPIOB,GPIO_Pin_1);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">GPIO_ResetBits(GPIOB,GPIO_Pin_5);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">GPIO_ResetBits(GPIOB,GPIO_Pin_4);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">GPIO_ResetBits(GPIOF,GPIO_Pin_11);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">GPIO_ResetBits(GPIOF,GPIO_Pin_12);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_OFF</span><span class="params">(<span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">switch</span>(i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">GPIO_SetBits(GPIOB,GPIO_Pin_0);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">GPIO_SetBits(GPIOB,GPIO_Pin_1);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">GPIO_SetBits(GPIOB,GPIO_Pin_5);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">GPIO_SetBits(GPIOB,GPIO_Pin_4);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">GPIO_SetBits(GPIOF,GPIO_Pin_11);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">GPIO_SetBits(GPIOF,GPIO_Pin_12);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//====================================================</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//===============================</span></span><br><span class="line"><span class="comment">//开启tim定时器</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2,ENABLE);</span><br><span class="line">TIM_TimeBaseInitTypeDef TIM_InitStructure;</span><br><span class="line">TIM_InitStructure.TIM_ClockDivision = TIM_CKD_DIV1;</span><br><span class="line">TIM_InitStructure.TIM_CounterMode = TIM_CounterMode_Up;</span><br><span class="line">TIM_InitStructure.TIM_Period = <span class="number">10000</span><span class="number">-1</span>;</span><br><span class="line">TIM_InitStructure.TIM_Prescaler = <span class="number">7200</span><span class="number">-1</span>;</span><br><span class="line">TIM_InitStructure.TIM_RepetitionCounter = <span class="number">0</span>;</span><br><span class="line">TIM_TimeBaseInit(TIM2,&amp;TIM_InitStructure);</span><br><span class="line"></span><br><span class="line">TIM_ClearFlag(TIM2,TIM_FLAG_Update);<span class="comment">//清空中断标志位</span></span><br><span class="line">TIM_ITConfig(TIM2,TIM_FLAG_Update,ENABLE);<span class="comment">//开启中断到nvic的通路</span></span><br><span class="line"></span><br><span class="line">NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannel = TIM2_IRQn;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority =<span class="number">2</span>;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">1</span>;</span><br><span class="line">NVIC_Init(&amp;NVIC_InitStructure);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">TIM_Cmd(TIM2,ENABLE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//=================================================</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> led_should_on[<span class="number">6</span>]; <span class="comment">//存要开关的灯,多留一个0位，用于标记</span></span><br><span class="line"><span class="type">int</span> led_count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">led_waterfall</span><span class="params">(<span class="type">uint8_t</span> leds)</span></span><br><span class="line">&#123;</span><br><span class="line">LED_Init();</span><br><span class="line">TIM_Init();</span><br><span class="line"><span class="keyword">if</span> ((leds &amp; <span class="number">0x01</span>) == <span class="number">0x01</span>)</span><br><span class="line">&#123;</span><br><span class="line">led_should_on[led_count] = <span class="number">1</span>;</span><br><span class="line">led_count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((leds &amp; (<span class="number">0x01</span> &lt;&lt; <span class="number">1</span>)) == (<span class="number">0x01</span> &lt;&lt; <span class="number">1</span>))</span><br><span class="line">&#123;</span><br><span class="line">led_should_on[led_count] = <span class="number">2</span>;</span><br><span class="line">led_count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((leds &amp; (<span class="number">0x01</span> &lt;&lt; <span class="number">2</span>)) == (<span class="number">0x01</span> &lt;&lt; <span class="number">2</span>))</span><br><span class="line">&#123;</span><br><span class="line">led_should_on[led_count] = <span class="number">3</span>;</span><br><span class="line">led_count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((leds &amp; (<span class="number">0x01</span> &lt;&lt; <span class="number">3</span>)) == (<span class="number">0x01</span> &lt;&lt; <span class="number">3</span>))</span><br><span class="line">&#123;</span><br><span class="line">led_should_on[led_count] = <span class="number">4</span>;</span><br><span class="line">led_count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((leds &amp; (<span class="number">0x01</span> &lt;&lt; <span class="number">4</span>)) == (<span class="number">0x01</span> &lt;&lt; <span class="number">4</span>))</span><br><span class="line">&#123;</span><br><span class="line">led_should_on[led_count] = <span class="number">5</span>;</span><br><span class="line">led_count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((leds &amp; (<span class="number">0x01</span> &lt;&lt; <span class="number">5</span>)) == (<span class="number">0x01</span> &lt;&lt; <span class="number">5</span>))</span><br><span class="line">&#123;</span><br><span class="line">led_should_on[led_count] = <span class="number">6</span>;</span><br><span class="line">led_count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//=================================================</span></span><br><span class="line"><span class="comment">//具体事件编写</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM2_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(TIM_GetITStatus(TIM2,TIM_IT_Update) == SET)</span><br><span class="line">&#123;</span><br><span class="line">LED_ON(led_should_on[i]);</span><br><span class="line"><span class="keyword">if</span>(i&gt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">LED_OFF(led_should_on[i<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> j = led_count<span class="number">-1</span>;</span><br><span class="line">LED_OFF(led_should_on[j]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(led_should_on[i+<span class="number">1</span>]==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">i = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">TIM_ClearITPendingBit(TIM2,TIM_IT_Update);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="视频：-2"><a href="#视频：-2" class="headerlink" title="视频："></a>视频：</h3><p><a href ="https://lark-video.oss-cn-hangzhou.aliyuncs.com/outputs/prod/yuque/2024/44392709/mp4/1729184451456-34aaa9d9-2689-4abb-862b-9df182355abb.mp4?OSSAccessKeyId=LTAI4GKnqTWmz2X8mzA1Sjbv&amp;Expires=1729705398&amp;Signature=C8MTR6QCKfZAFqcr67jZ3QvdfwY%3D">点击查看视频</a></p></li></ol><h2 id="进阶任务：共地和上拉-下拉电阻的作用"><a href="#进阶任务：共地和上拉-下拉电阻的作用" class="headerlink" title="进阶任务：共地和上拉\下拉电阻的作用"></a>进阶任务：共地和上拉\下拉电阻的作用</h2><h3 id="1-共地"><a href="#1-共地" class="headerlink" title="1. 共地"></a>1. <strong>共地</strong></h3><p>共地是指电路中的不同部分（如电源、传感器、外设、处理器等）共享同一个GND作为电压为零的参考点，所有信号电压都是相对于这个参考点来测量的，避免信号传输过程中产生误差。</p><p>如果不共地，信号可能会不稳定，不共地的电路可能会在地线之间形成环路，产生电磁干扰，可能损坏电路元件</p><h3 id="2-上拉电阻和下拉电阻"><a href="#2-上拉电阻和下拉电阻" class="headerlink" title="2. 上拉电阻和下拉电阻"></a>2. <strong>上拉电阻和下拉电阻</strong></h3><p>上拉电阻 和 下拉电阻 是用来稳定数字电路中未连接状态时的信号电平的电阻器。它们用于防止输入引脚悬空，并确保其处于已知的逻辑电平。上拉电阻连接在 信号引脚和电源正极 之间。当输入引脚没有驱动时，上拉电阻将引脚电压拉高到高电平，确保信号处于稳定的高电平。下拉电阻连接信号引脚和地 之间。当输入引脚没有驱动时，下拉电阻将引脚电压拉低到逻辑低电平，确保信号处于稳定的低电平。</p><h3 id="分析图片"><a href="#分析图片" class="headerlink" title="分析图片"></a>分析图片</h3><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241018005115582.png" alt="image-20241018005115582" style="zoom:33%;" />这个图片中，当开关断开时，nrst直接连在上拉电阻上，为稳定的高电平，当开关闭合时，nrst接地，为低电平</p><h2 id="其它——tim定时器学习笔记"><a href="#其它——tim定时器学习笔记" class="headerlink" title="其它——tim定时器学习笔记"></a>其它——tim定时器学习笔记</h2><h3 id="定时器外部中断"><a href="#定时器外部中断" class="headerlink" title="定时器外部中断"></a>定时器外部中断</h3><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241016182413622.png" alt="image-20241016182413622"></p><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241016182924178.png" alt="image-20241016182924178"></p><ul><li>主从触发模式的作用：它能让内部的硬件在不受程序的控制下实现自动运行（可以减轻cpu的负担）</li></ul><h4 id="基本定时器工作原理：（只能向上计数）"><a href="#基本定时器工作原理：（只能向上计数）" class="headerlink" title="基本定时器工作原理：（只能向上计数）"></a>基本定时器工作原理：（只能向上计数）</h4><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241016184838791.png" alt="image-20241016184838791"></p><ul><li>把下面那个U映射到触发输出（TRGO），无需频繁中断，也可进行dac转换，触发定时器的的更新</li><li>上面那个ui，计数值等于更新重装值产生的中断，叫做“更新中断”</li></ul><p>通用定时器和高级定时器还支持向下计数和中央对齐计数</p><h4 id="通用定时器"><a href="#通用定时器" class="headerlink" title="通用定时器"></a>通用定时器</h4><p>模式二——最简单，最直接</p><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241016203406894.png" alt="image-20241016203406894"></p><p>模式1——trgi当作外部时钟使用：（主要使用etr）</p><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241016202456391.png" alt="image-20241016202456391"></p><ul><li>定时器的级联：黄色那条线，一个tim计时器的事件可以驱动另一个计时器的itr，这个计时器通过trgi输出，就实现了两个计时器的级联</li></ul><h4 id="三种定时器的区别："><a href="#三种定时器的区别：" class="headerlink" title="三种定时器的区别："></a>三种定时器的区别：</h4><p><strong>基本定时器</strong>：基本定时器有计数器、预分频器和自动重装载寄存器，能完成基本的计数和触发中断，主要用于生成定时中断。<strong>没有输入捕获、输出比较和 PWM 功能</strong>。常用于 DAC 触发或简单的时间间隔生成</p><p><strong>通用定时器</strong>：通用定时器具备计数、捕获比较、PWM 生成等功能。</p><p><strong>高级定时器</strong>：包括复杂的 PWM 输出、死区控制、互补输出等功能</p><h5 id="定时中断基本结构"><a href="#定时中断基本结构" class="headerlink" title="定时中断基本结构"></a>定时中断基本结构</h5><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241016204528525.png" alt="image-20241016204528525"></p><p>中断输出控制：中断输出的允许位，在一个时钟配置里，可能有很多地方申请中断，如果用不到，就把中断输出允许位设置为不允许，要用的话就设为允许</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>      <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;LED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;DELAY.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;OLED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Timer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> Num;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM2_IRQHandler</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">OLED_Init();</span><br><span class="line">Timer_Init();</span><br><span class="line">OLED_ShowString(<span class="number">1</span>,<span class="number">1</span>,<span class="string">&quot;Num:&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">OLED_ShowNum(<span class="number">1</span>,<span class="number">5</span>,Num,<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM2_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(TIM_GetITStatus(TIM2,TIM_IT_Update) == SET)</span><br><span class="line">&#123;</span><br><span class="line">Num++;</span><br><span class="line">TIM_ClearITPendingBit(TIM2,TIM_IT_Update);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这个程序使用内部时钟</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Timer.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Timer_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2,ENABLE);<span class="comment">//使能时钟</span></span><br><span class="line"></span><br><span class="line">TIM_InternalClockConfig(TIM2);</span><br><span class="line"></span><br><span class="line">TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;</span><br><span class="line">TIM_TimeBaseInitStructure.TIM_ClockDivision=TIM_CKD_DIV1; <span class="comment">//ָ设置时钟分频（1分频）</span></span><br><span class="line">TIM_TimeBaseInitStructure.TIM_CounterMode=TIM_CounterMode_Up; <span class="comment">//向上计数</span></span><br><span class="line">TIM_TimeBaseInitStructure.TIM_Period=<span class="number">10000</span><span class="number">-1</span>;</span><br><span class="line">TIM_TimeBaseInitStructure.TIM_Prescaler=<span class="number">7200</span><span class="number">-1</span>; <span class="comment">//72mzh / 7200 = 10k ,72mhz / 7200 = 10k</span></span><br><span class="line">TIM_TimeBaseInitStructure.TIM_RepetitionCounter=<span class="number">0</span>;<span class="comment">//重复计数（高级计时器有，现在不用）</span></span><br><span class="line">TIM_TimeBaseInit(TIM2,&amp;TIM_TimeBaseInitStructure);</span><br><span class="line"></span><br><span class="line">TIM_ClearFlag(TIM2,TIM_FLAG_Update); <span class="comment">//清除TIM2的更新中断标志位，确保定时器开始时没有残留的中断标志</span></span><br><span class="line"></span><br><span class="line">TIM_ITConfig(TIM2,TIM_IT_Update,ENABLE);<span class="comment">//开启更新中断到nvic通路</span></span><br><span class="line"></span><br><span class="line">NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);</span><br><span class="line"></span><br><span class="line">NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannel= TIM2_IRQn;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelCmd=ENABLE;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=<span class="number">2</span>;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelSubPriority=<span class="number">1</span>;</span><br><span class="line">NVIC_Init(&amp;NVIC_InitStructure);</span><br><span class="line">TIM_Cmd(TIM2,ENABLE);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* //用的时候复制进mian</span></span><br><span class="line"><span class="comment">void TIM2_IRQHandler(void)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">if(TIM_GetITStatus(TIM2,TIM_IT_Update) == SET)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">TIM_ClearITPendingBit(TIM2,TIM_IT_Update);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="红外对管"><a href="#红外对管" class="headerlink" title="红外对管"></a>红外对管</h5><h5 id="pwm驱动呼吸灯"><a href="#pwm驱动呼吸灯" class="headerlink" title="pwm驱动呼吸灯"></a>pwm驱动呼吸灯</h5><p>更新中</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>近世代数-002-代数系统及其同态与同构</title>
      <link href="/2024/10/13/%E8%BF%91%E4%B8%96%E4%BB%A3%E6%95%B0-%E4%BB%A3%E6%95%B0%E7%B3%BB%E7%BB%9F%E5%8F%8A%E5%85%B6%E5%90%8C%E6%80%81%E4%B8%8E%E5%90%8C%E6%9E%84/"/>
      <url>/2024/10/13/%E8%BF%91%E4%B8%96%E4%BB%A3%E6%95%B0-%E4%BB%A3%E6%95%B0%E7%B3%BB%E7%BB%9F%E5%8F%8A%E5%85%B6%E5%90%8C%E6%80%81%E4%B8%8E%E5%90%8C%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241015110807262.png" alt="image-20241015110807262"></p><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241015110744452.png" alt="image-20241015110744452"></p><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241015111357536.png" alt="image-20241015111357536"></p><p>近世代数（或抽象代数）的主要研究内容就是 研究所谓的代数系统，即带有运算的集合。在近世 代数里，不管是在群、环里还是在其它代数系统 里，研究一种代数系统就是要解决这一系统的<strong>存在问题、数量问题和构造问题</strong>。如果对于一个代数系 统，这三个问题能得到圆满的解答，研究的目的就 算达到了</p><p><strong>由已知的代数系统可以通过系统的方法构建新 的代数系统，即子代数和积代数。 这些代数系统（即子代数和积代数）能够保持 或者基本上保持原有代数系统的良好性质。</strong></p><h2 id="子代数"><a href="#子代数" class="headerlink" title="子代数"></a>子代数</h2><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241015112033678.png" alt="image-20241015112033678"></p><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241015112158434.png" alt="image-20241015112158434"></p><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241015112411970.png" alt="image-20241015112411970"></p><h2 id="积代数"><a href="#积代数" class="headerlink" title="积代数"></a>积代数</h2><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241015112447943.png" alt="image-20241015112447943"></p><ol><li>第一步，把定义域扩充到<strong>笛卡尔积</strong></li><li>第二步，笛卡尔积中取出两个元素，进行新定义运算</li><li>第三步，定义的新运算等于两个笛卡尔积中，属于a的元素和属于b的元素分别进行原有运算</li></ol><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241015113323852.png" alt="image-20241015113323852"></p><p>在代数系统的研究中，子代数和积代数是两个重要的概念。让我们逐一讨论这两个问题。</p><h3 id="1-子代数的存在性"><a href="#1-子代数的存在性" class="headerlink" title="1. 子代数的存在性"></a>1. <strong>子代数的存在性</strong></h3><ul><li><strong>子代数（Subalgebra）</strong>：子代数是从原代数系统中选出一个子集，并且这个子集在代数运算下仍然封闭（也就是说，子集中任意两个元素进行原代数系统的运算，结果仍在子集中）。子代数继承了原代数系统的运算和性质。</li></ul><h4 id="问题：设-V-是一个代数系统，-V-一定有子代数吗？或者-V-的子代数一定存在吗？"><a href="#问题：设-V-是一个代数系统，-V-一定有子代数吗？或者-V-的子代数一定存在吗？" class="headerlink" title="问题：设 ( V ) 是一个代数系统，( V ) 一定有子代数吗？或者 ( V ) 的子代数一定存在吗？"></a>问题：设 ( V ) 是一个代数系统，( V ) 一定有子代数吗？或者 ( V ) 的子代数一定存在吗？</h4><ul><li><p><strong>答案：是的，代数系统 ( V ) 总是有子代数的</strong>。</p></li><li><p><strong>解释：</strong> 每个代数系统至少有两个子代数：</p><ol><li><strong>平凡子代数（trivial subalgebra）</strong>：包含代数系统的单位元或某些特殊元素，通常是系统中唯一的零元素或单位元素（例如，在一个群中，包含唯一单位元的子集构成平凡子群）。</li><li><strong>自身子代数</strong>：代数系统本身就是它的一个子代数。</li></ol></li><li><p><strong>总结</strong>：因此，代数系统 ( V ) 至少有两个子代数，平凡子代数和代数系统本身。这意味着<strong>子代数总是存在的</strong>。</p></li></ul><h3 id="2-积代数的存在性"><a href="#2-积代数的存在性" class="headerlink" title="2. 积代数的存在性"></a>2. <strong>积代数的存在性</strong></h3><ul><li><strong>积代数（Product Algebra）</strong>：积代数是指在给定的代数系统上，构造一个新代数系统，其元素是原系统的元素对（或更高维的元素组），并且新系统中的运算是在每个坐标分量上分别进行原系统的运算。形式上，如果 ( V_1 ) 和 ( V_2 ) 是两个代数系统，那么它们的积代数 ( V_1 \times V_2 ) 是由所有形式为 ( (v_1, v_2) ) 的元素组成，其中 ( v_1 \in V_1 )，( v_2 \in V_2 )，且代数运算是分量的逐点运算。</li></ul><h4 id="问题：设-V-是一个代数系统，-V-一定有积代数吗？或者-V-的积代数一定存在吗？"><a href="#问题：设-V-是一个代数系统，-V-一定有积代数吗？或者-V-的积代数一定存在吗？" class="headerlink" title="问题：设 ( V ) 是一个代数系统，( V ) 一定有积代数吗？或者 ( V ) 的积代数一定存在吗？"></a>问题：设 ( V ) 是一个代数系统，( V ) 一定有积代数吗？或者 ( V ) 的积代数一定存在吗？</h4><ul><li><p><strong>答案：是的，积代数一定存在</strong>，但这取决于你是否给定了另一个代数系统进行积运算。</p></li><li><p><strong>解释：</strong></p><ul><li>如果你有两个代数系统 ( V_1 ) 和 ( V_2 )，你可以总是构造它们的积代数 ( V_1 \times V_2 )。积代数的定义是根据两个代数系统的逐分量运算构造的，因此，只要你有两个代数系统，积代数总是可以存在的。</li><li>对于一个代数系统 ( V ) 自身，如果你想构造与自己做积代数（即 ( V \times V )），这个积代数也是存在的。</li></ul></li><li><p><strong>总结</strong>：积代数总是可以构造的，因为积代数是一个代数运算的扩展，它取决于给定代数系统的逐点运算。因此，<strong>积代数的存在性是可以保证的</strong>，只要有至少一个代数系统（如自身或其他代数系统）来构造积。</p></li></ul><hr><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ol><li><strong>子代数的存在性</strong>：每个代数系统至少有两个子代数（平凡子代数和自身子代数），因此子代数总是存在的。</li><li><strong>积代数的存在性</strong>：给定一个代数系统 ( V )，它的积代数（无论是自身的积代数，还是与其他系统的积代数）总是可以构造，因此积代数也一定存在。</li></ol><h2 id="同态映射"><a href="#同态映射" class="headerlink" title="同态映射"></a>同态映射</h2><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241015114138959.png" alt="image-20241015114138959"></p><ol><li>两个定义域为A,B的代数系统，一个A-&gt;B的映射</li><li>如果A中取出x，y，进行A系统内的运算以后，映射到B系统，，等于A中的两个元素先映射到B系统，再进行B系统内的运算，则这个<strong>映射f</strong>称为同态映射，简称同态</li><li>f是单射，满射，双射分别称为 单同态，满同态（此时称V2是V1的同态像，记作V1~V2）,同构</li><li>如果v1&#x3D;v2，自同态</li></ol><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241015115806377.png" alt="image-20241015115806377"></p><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241015115906592.png" alt="image-20241015115906592"></p><ol><li><p>a@b &#x3D; b@a ,f(a@b) &#x3D; <strong>f(a)#f(b)</strong> &#x3D;  f(b@a) &#x3D; <strong>f(b)#f(a)</strong>,</p><p>至于为什么要规定满同态才成立，想想便知，上面的式子其实已经隐含了一个条件，那就是对于b里面的所有能表示成<strong>f(x属于A)<strong>的元素，运算#具有交换律，那想要让所有B</strong>中元素对于运算#都具有交换律，就要保证所有B中的的元素都能表示成a中元素的f映射</strong>，也就是必须A-&gt;B的映射f为满射，即满同态</p></li><li><p>a@(b?c) &#x3D; a@c ?b@c , f(a@(b?c)) &#x3D; f(a)#f(b?c) &#x3D;<strong>f(a)#(f(b)&amp;f(c)</strong></p><p>f(a@c ?b@c) &#x3D; f(a@c) &amp; f(b@c) &#x3D; <strong>f(a)#f(c) &amp;f(b)#f(c)</strong></p><p>同理，规定满同态成立的原因，也是要把存在A中元素，能映射到B中元素的每一个角落，使得B也有这个性质</p></li></ol><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241018162651115.png" alt="image-20241018162651115"></p><ul><li><strong>总结来说，对于满同态映射f，A中的 交换律 分配律 单位元 零元 逆元 均能由f映射到B</strong></li></ul><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241018163006857.png" alt="image-20241018163006857"></p><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241018163028610.png" alt="image-20241018163028610"></p><h3 id="注意，群理论中的ker和商集的定义-与-集合论-等价类中ker和商集的定义不一样！"><a href="#注意，群理论中的ker和商集的定义-与-集合论-等价类中ker和商集的定义不一样！" class="headerlink" title="注意，群理论中的ker和商集的定义 与 集合论 等价类中ker和商集的定义不一样！"></a><strong>注意，群理论中的ker和商集的定义 与 集合论 等价类中ker和商集的定义不一样！</strong></h3><h3 id="1-群论中的“核”和“商群”"><a href="#1-群论中的“核”和“商群”" class="headerlink" title="1. 群论中的“核”和“商群”"></a>1. 群论中的“核”和“商群”</h3><p>在<strong>群论</strong>中，核和商群是与<strong>群同态</strong>相关的概念：</p><ul><li><strong>核（kernel）</strong>：对于一个群同态 f:G→G′<em>f</em>:<em>G</em>→<em>G</em>′，核是那些被映射到目标群 G′<em>G</em>′ 中<strong>单位元</strong>的元素集合。核只包括那些在同态下“失去”区别的元素，它们被看作相等。</li><li><strong>商群（quotient group）</strong>：商群是通过核来构造的，它的元素是<strong>陪集（coset）</strong>。陪集将原群 G<em>G</em> 中那些在同态下被映射到 G′<em>G</em>′ 中同一个元素的所有元素归为一组。商群中的每个元素实际上是原群的一个等价类，这些等价类是根据映射到 G′<em>G</em>′ 中同一元素来分的。</li></ul><h3 id="2-等价关系和等价类中的“核”和“商集”"><a href="#2-等价关系和等价类中的“核”和“商集”" class="headerlink" title="2. 等价关系和等价类中的“核”和“商集”"></a>2. 等价关系和等价类中的“核”和“商集”</h3><p>在<strong>等价关系</strong>和<strong>集合论</strong>中，确实有类似的概念，但定义略有不同：</p><ul><li><strong>等价类</strong>：等价关系是集合中的一种关系，表示两个元素“等价”。如果两个元素通过某个等价关系被认为是等价的，它们属于同一个<strong>等价类</strong>。一个集合可以根据等价关系分成若干个等价类。</li><li><strong>核</strong>：在一些代数结构（如模糊集合、泛代数）中，核可以表示<strong>映射到同一元素的元素集合</strong>。这与你提到的情况类似，即核是那些通过某个映射被映射到相同元素的元素的集合。</li><li>**商集：在等价关系下，商集是将所有等价类作为集合中的单个元素看待的结果。换句话说，商集中的每个元素都是一个等价类，这些等价类包含了原集合中所有相互等价的元素。</li></ul><h3 id="3-二者的异同"><a href="#3-二者的异同" class="headerlink" title="3. 二者的异同"></a>3. 二者的异同</h3><p>尽管<strong>群论</strong>中的核和商群与<strong>集合论</strong>中的核和商集存在一些联系，但它们的定义和使用方式是不同的：</p><ul><li><strong>核的相似点</strong>：在集合论的等价类中，核可以看作是那些通过某个映射或等价关系被归为同一类的元素集合。而在群论中，核是映射到单位元的元素集合，它们也是在映射下“无法区分”的元素。</li><li><strong>商集和商群的区别</strong>：集合论中的<strong>商集</strong>是将等价类视为集合中的单个元素，而<strong>商群</strong>则不仅仅是分类，更是保留了群的结构（运算规则）。群论中的商群不仅是“分类”，还要满足群的运算性质。</li></ul><h3 id="对于群论中ker和商集的理解（相对于集合论，它有什么改变）："><a href="#对于群论中ker和商集的理解（相对于集合论，它有什么改变）：" class="headerlink" title="对于群论中ker和商集的理解（相对于集合论，它有什么改变）："></a>对于群论中ker和商集的理解（相对于集合论，它有什么改变）：</h3><ol><li><strong>为什么核是映射到单位元的元素，而不是映射到其他元素的元素？</strong><ul><li>核的定义就是用来捕捉映射下变成单位元的元素的。这个定义在同态理论中很重要，因为核的性质与同态的性质直接相关。比如，ker⁡(f)ker(<em>f</em>) 的元素决定了哪些元素在同态映射中“无变化”。</li></ul></li><li><strong>映射到其他元素的原群中的元素怎么办？</strong><ul><li>它们没有被“遗弃”，而是通过陪集的方式出现在商群 G&#x2F;ker⁡(f)<em>G</em>&#x2F;ker(<em>f</em>) 中。G<em>G</em> 中每一个映射到 G′<em>G</em>′ 中不同元素 g′∈G′<em>g</em>′∈<em>G</em>′ 的元素对应一个特定的陪集 gker⁡(f)<em>g</em>ker(<em>f</em>)。这就是商群的构造方式，商群中每一个元素（陪集）实际上代表了 G<em>G</em> 中一类被 f<em>f</em> 映射为同一 G′<em>G</em>′ 元素的元素。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 近世代数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>近世代数-001-二元运算及其性质</title>
      <link href="/2024/10/13/%E8%BF%91%E4%B8%96%E4%BB%A3%E6%95%B0-%E4%BA%8C%E5%85%83%E8%BF%90%E7%AE%97%E5%8F%8A%E5%85%B6%E6%80%A7%E8%B4%A8/"/>
      <url>/2024/10/13/%E8%BF%91%E4%B8%96%E4%BB%A3%E6%95%B0-%E4%BA%8C%E5%85%83%E8%BF%90%E7%AE%97%E5%8F%8A%E5%85%B6%E6%80%A7%E8%B4%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h3><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241013103139067.png" alt="image-20241013103139067"></p><p><strong>二元运算的定义</strong>：设S为集合，映射f：SxS-&gt;S称为S上的一个二元运算</p><ul><li>S中任意两个元素都可以进行运算，且运算的结果唯一</li><li>S中任何两个元素的运算结果都属于S，这个性质成为运算的<strong>封闭性</strong></li><li>按照定义，运算的封闭性已经蕴含在定义中</li></ul><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241013104002682.png" alt="image-20241013104002682"></p><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241013104933404.png" alt="image-20241013104933404"></p><p><strong>一元运算的定义</strong>：设S为集合，映射f : S→S 称为S上的一元运算.</p><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241013105049418.png" alt="image-20241013105049418"></p><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241015102834810.png" alt="image-20241015102834810"></p><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241015102847256.png" alt="image-20241015102847256"></p><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241015102857820.png" alt="image-20241015102857820"></p><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241015102908957.png" alt="image-20241015102908957"></p><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241015102918846.png" alt="image-20241015102918846"></p><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241015103014770.png" alt="image-20241015103014770"></p><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241015103032266.png" alt="image-20241015103032266"></p><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241015103057817.png" alt="image-20241015103057817"></p><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241015103728223.png" alt="image-20241015103728223"></p><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241015103810852.png" alt="image-20241015103810852"></p><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241015103834722.png" alt="image-20241015103834722"></p><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241015104002518.png" alt="image-20241015104002518"></p><ul><li>同理，如果一个二元运算有左零元θl，一定有右零元θr吗？</li></ul><p>​答案是否定的，考虑二元运算 x 。y &#x3D;  x</p><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241015104200533.png" alt="image-20241015104200533"></p><p>（1）（2）不一定</p><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241015104618563.png" alt="image-20241015104618563"></p><ul><li><p>如果x有左逆元yl，那x一定有右逆元yr吗?（不一定）</p><p>——单射左可逆，满射右可逆</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 近世代数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>stm32学习笔记001</title>
      <link href="/2024/10/12/stm3201/"/>
      <url>/2024/10/12/stm3201/</url>
      
        <content type="html"><![CDATA[<h1 id="stm32学习笔记001"><a href="#stm32学习笔记001" class="headerlink" title="stm32学习笔记001"></a>stm32学习笔记001</h1><h3 id="新建keil5工程"><a href="#新建keil5工程" class="headerlink" title="新建keil5工程"></a>新建keil5工程</h3><ol><li>装好keil5</li><li>project-&gt;new..project,选择目标文件夹</li><li>选好后把stm32库文件中有关启动和各种库粘贴到starup文件夹下；</li><li>在魔术棒-&gt;c&#x2F;c++里面，添加define 为USE_STDPERIPH_DRIVER,，并把library文件夹添加到includepath里</li></ol><h3 id="寄存器点灯（任务1-1）"><a href="#寄存器点灯（任务1-1）" class="headerlink" title="寄存器点灯（任务1.1）"></a>寄存器点灯（任务1.1）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>  </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    RCC-&gt;APB2ENR = <span class="number">0x00000008</span>;</span><br><span class="line">GPIOB-&gt;CRL = <span class="number">0x00300033</span>;</span><br><span class="line">GPIOB-&gt;ODR = <span class="number">0x00000000</span>; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//若要熄灭，将odr设置为高电平：</span></span><br><span class="line">    <span class="comment">//GPIOB-&gt;ODR = 0x00000001; </span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;<span class="comment">//这里下面要有最后一行空行，否则报错</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>代码解析：</p><ul><li>RCC-&gt;APB2ENR &#x3D; 0x00000008;</li></ul><p>​RCC代表寄存器，APB2ENR代表APB2外设时钟使能寄存器</p><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241012131906762.png" alt="image-20241012131906762"></p><p>​要想使用各个<strong>外设</strong>（定义见文末附录），就要先把这个外设<strong>使能</strong></p><p>​有官方手册可看出，GPIOB口在APB2中使能，且在“3”编号上，把3这个编号赋值1，其他为0，四个一组转换成16进制，得出0x00000008；</p><ul><li>GPIOB-&gt;CRL &#x3D; 0x00300033;</li></ul><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241012132818313.png" alt="image-20241012132818313"></p><p>GPIOx_CRL:       1.x:GPIO 后面的字母   2.CRL的L:LOW,代表低寄存器（H代表高）</p><ul><li>GPIOB-&gt;ODR &#x3D; 0x00000000；</li></ul><p>​<img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241012133231074.png" alt="image-20241012133231074"></p><p>ODR的O:output</p><ul><li>运行结果：</li></ul><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241012150653517.png" alt="image-20241012150653517"></p><h3 id="库函数点灯（任务1-2）："><a href="#库函数点灯（任务1-2）：" class="headerlink" title="库函数点灯（任务1.2）："></a>库函数点灯（任务1.2）：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//pf11</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOF,ENABLE);</span><br><span class="line"><span class="comment">//这句代码相当于寄存器点灯操作时的gpio使能，这里选用gpiof</span></span><br><span class="line"></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructurePF11;</span><br><span class="line"><span class="comment">//创建一个GPIO_InitTypeDef类型的结构体，结构体用于初始化gpio的各个参数</span></span><br><span class="line"><span class="comment">//分别是 mode ，pin ，speed，这三个参数在库文件中均以枚举定义</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">GPIO_InitStructurePF11.GPIO_Mode = GPIO_Mode_Out_PP; <span class="comment">//推挽输出</span></span><br><span class="line">GPIO_InitStructurePF11.GPIO_Pin = GPIO_Pin_11; <span class="comment">//11号引脚</span></span><br><span class="line">GPIO_InitStructurePF11.GPIO_Speed = GPIO_Speed_50MHz; <span class="comment">//速率</span></span><br><span class="line"></span><br><span class="line">GPIO_Init(GPIOF,&amp;GPIO_InitStructurePF11); </span><br><span class="line"><span class="comment">//初始化gpio引脚，第一个参数是GPIOx（实际上是指针），第二个是结构体初始化数组的地址</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">GPIO_ResetBits(GPIOF,GPIO_Pin_11);</span><br><span class="line"><span class="comment">//设置输出为低电平</span></span><br></pre></td></tr></table></figure><p>涉及的可选参数详见附录</p><ul><li>效果：</li></ul><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241012150710945.png" alt="image-20241012150710945"></p><h3 id="GPIO输入输出（任务2）"><a href="#GPIO输入输出（任务2）" class="headerlink" title="GPIO输入输出（任务2）"></a>GPIO输入输出（任务2）</h3><h4 id="读取输入的方法"><a href="#读取输入的方法" class="headerlink" title="读取输入的方法"></a>读取输入的方法</h4><h5 id="读取输入寄存器（IDR）"><a href="#读取输入寄存器（IDR）" class="headerlink" title="读取输入寄存器（IDR）"></a>读取输入寄存器（IDR）</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取GPIO输出的方法----读取它的输入寄存器</span></span><br><span class="line"><span class="comment">//即使goio是输出模式，IDR也能反映它的状态</span></span><br><span class="line"><span class="type">int</span> pinState;</span><br><span class="line"></span><br><span class="line">pinState = (GPIOF-&gt;IDR &amp; GPIO_PIN_x) ? <span class="number">1</span> : <span class="number">0</span>;  <span class="comment">// 读取 GPIOF 11 引脚状态</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//方法2 ---- 库函数GPIO_ReadInputDataBit（基于输入寄存器）</span></span><br><span class="line"><span class="keyword">if</span>(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_0)==Bit_RESET)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//Bit_SET:高电平</span></span><br><span class="line">    <span class="comment">//Bit_RESET:低电平</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="读取输出寄存器（ODR）"><a href="#读取输出寄存器（ODR）" class="headerlink" title="读取输出寄存器（ODR）"></a>读取输出寄存器（ODR）</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接读取输出寄存器（ODR）</span></span><br><span class="line"><span class="type">int</span> pinState;</span><br><span class="line"></span><br><span class="line">pinState = (GPIOF-&gt;ODR &amp; GPIO_PIN_x) ? <span class="number">1</span> : <span class="number">0</span>;  <span class="comment">// 读取 GPIOF 11 引脚状态</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure><h5 id="二者的区别"><a href="#二者的区别" class="headerlink" title="二者的区别"></a>二者的区别</h5><p>IDR反应实际物理状态，ODR反应代码设置的状态（不一定是实际）</p><p>假设有一个 GPIO 引脚配置为输出模式，在代码中设置了它为高电平，但这个引脚连接了一个外部电路，外部电路强行把这个引脚拉低了的话，二者的区别就会显现</p><ul><li><strong>IDR</strong>：反映这个引脚的实际电平为低电平，因为它受到了外部电路的影响。</li><li><strong>ODR</strong>：仍然会反映你在代码中设置的高电平，因为它表示的是你通过 MCU 设置的输出值，而不是实际的电平。</li></ul><h4 id="延时函数的实现"><a href="#延时函数的实现" class="headerlink" title="延时函数的实现"></a>延时函数的实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SysTick_Init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// SystemCoreClock 是系统时钟频率，比如 72 MHz（72000000 Hz）</span></span><br><span class="line">    <span class="comment">// 配置 SysTick 每 1 毫秒触发一次中断</span></span><br><span class="line">    SysTick_Config(SystemCoreClock / <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">uint32_t</span> sysTickCounter = <span class="number">0</span>;<span class="comment">//定义一个计数器</span></span><br><span class="line"><span class="comment">//使用 volatile 关键字是因为该变量会在中断中修改，防止编译器优化</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SysTick_Handler</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (sysTickCounter &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        sysTickCounter--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注意，SysTick_Handler函数在库文件中已经有定义了</span></span><br><span class="line"><span class="comment">//但是内容是空的</span></span><br><span class="line"><span class="comment">//因此，在此库文件中声明extern的计数器变量，然后在库文件中修改此函数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay_ms</span><span class="params">(<span class="type">uint32_t</span> ms)</span> &#123;</span><br><span class="line">    sysTickCounter = ms;</span><br><span class="line">    <span class="keyword">while</span> (sysTickCounter != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 等待延时结束</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>具体过程如下：</p><ol><li><p>sysTickCounter 被设置为延时的毫秒数。</p></li><li><p>每 1 毫秒，SysTick 触发中断，调用 SysTick_Handler() 函数，递减 sysTickCounter</p><p><strong>因此，起到延时作用的是SysTick_Handler() 函数</strong></p></li><li><p>当 sysTickCounter 减到 0 时，while 循环结束，延时函数完成。</p></li></ol><p>SysTick_Handler() 只有在倒计时中每隔 1 毫秒被调用一次，并且只有在 sysTickCounter &gt; 0 时它才会递减计数器。一旦计数器减到 <strong>0</strong>，SysTick_Handler() 仍然会被 1 毫秒触发一次，只不过它不再执行任何递减操作</p><h4 id="总代码如下"><a href="#总代码如下" class="headerlink" title="总代码如下"></a>总代码如下</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>      <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SysTick_Init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    SysTick_Config(SystemCoreClock / <span class="number">1000</span>);</span><br><span class="line">&#125; <span class="comment">//初始化时钟延迟为1ms</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">uint32_t</span> sysTickCounter = <span class="number">0</span>;<span class="comment">//初始化计数器</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay_ms</span><span class="params">(<span class="type">uint32_t</span> ms)</span> &#123;</span><br><span class="line">    sysTickCounter = ms;</span><br><span class="line">    <span class="keyword">while</span> (sysTickCounter != <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//定义delay函数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//RCC-&gt;APB2ENR = 0x00000008;</span></span><br><span class="line">    <span class="comment">//GPIOB-&gt;CRL = 0x00300033;</span></span><br><span class="line">    <span class="comment">//GPIOB-&gt;ODR = 0x00000000;       //寄存器点灯的代码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//__enable_irq();  //启用全局中断（但是不启用也能跑）</span></span><br><span class="line"></span><br><span class="line">    SysTick_Init();<span class="comment">//初始化计时器</span></span><br><span class="line"></span><br><span class="line">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);</span><br><span class="line">    <span class="comment">//使能GPIOB</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//GPIO_InitTypeDef GPIO_InitStructurePB5;</span></span><br><span class="line">    <span class="comment">//GPIO_InitStructurePB5.GPIO_Mode=GPIO_Mode_Out_PP;</span></span><br><span class="line">    <span class="comment">//GPIO_InitStructurePB5.GPIO_Pin=GPIO_Pin_5;</span></span><br><span class="line">    <span class="comment">//GPIO_InitStructurePB5.GPIO_Speed=GPIO_Speed_50MHz;</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//GPIO_Init(GPIOB,&amp;GPIO_InitStructurePB5);</span></span><br><span class="line">    <span class="comment">/////点亮GPIOB5的代码</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化gpio0</span></span><br><span class="line">    GPIO_InitTypeDef GPIO_InitStructurePB0;</span><br><span class="line">    GPIO_InitStructurePB0.GPIO_Mode=GPIO_Mode_Out_PP;</span><br><span class="line">    GPIO_InitStructurePB0.GPIO_Pin=GPIO_Pin_0;</span><br><span class="line">    GPIO_InitStructurePB0.GPIO_Speed=GPIO_Speed_50MHz;</span><br><span class="line"></span><br><span class="line">    GPIO_Init(GPIOB, &amp;GPIO_InitStructurePB0);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    GPIO_ResetBits(GPIOB,GPIO_Pin_0);</span><br><span class="line">    <span class="comment">//³õÊ¼»¯GPIOB0£¬ÇÒ½«ÆäÉèÎªµÍµçÆ½£¨ÁÁµÆ£©</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    GPIO_InitTypeDef GPIO_InitStructurePB1;</span><br><span class="line">    GPIO_InitStructurePB1.GPIO_Mode=GPIO_Mode_Out_PP;</span><br><span class="line">    GPIO_InitStructurePB1.GPIO_Pin=GPIO_Pin_1;</span><br><span class="line">    GPIO_InitStructurePB1.GPIO_Speed=GPIO_Speed_50MHz;</span><br><span class="line"></span><br><span class="line">    GPIO_Init(GPIOB, &amp;GPIO_InitStructurePB1);</span><br><span class="line">    <span class="comment">//³õÊ¼»¯GPIOB1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//pf11（让它常亮吧）</span></span><br><span class="line">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOF,ENABLE);</span><br><span class="line"></span><br><span class="line">    GPIO_InitTypeDef GPIO_InitStructurePF11;</span><br><span class="line">    GPIO_InitStructurePF11.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line">    GPIO_InitStructurePF11.GPIO_Pin = GPIO_Pin_11;</span><br><span class="line">    GPIO_InitStructurePF11.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line"></span><br><span class="line">    GPIO_Init(GPIOF,&amp;GPIO_InitStructurePF11);</span><br><span class="line">    GPIO_ResetBits(GPIOF,GPIO_Pin_11);</span><br><span class="line">    GPIO_SetBits(GPIOB,GPIO_Pin_1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">//判断GPIO0的状态</span></span><br><span class="line">        <span class="keyword">if</span>(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_0)==Bit_RESET)</span><br><span class="line">        &#123;</span><br><span class="line">            Delay_ms(<span class="number">1000</span>);</span><br><span class="line">            GPIO_ResetBits(GPIOB,GPIO_Pin_1);</span><br><span class="line">            GPIO_SetBits(GPIOB,GPIO_Pin_0);</span><br><span class="line">            Delay_ms(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            GPIO_SetBits(GPIOB,GPIO_Pin_1);</span><br><span class="line">            GPIO_ResetBits(GPIOB,GPIO_Pin_0);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>输出演示视频：</p><p><a href="https://lark-video.oss-cn-hangzhou.aliyuncs.com/outputs/prod/yuque/2024/44392709/mp4/1728726330624-46c344cb-e02f-4a81-bc7a-e7395e288175.mp4?OSSAccessKeyId=LTAI4GKnqTWmz2X8mzA1Sjbv&Expires=1729702347&Signature=Z%2F%2BjsbCjdoHoJVjojl2fqPv47LQ%3D">点击查看视频</a></p></li></ul><h3 id="外部中断"><a href="#外部中断" class="headerlink" title="外部中断"></a>外部中断</h3><h4 id="一个按键的"><a href="#一个按键的" class="headerlink" title="一个按键的"></a>一个按键的</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>      <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">uint32_t</span> sysTickCounter = <span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">EXTI_Config</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOF,ENABLE);</span><br><span class="line"></span><br><span class="line"><span class="comment">//灯的初始化</span></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;</span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line"></span><br><span class="line">GPIO_Init(GPIOF,&amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//按键初始化</span></span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;</span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line"></span><br><span class="line">GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">GPIO_EXTILineConfig(GPIO_PortSourceGPIOA,GPIO_PinSource0);<span class="comment">//将GPIOA0连接到EXTI外设</span></span><br><span class="line">EXTI_InitTypeDef EXTI_InitStructure;</span><br><span class="line">EXTI_InitStructure.EXTI_Line=EXTI_Line0;</span><br><span class="line">EXTI_InitStructure.EXTI_LineCmd=ENABLE;</span><br><span class="line">EXTI_InitStructure.EXTI_Mode=EXTI_Mode_Interrupt;</span><br><span class="line">EXTI_InitStructure.EXTI_Trigger=EXTI_Trigger_Falling;</span><br><span class="line"></span><br><span class="line">EXTI_Init(&amp;EXTI_InitStructure);<span class="comment">//初始化EXIT</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//开启NVIC</span></span><br><span class="line">NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);</span><br><span class="line">NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannel = EXTI0_IRQn;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">2</span>;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">2</span>;</span><br><span class="line">NVIC_Init(&amp;NVIC_InitStructure);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">EXTI0_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(EXTI_GetITStatus(EXTI_Line0)==SET)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(GPIO_ReadInputDataBit(GPIOF,GPIO_Pin_11)==Bit_SET)</span><br><span class="line">&#123;</span><br><span class="line">GPIO_ResetBits(GPIOF,GPIO_Pin_11);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">GPIO_SetBits(GPIOF,GPIO_Pin_11);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">EXTI_ClearITPendingBit(EXTI_Line0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">EXTI_Config();</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="两个按键的"><a href="#两个按键的" class="headerlink" title="两个按键的"></a>两个按键的</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>      <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">uint32_t</span> sysTickCounter = <span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">EXTI_Config</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOF,ENABLE);</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE); </span><br><span class="line"></span><br><span class="line"><span class="comment">//灯的初始化</span></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;</span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line"></span><br><span class="line">GPIO_Init(GPIOF,&amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//按键初始化</span></span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;</span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line"></span><br><span class="line">GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二个按键初始化</span></span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1;</span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line"></span><br><span class="line">GPIO_Init(GPIOF,&amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//将GPIOA0连接到exti外设</span></span><br><span class="line">GPIO_EXTILineConfig(GPIO_PortSourceGPIOA,GPIO_PinSource0);</span><br><span class="line">EXTI_InitTypeDef EXTI_InitStructure;</span><br><span class="line">EXTI_InitStructure.EXTI_Line=EXTI_Line0;</span><br><span class="line">EXTI_InitStructure.EXTI_LineCmd=ENABLE;</span><br><span class="line">EXTI_InitStructure.EXTI_Mode=EXTI_Mode_Interrupt;</span><br><span class="line">EXTI_InitStructure.EXTI_Trigger=EXTI_Trigger_Falling;</span><br><span class="line"></span><br><span class="line">EXTI_Init(&amp;EXTI_InitStructure);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将GPIOF1连接到exti外设</span></span><br><span class="line">GPIO_EXTILineConfig(GPIO_PortSourceGPIOF,GPIO_PinSource1);</span><br><span class="line"><span class="comment">//EXTI_InitStructure已经定义，可以直接拿来用</span></span><br><span class="line">EXTI_InitStructure.EXTI_Line=EXTI_Line1;<span class="comment">//换一个中断线路</span></span><br><span class="line">EXTI_InitStructure.EXTI_LineCmd=ENABLE;</span><br><span class="line">EXTI_InitStructure.EXTI_Mode=EXTI_Mode_Interrupt;</span><br><span class="line">EXTI_InitStructure.EXTI_Trigger=EXTI_Trigger_Falling;</span><br><span class="line"></span><br><span class="line">EXTI_Init(&amp;EXTI_InitStructure);</span><br><span class="line"></span><br><span class="line"><span class="comment">//配置NVIC</span></span><br><span class="line">NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);</span><br><span class="line">NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为按键1配置NVIC</span></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannel = EXTI0_IRQn;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">2</span>;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">1</span>;</span><br><span class="line">NVIC_Init(&amp;NVIC_InitStructure);</span><br><span class="line"></span><br><span class="line"><span class="comment">//为按键2配置NVIC</span></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannel = EXTI1_IRQn;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">2</span>;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">2</span>;</span><br><span class="line">NVIC_Init(&amp;NVIC_InitStructure);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">EXTI0_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(EXTI_GetITStatus(EXTI_Line0)==SET)</span><br><span class="line">&#123;</span><br><span class="line">GPIO_ResetBits(GPIOF,GPIO_Pin_11);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EXTI_ClearITPendingBit(EXTI_Line0);<span class="comment">//清空中断标志位</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">EXTI1_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(EXTI_GetITStatus(EXTI_Line1)==SET)</span><br><span class="line">&#123;</span><br><span class="line">GPIO_SetBits(GPIOF,GPIO_Pin_11);</span><br><span class="line">&#125;</span><br><span class="line">EXTI_ClearITPendingBit(EXTI_Line1);<span class="comment">//清空中断标志位</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">EXTI_Config();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="视频："><a href="#视频：" class="headerlink" title="视频："></a>视频：</h4><h5 id="一个按键的："><a href="#一个按键的：" class="headerlink" title="一个按键的："></a>一个按键的：</h5><p><a href="https://bizsec-auth.alicdn.com/d946ca083b65cd66/f80ebf33b1f6af3b/20241012_19fb5ed7c3bece04_486428009028_181701368300603_published_mp4_264_hd_unlimit_taobao.mp4?auth_key=1729699652-0-0-b10db018812c27132b7aed5bbe6515e9&biz=video-d63683b96e69ef50&t=213da87517296969520431973e1658&t=213da87517296969520431973e1658&b=video&p=cloudvideo_http_from_v1_800000012">点击查看视频</a></p><h5 id="两个按键的："><a href="#两个按键的：" class="headerlink" title="两个按键的："></a>两个按键的：</h5><p><a href="https://cloud.video.taobao.com/play/u/44392709/p/1/d/ld/e/6/t/1/486428009029.mp4?auth_key=YXBwX2tleT04MDAwMDAwMTImYXV0aF9pbmZvPXsidGltZXN0YW1wRW5jcnlwdGVkIjoiNGM3MWFhYWJlNDAyZWFjNDUwZGFmMjI3MzM5MGQ1N2EifSZkdXJhdGlvbj0mdGltZXN0YW1wPTE3Mjk2OTUxNDc=">点击查看视频</a></p><h2 id="附录（信息整合）"><a href="#附录（信息整合）" class="headerlink" title="附录（信息整合）"></a>附录（信息整合）</h2><h3 id="外设相关信息"><a href="#外设相关信息" class="headerlink" title="外设相关信息"></a>外设相关信息</h3><ul><li><ul><li><h3 id="1-GPIO（通用输入输出接口）"><a href="#1-GPIO（通用输入输出接口）" class="headerlink" title="1. GPIO（通用输入输出接口）"></a>1. <strong>GPIO（通用输入输出接口）</strong></h3><h4 id="功能："><a href="#功能：" class="headerlink" title="功能："></a>功能：</h4><p>GPIO 是 STM32 控制器中最基本的外设之一，用于控制设备与外部电路之间的数字信号交互。每个 GPIO 引脚都可以独立配置为输入、输出、模拟模式或用于特定外设的功能复用模式（如 USART、I2C 等）。</p><h4 id="常见用途："><a href="#常见用途：" class="headerlink" title="常见用途："></a>常见用途：</h4><ul><li><strong>数字输入</strong>：读取按键、开关或传感器状态。</li><li><strong>数字输出</strong>：控制 LED、继电器、蜂鸣器等。</li><li><strong>PWM 输出</strong>：控制电机速度、LED 亮度。</li><li><strong>外部中断</strong>：用于检测引脚电平变化（如按键按下或松开时触发中断）。</li></ul><h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><ul><li><p>模式配置</p><p>：</p><ul><li><strong>输入模式</strong>：可以配置为浮空输入、上拉输入或下拉输入。</li><li><strong>输出模式</strong>：支持推挽输出和开漏输出，适合驱动不同类型的负载。</li><li><strong>模拟模式</strong>：用于连接模拟信号输入，如 ADC（模数转换器）的模拟信号通道。</li><li><strong>复用功能</strong>：引脚可以作为外设的信号引脚使用，如 USART 的 TX&#x2F;RX。</li></ul></li><li><p><strong>外部中断</strong>：支持引脚的上升沿、下降沿或双边沿触发中断事件，允许系统对外部事件做出快速响应。</p></li><li><p><strong>快速切换</strong>：GPIO 引脚的状态可以通过寄存器快速读取和修改，具备高效的响应能力。</p></li></ul><h4 id="实际应用："><a href="#实际应用：" class="headerlink" title="实际应用："></a>实际应用：</h4><p>配置 GPIO 为输出模式控制一个 LED，当按键按下时通过外部中断机制点亮 LED。</p></li></ul></li></ul><pre><code>------   ### 2. **USART / UART（通用异步收发器）**   #### 功能：   USART（Universal Synchronous Asynchronous Receiver Transmitter）或 UART 是常用于串行通信的外设，支持异步和同步通信。它通常用于与计算机、外部模块或其他微控制器之间的通信。   #### 常见用途：   - **调试接口**：将调试信息发送到串口终端，帮助开发人员实时查看系统运行状态。   - **模块通信**：与蓝牙模块、GPS 模块、GSM 模块等外设进行数据交互。   - **设备通信**：与传感器、执行器、其他微控制器通信。   #### 特点：   - **波特率**：支持多种波特率设置（如 9600、115200），可以适应不同速度的通信需求。   - 数据格式     ：灵活设置数据位、停止位、校验位等，适应不同协议需求。     - 常见配置：8 数据位、1 停止位、无校验位。   - **硬件流控**：支持 RTS/CTS 硬件流控，减少数据丢失风险，特别适合高速通信。   - **中断和 DMA 支持**：可以通过中断或 DMA 传输数据，减少 CPU 负担，提高系统效率。   - **多处理器模式**：允许多处理器间的串行通信，通过地址标识进行选择性通信。   #### 实际应用：   使用 STM32 的 `USART2` 端口与计算机串口终端通信，将传感器数据通过 UART 发送到终端，以进行实时监控。------   ### 3. **SPI（串行外设接口）**   #### 功能：   SPI（Serial Peripheral Interface）是一种高速的同步串行通信接口，通常用于与外部传感器、存储设备（如 EEPROM、Flash）和显示器等外设进行通信。STM32 的 SPI 接口支持全双工通信，可以同时发送和接收数据。   #### 常见用途：   - **存储器通信**：与 SPI 闪存或 EEPROM 进行高速读写操作。   - **显示器控制**：与 OLED、LCD 屏幕进行通信，快速刷新显示内容。   - **传感器数据读取**：获取 MEMS 传感器、加速度计、陀螺仪等传感器的数据。   - **音频模块**：通过 SPI 与音频芯片通信，进行音频数据的传输和控制。   #### 特点：   - **主从模式**：SPI 支持主从通信模式，STM32 可以配置为主设备或从设备。   - **高数据速率**：SPI 的通信速率可达几十 MHz，适合高速数据传输应用。   - **全双工通信**：支持同时发送和接收数据，适合需要高速双向通信的场景。   - **多从设备支持**：通过片选引脚（CS），可以连接多个从设备，灵活控制不同的外设。   #### 实际应用：   使用 STM32 作为主设备，通过 SPI 接口读取外部 EEPROM 的数据，或者驱动 OLED 显示屏显示图像数据。------   ### 4. **I2C（集成电路互联）**   #### 功能：   I2C 是一种常用的双线串行通信协议，适用于低速外围设备（如传感器、存储器、RTC 模块）的通信。它只需要两根线：SCL（时钟）和 SDA（数据），即可在多主多从架构中进行通信。   #### 常见用途：   - **传感器通信**：与温度传感器、压力传感器等低速设备通信。   - **存储器接口**：如 I2C EEPROM，用于存储配置信息或日志。   - **RTC（实时时钟）模块**：读取实时时钟的日期和时间信息。   - **显示模块**：驱动 I2C 协议的 OLED 或 LCD 显示屏。   #### 特点：   - **双线通信**：使用 SDA 和 SCL 两条线，减少通信接口数量。   - **多主多从支持**：允许多个设备同时连接到同一条总线上，支持多主设备通信。   - **地址识别**：每个从设备都有唯一的 7 位或 10 位地址，主设备通过地址访问特定从设备。   - **多种通信速率**：支持标准模式（100kHz）、快速模式（400kHz）和高速模式（1MHz）。   #### 实际应用：   使用 STM32 的 I2C 接口与温度传感器通信，周期性读取环境温度，并通过串口将数据发送到电脑进行监控。------   ### 5. **ADC（模数转换器）**   #### 功能：   ADC（Analog to Digital Converter）用于将模拟信号转换为数字信号，是读取传感器等模拟设备数据的重要接口。STM32 的 ADC 通常具有多通道和高分辨率的特点，适用于高精度的模拟信号采集。   #### 常见用途：   - **传感器信号采集**：采集温度传感器、电位器等模拟设备的信号。   - **电压监测**：监测电池电压、电源电压等，防止过充或欠压情况。   - **音频输入**：在音频处理应用中，采集麦克风或音频信号。   - **环境监测**：用于光照强度、气体浓度等的模拟数据读取。   #### 特点：   - **多通道支持**：STM32 的 ADC 通常支持多通道采样，可以轮询多个模拟信号源。   - **高分辨率**：支持 12 位甚至 16 位分辨率，确保高精度的数据转换。   - **连续转换模式**：可以配置为连续采样模式，持续采集模拟信号。   - **DMA 支持**：与 DMA 协同工作，允许大数据量的自动采集而无需占用 CPU。   - **采样时间可调**：可以根据不同输入信号源的阻抗调整采样时间，确保准确性。   #### 实际应用：   使用 ADC 接口读取电位器的模拟信号，通过 ADC 转换为数字信号后进行处理，调整系统的输出参数，如控制 LED 的亮度或调整电机转速。------   ### 6. **TIM（定时器）**   #### 功能：   定时器（TIM）是 STM32 中非常强大的外设，支持计时、事件控制、PWM 生成、输入捕获、输出比较等功能。STM32 中有多种类型的定时器，可用于不同的任务。   #### 常见用途：   - **时间延迟**：生成精确的时间延迟，用于定时任务或周期性中断。   - **PWM 生成**：控制电机转速、调光 LED 亮度、音频输出等。   - **输入捕获**：测量输入信号的脉冲宽度或频率，如测速应用。   - **事件计数**：用于记录外部事件的发生次数，如脉冲计数。   #### 特点：   - **多种模式**：支持单次计时、周期性计时等多种模式。   - **高精度计时**：可以通过定时器预分频器实现高精度时间控制，支持从微秒级别到数秒级别的计时任务。   - **PWM 输出**：定时器支持多通道 PWM 输出，可以同时控制多个设备，如控制多路 LED 的亮度或多轴电机的速度。   - **输入捕获/输出比较**：输入捕获用于精确测量输入信号的时间特性，输出比较用于在特定时间输出控制信号。   #### 实际应用：   配置 STM32 的 TIM 定时器生成 PWM 信号控制直流电机的转速，或者通过输入捕获功能测量外部信号的频率。</code></pre><h3 id="GPIO-InitTypeDef，EXTI-InitTypeDef，NVIC-InitTypeDef等常用的def的各个参数及使用方法"><a href="#GPIO-InitTypeDef，EXTI-InitTypeDef，NVIC-InitTypeDef等常用的def的各个参数及使用方法" class="headerlink" title="GPIO_InitTypeDef，EXTI_InitTypeDef，NVIC_InitTypeDef等常用的def的各个参数及使用方法"></a>GPIO_InitTypeDef，EXTI_InitTypeDef，NVIC_InitTypeDef等常用的def的各个参数及使用方法</h3><h3 id="1-GPIO-InitTypeDef"><a href="#1-GPIO-InitTypeDef" class="headerlink" title="1. GPIO_InitTypeDef"></a>1. <strong>GPIO_InitTypeDef</strong></h3><p><code>GPIO_InitTypeDef</code> 是用于配置 GPIO 引脚的结构体。它的成员变量决定了引脚的工作模式、输出类型、速度以及上下拉电阻配置。</p><h4 id="结构体定义："><a href="#结构体定义：" class="headerlink" title="结构体定义："></a>结构体定义：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">  uint32_t GPIO_Pin;        // GPIO 引脚号</span><br><span class="line">  GPIOMode_TypeDef GPIO_Mode; // GPIO 模式（输入、输出、复用、模拟）</span><br><span class="line">  GPIOSpeed_TypeDef GPIO_Speed; // GPIO 速度</span><br><span class="line">  GPIOOType_TypeDef GPIO_OType; // GPIO 输出类型（推挽/开漏）</span><br><span class="line">  GPIOPuPd_TypeDef GPIO_PuPd;   // GPIO 上拉/下拉电阻配置</span><br><span class="line">&#125; GPIO_InitTypeDef;</span><br></pre></td></tr></table></figure><h4 id="参数说明："><a href="#参数说明：" class="headerlink" title="参数说明："></a>参数说明：</h4><ul><li>**<code>GPIO_Pin</code>**：指定要配置的 GPIO 引脚。可以是以下常量的组合，用于同时配置多个引脚：<ul><li><code>GPIO_Pin_0</code>, <code>GPIO_Pin_1</code>, <code>GPIO_Pin_2</code>, …, <code>GPIO_Pin_15</code>。</li></ul></li><li>**<code>GPIO_Mode</code>**：设置引脚的工作模式。可以选择以下模式：<ul><li><code>GPIO_Mode_IN</code>：输入模式。</li><li><code>GPIO_Mode_OUT</code>：输出模式。</li><li><code>GPIO_Mode_AF</code>：复用模式（用于外设，如 USART、SPI 等）。</li><li><code>GPIO_Mode_AN</code>：模拟模式（用于 ADC）。</li></ul></li><li>**<code>GPIO_Speed</code>**：配置引脚的速度，主要用于输出模式。速度取决于应用需求以及外设要求：<ul><li><code>GPIO_Speed_2MHz</code>：低速（2MHz）。</li><li><code>GPIO_Speed_25MHz</code>：中速（25MHz）。</li><li><code>GPIO_Speed_50MHz</code>：高速（50MHz）。</li><li><code>GPIO_Speed_100MHz</code>：非常高速（100MHz）。</li></ul></li><li>**<code>GPIO_OType</code>**：输出类型，决定引脚是推挽还是开漏输出。主要用于输出模式：<ul><li><code>GPIO_OType_PP</code>：推挽输出。</li><li><code>GPIO_OType_OD</code>：开漏输出。</li></ul></li><li>**<code>GPIO_PuPd</code>**：配置上拉或下拉电阻，主要用于输入模式：<ul><li><code>GPIO_PuPd_NOPULL</code>：无上拉或下拉电阻。</li><li><code>GPIO_PuPd_UP</code>：上拉电阻。</li><li><code>GPIO_PuPd_DOWN</code>：下拉电阻。</li></ul></li></ul><h4 id="使用示例："><a href="#使用示例：" class="headerlink" title="使用示例："></a>使用示例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);  // 使能 GPIOA 时钟</span><br><span class="line"></span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5;              // 配置 PA5 引脚</span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;          // 输出模式</span><br><span class="line">GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;         // 推挽输出</span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;      // 50MHz 速度</span><br><span class="line">GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;       // 无上拉/下拉</span><br><span class="line">GPIO_Init(GPIOA, &amp;GPIO_InitStructure);                 // 初始化 GPIOA 引脚</span><br></pre></td></tr></table></figure><h3 id="2-EXTI-InitTypeDef"><a href="#2-EXTI-InitTypeDef" class="headerlink" title="2. EXTI_InitTypeDef"></a>2. <strong>EXTI_InitTypeDef</strong></h3><p><code>EXTI_InitTypeDef</code> 用于配置外部中断（EXTI），STM32 的 EXTI 模块可以通过 GPIO 引脚引发外部中断。</p><h4 id="结构体定义：-1"><a href="#结构体定义：-1" class="headerlink" title="结构体定义："></a>结构体定义：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">  uint32_t EXTI_Line;    // 外部中断线</span><br><span class="line">  EXTIMode_TypeDef EXTI_Mode; // 中断模式或事件模式</span><br><span class="line">  EXTITrigger_TypeDef EXTI_Trigger; // 中断触发条件（上升沿、下降沿、双边沿）</span><br><span class="line">  FunctionalState EXTI_LineCmd;     // 外部中断使能或禁用</span><br><span class="line">&#125; EXTI_InitTypeDef;</span><br></pre></td></tr></table></figure><h4 id="参数说明：-1"><a href="#参数说明：-1" class="headerlink" title="参数说明："></a>参数说明：</h4><ul><li>**<code>EXTI_Line</code>**：指定要配置的 EXTI 线，范围从 <code>EXTI_Line0</code> 到 <code>EXTI_Line15</code>，对应不同的 GPIO 引脚（例如，<code>EXTI_Line0</code> 对应 GPIO 0 号引脚）。</li><li>**<code>EXTI_Mode</code>**：配置 EXTI 的模式，可以是以下两种：<ul><li><code>EXTI_Mode_Interrupt</code>：中断模式。</li><li><code>EXTI_Mode_Event</code>：事件模式，不产生中断，但可以触发事件。</li></ul></li><li>**<code>EXTI_Trigger</code>**：设置中断触发条件，可以选择以下触发条件：<ul><li><code>EXTI_Trigger_Rising</code>：上升沿触发。</li><li><code>EXTI_Trigger_Falling</code>：下降沿触发。</li><li><code>EXTI_Trigger_Rising_Falling</code>：上升沿和下降沿都触发。</li></ul></li><li>**<code>EXTI_LineCmd</code>**：用于使能或禁用 EXTI 线：<ul><li><code>ENABLE</code>：使能 EXTI 线。</li><li><code>DISABLE</code>：禁用 EXTI 线。</li></ul></li></ul><h4 id="使用示例：-1"><a href="#使用示例：-1" class="headerlink" title="使用示例："></a>使用示例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">EXTI_InitTypeDef EXTI_InitStructure;</span><br><span class="line"></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);  // 使能 SYSCFG 时钟</span><br><span class="line">SYSCFG_EXTILineConfig(EXTI_PortSourceGPIOA, EXTI_PinSource0); // 将 PA0 配置为 EXTI_Line0</span><br><span class="line"></span><br><span class="line">EXTI_InitStructure.EXTI_Line = EXTI_Line0;              // 配置 EXTI Line0</span><br><span class="line">EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;     // 中断模式</span><br><span class="line">EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising;  // 上升沿触发</span><br><span class="line">EXTI_InitStructure.EXTI_LineCmd = ENABLE;               // 使能 EXTI Line0</span><br><span class="line">EXTI_Init(&amp;EXTI_InitStructure);                         // 初始化 EXTI</span><br></pre></td></tr></table></figure><h3 id="3-NVIC-InitTypeDef"><a href="#3-NVIC-InitTypeDef" class="headerlink" title="3. NVIC_InitTypeDef"></a>3. <strong>NVIC_InitTypeDef</strong></h3><p><code>NVIC_InitTypeDef</code> 用于配置嵌套向量中断控制器 (NVIC)，用于管理中断优先级并使能中断请求。</p><h4 id="结构体定义：-2"><a href="#结构体定义：-2" class="headerlink" title="结构体定义："></a>结构体定义：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">  uint8_t NVIC_IRQChannel; // 要配置的中断通道</span><br><span class="line">  uint8_t NVIC_IRQChannelPreemptionPriority; // 抢占优先级</span><br><span class="line">  uint8_t NVIC_IRQChannelSubPriority;        // 响应优先级</span><br><span class="line">  FunctionalState NVIC_IRQChannelCmd;        // 中断使能或禁用</span><br><span class="line">&#125; NVIC_InitTypeDef;</span><br></pre></td></tr></table></figure><h4 id="参数说明：-2"><a href="#参数说明：-2" class="headerlink" title="参数说明："></a>参数说明：</h4><ul><li>**<code>NVIC_IRQChannel</code>**：指定要配置的中断通道。例如：<ul><li><code>EXTI0_IRQn</code>：EXTI Line0 的中断。</li><li><code>TIM2_IRQn</code>：TIM2 定时器的中断。</li></ul></li><li>**<code>NVIC_IRQChannelPreemptionPriority</code>**：设置抢占优先级，数值越低优先级越高。在 STM32F4 中通常支持 4 位优先级划分。</li><li>**<code>NVIC_IRQChannelSubPriority</code>**：设置响应优先级，用于同一抢占优先级下的多个中断之间的调度，数值越低优先级越高。</li><li>**<code>NVIC_IRQChannelCmd</code>**：使能或禁用中断通道：<ul><li><code>ENABLE</code>：使能中断通道。</li><li><code>DISABLE</code>：禁用中断通道。</li></ul></li></ul><h4 id="使用示例：-2"><a href="#使用示例：-2" class="headerlink" title="使用示例："></a>使用示例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line"></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannel = EXTI0_IRQn;                   // 配置 EXTI Line0 中断</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x01;        // 抢占优先级 1</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x01;               // 响应优先级 1</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;                     // 使能中断</span><br><span class="line">NVIC_Init(&amp;NVIC_InitStructure);                                     // 初始化 NVIC</span><br></pre></td></tr></table></figure><hr><h3 id="综合示例：外部中断配置"><a href="#综合示例：外部中断配置" class="headerlink" title="综合示例：外部中断配置"></a>综合示例：外部中断配置</h3><p>假设我们要配置一个按键中断，按下按键时通过 EXTI 触发 PA0 引脚的中断，以下是完整的配置流程：</p><ol><li><strong>配置 GPIO 引脚为输入模式</strong>：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);</span><br><span class="line"></span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;            // 配置 PA0</span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;         // 输入模式</span><br><span class="line">GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;     // 无上拉/下拉</span><br><span class="line">GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span><br></pre></td></tr></table></figure><ol><li><strong>配置 EXTI</strong>：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">EXTI_InitTypeDef EXTI_InitStructure;</span><br><span class="line"></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);</span><br><span class="line">SYSCFG_EXTILineConfig(EXTI_PortSourceGPIOA, EXTI_PinSource0);  // 配置 EXTI Line0 对应 PA0</span><br><span class="line"></span><br><span class="line">EXTI_InitStructure.EXTI_Line = EXTI_Line0;                    // 配置 EXTI Line0</span><br><span class="line">EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;           // 中断模式</span><br><span class="line">EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising;        // 上升沿触发</span><br><span class="line">EXTI_InitStructure.EXTI_LineCmd = ENABLE;                     // 使能 EXTI Line0</span><br><span class="line">EXTI_Init(&amp;EXTI_InitStructure);</span><br></pre></td></tr></table></figure><ol><li><strong>配置 NVIC</strong>：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line"></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannel = EXTI0_IRQn;               // 配置 EXTI0 中断</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x00;   // 抢占优先级 0</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x00;          // 响应优先级 0</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;                // 使能中断</span><br><span class="line">NVIC_Init(&amp;NVIC_InitStructure);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈和队列</title>
      <link href="/2024/09/23/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
      <url>/2024/09/23/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h4 id="栈的顺序存储实现"><a href="#栈的顺序存储实现" class="headerlink" title="栈的顺序存储实现"></a>栈的顺序存储实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> STACK_INIT_SIZE 80</span></span><br><span class="line">#DEFINE STACK_INCREMENT <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    elemtype *base;</span><br><span class="line">    elemtype *top;</span><br><span class="line">    <span class="type">int</span> stacksize;<span class="comment">//栈长度（有多少元素），不是sizeof</span></span><br><span class="line">&#125;SqStack;</span><br><span class="line"></span><br><span class="line">Sqstack s;</span><br><span class="line"></span><br><span class="line">Status <span class="title function_">StackInit</span> <span class="params">(Sqstack *s)</span> <span class="comment">//传入结构体指针变量</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!(s-&gt;base = (elemtype*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(elemtype)*STACK_INIT_SIZE)))</span><br><span class="line">        <span class="comment">//对于线性表，分配内存空间是给L直接分配，因为L自身的含义就是头指针的地址，并且线性表是多个结构体指针变量连起来的，而对于顺序栈来说，他只有一个正常的结构体，结构体里面才包含头尾指针，所有的操作都是在这个结构体内部，使用这一个结构体的成员变量完成的</span></span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">    s-&gt;top = s-&gt;base;</span><br><span class="line">    <span class="keyword">return</span> OK;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="顺序栈的使用"><a href="#顺序栈的使用" class="headerlink" title="顺序栈的使用"></a>顺序栈的使用</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//入栈</span></span><br><span class="line">Status <span class="title function_">Push</span><span class="params">(Sqstack *s, elemtype e)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//第一步，先处理一下栈容量够不够的问题</span></span><br><span class="line">    <span class="keyword">if</span>(s-&gt;top-s-&gt;base &gt;= s-&gt;stacksize )<span class="comment">//c语言指针的运算，减出来结果等于sizeof(elemtype)</span></span><br><span class="line">    &#123;</span><br><span class="line">        s-&gt;base = (elemtype*)<span class="built_in">realloc</span>(s-&gt;base,(stacksize+STACK_INCREMENT)*<span class="keyword">sizeof</span>(elemtype));</span><br><span class="line">        <span class="keyword">if</span>(!(s-&gt;base))</span><br><span class="line">            <span class="keyword">return</span> ERROR;</span><br><span class="line">        s-&gt;top = s-&gt;base + s-&gt;stacksize;</span><br><span class="line">        s-&gt;stacksize += STACK_INCREMENT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//入栈</span></span><br><span class="line">    *(s-&gt;top) = e;  <span class="comment">//正确的解引用方式，不要把它写成   s-&gt; *top  ,这不是正确的解引用方式</span></span><br><span class="line">    s -&gt; top++;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈</span></span><br><span class="line">Status <span class="title function_">Pop</span><span class="params">(Sqstack *s, elemtype*e)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//第一步，先判断栈是否为空</span></span><br><span class="line">    <span class="keyword">if</span>(s-&gt;base == s-&gt;top)</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="comment">//出栈</span></span><br><span class="line">    *e = *(--(s -&gt; top));  <span class="comment">//同样的，对top进行操作，现在前面加上s-&gt;,而不是写成  s-&gt; --top</span></span><br><span class="line">   *(s-&gt;top) = <span class="number">0</span>; <span class="comment">//这一步可以省略</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="链栈的实现"><a href="#链栈的实现" class="headerlink" title="链栈的实现"></a>链栈的实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    elemtype data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;SNode,*LinkStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//init</span></span><br><span class="line">LinkStack s;</span><br><span class="line"></span><br><span class="line">Status <span class="title function_">LinkStackInit</span> <span class="params">(LinkStack *s)</span> <span class="comment">//如果使用&amp;s，则函数内可以直接使用s，</span></span><br><span class="line">     <span class="comment">//不用加*号，使用指针的话则必须加上*号</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!(*s = (SNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SNode))))</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    （*s） -&gt; next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="链栈的基本使用"><a href="#链栈的基本使用" class="headerlink" title="链栈的基本使用"></a>链栈的基本使用</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//入栈</span></span><br><span class="line">Status <span class="title function_">Push</span><span class="params">(LinkStack *s, elemtype e)</span></span><br><span class="line">&#123;</span><br><span class="line">    SNode* p;</span><br><span class="line">    <span class="keyword">if</span>(!(p=(SNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SNode))))</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    p-&gt;next = *s;</span><br><span class="line">    p-&gt;data = e;</span><br><span class="line">    *s = p;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈</span></span><br><span class="line">Status <span class="title function_">Pop</span><span class="params">(LinkStack *s, elemtype *e)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(*s == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> EMPTY;</span><br><span class="line">    *e = (*s)-&gt;data;</span><br><span class="line">    LinkStack p = *s;</span><br><span class="line">    *s = (*s)-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> OK;       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="栈的应用举例"><a href="#栈的应用举例" class="headerlink" title="栈的应用举例"></a>栈的应用举例</h4><h5 id="数制转换"><a href="#数制转换" class="headerlink" title="数制转换"></a>数制转换</h5><p>数值转换的思路都是把一个数不断除以进制n，<strong>从晚到早</strong> 的余数排列就是  <strong>从高到低</strong> 的新数位</p><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20240924203654511.png" alt="image-20240924203654511"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a; <span class="comment">//进制</span></span><br><span class="line">    <span class="type">int</span> num; <span class="comment">//数字</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;num);</span><br><span class="line">        </span><br><span class="line">    LinkStack s = <span class="literal">NULL</span>; <span class="comment">//初始化栈顶指针要让他为NULL</span></span><br><span class="line">    <span class="keyword">while</span>(num &gt; <span class="number">0</span>)  <span class="comment">//如果这个地方用 num%a!=0 作为判断条件，有可能回导致最后一次判断失误（如果正好除尽）</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> b = num%a;</span><br><span class="line">        num /= a;</span><br><span class="line">        Push(&amp;s,b);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">while</span>(s != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> temp;</span><br><span class="line">        pop(&amp;s,&amp;temp);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,temp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="括号匹配的检验"><a href="#括号匹配的检验" class="headerlink" title="括号匹配的检验"></a>括号匹配的检验</h5><p>设计算法检验表达式中所使用括号的合法性</p><p>思路：括号的合法，指的就是  左右成对出现，也就是</p><p>一直入栈，如果上一个左括号和下一个右括号匹配，则二者出栈，看最后能不能出完</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">&#125;SNode,*LinkStack;</span><br><span class="line">pop(LinkStack *s,<span class="type">char</span>*e); <span class="comment">//出栈</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(*s == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> EMPTY;</span><br><span class="line">    *e = (*s)-&gt;data;</span><br><span class="line">    LinkStack p = *s;</span><br><span class="line">    *s = (*s)-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> OK;  </span><br><span class="line">&#125;</span><br><span class="line">push(LinkStack *s); <span class="comment">//入栈</span></span><br><span class="line">&#123;</span><br><span class="line">    SNode* p;</span><br><span class="line">    <span class="keyword">if</span>(!(p=(SNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SNode))))</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    p-&gt;next = *s;</span><br><span class="line">    p-&gt;data = e;</span><br><span class="line">    *s = p;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line">getelem(LinkStack s); <span class="comment">//读取当前栈顶元素，但是不取出</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">50</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str);</span><br><span class="line">    <span class="type">int</span> i =<span class="number">0</span>;</span><br><span class="line">    LinkStack s = <span class="literal">NULL</span>;<span class="comment">//初始化为空，切记</span></span><br><span class="line">    <span class="keyword">while</span>(str[i]!=<span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (str[i] == <span class="string">&#x27;(&#x27;</span> || str[i] ==<span class="string">&#x27;[&#x27;</span> || str[i] == <span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            push(&amp;s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(str[i] == <span class="string">&#x27;)&#x27;</span> || str[i] ==<span class="string">&#x27;]&#x27;</span> || str[i] == <span class="string">&#x27;&#125;&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i] == <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">char</span> c;</span><br><span class="line">                getelem(s,&amp;c);</span><br><span class="line">                <span class="keyword">if</span>(c == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                    pop(&amp;s);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(str[i] == <span class="string">&#x27;]&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">char</span> c;</span><br><span class="line">                getelem(s,&amp;c);</span><br><span class="line">                <span class="keyword">if</span>(c == <span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">                    pop(&amp;s);</span><br><span class="line">            &#125;            </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(str[i] == <span class="string">&#x27;&#125;&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">char</span> c;</span><br><span class="line">                getelem(s,&amp;c);</span><br><span class="line">                <span class="keyword">if</span>(c == <span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line">                    pop(&amp;s);</span><br><span class="line">            &#125;            </span><br><span class="line">&#125;</span><br><span class="line">        i++;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">if</span>(isEmpty(s))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;CORRECT&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SOMETHING WENT WRONG&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迷宫问题</p><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20240925155124181.png" alt="image-20240925155124181"></p><p>思路：</p><ol><li>先确定一个顺序（如，对于一个元素而言，在其周围遍历的顺序是从右上角开始，顺时针）</li><li>建立一个栈，这个栈用来存放当前坐标信息，对于一个元素而言，找到一个0，就把这个0入栈，然后把这个0 当作当前的中心，同时把上一个0标记成-1，代表出口不能从他这找</li><li>如果当前的0周围没有找到出口，那么退栈，重新以上一个0为中心继续找周围下一个0进行尝试，如果一圈都不行，把这个也退栈，以此类推</li><li>为了让这个算法能够适用于迷宫阵的角角落落，把周围一圈补上1</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> STACK_INIT_SIZE 80</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STACK_INCREASMENT 10</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ROW 7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COL 8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> Stack[STACK_INIT_SIZE][<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> *base;</span><br><span class="line">    <span class="type">int</span> *top;</span><br><span class="line">&#125;SNode;</span><br><span class="line"></span><br><span class="line">SNode s;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义迷宫数组</span></span><br><span class="line"><span class="type">int</span> maze[ROW][COL] = &#123;</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,  </span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> maze_after[ROW+<span class="number">2</span>][COL+<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">maze_increase</span><span class="params">(<span class="type">int</span>(*maze)[COL], <span class="type">int</span>(*maze_after)[COL+<span class="number">2</span>])</span><span class="comment">//用指针传递二维数组的方法</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= (ROW + <span class="number">1</span>); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= (COL + <span class="number">1</span>); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || i == (ROW + <span class="number">1</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                maze_after[i][j] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span> || j == (COL + <span class="number">1</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                maze_after[i][j] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                maze_after[i][j] = maze[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//test</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= ROW+<span class="number">1</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= COL+<span class="number">1</span>; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, maze_after[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//现在，maze_after已经是修正以后的迷宫了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面是迷宫具体算法</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">check</span><span class="params">(SNode s, <span class="type">int</span>(*maze_after)[COL + <span class="number">2</span>])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">1</span>; <span class="comment">//标记行位置</span></span><br><span class="line">    <span class="type">int</span> y = <span class="number">1</span>; <span class="comment">//标记列位置</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>; <span class="comment">//标记栈元素个数</span></span><br><span class="line">    s.Stack[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">//栈初始化第一个元素（起点行）</span></span><br><span class="line">    s.Stack[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;<span class="comment">//（起点列）</span></span><br><span class="line">    maze_after[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">-1</span>; <span class="comment">//标记起点位置为走过的</span></span><br><span class="line">    <span class="keyword">while</span> (s.Stack[<span class="number">0</span>][<span class="number">0</span>] != <span class="number">0</span>) <span class="comment">//只要别没有路，导致把起点给退栈了，就一直循环</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.Stack[i - <span class="number">1</span>][<span class="number">0</span>] == ROW &amp;&amp; s.Stack[i - <span class="number">1</span>][<span class="number">1</span>] == COL) <span class="comment">//栈走到终点了</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;找到一条\n&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> n = <span class="number">0</span>; n &lt;= i; n++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d,%d\n&quot;</span>, s.Stack[n][<span class="number">0</span>], s.Stack[n][<span class="number">1</span>]); <span class="comment">//输出栈</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (maze_after[x][y] == <span class="number">0</span> || maze_after[x][y] == <span class="number">-1</span>) <span class="comment">//当前的元素自身是通路</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;当前以x=%d,y=%d为中心\n&quot;</span>,x, y);</span><br><span class="line">            maze_after[x][y] = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span> (maze_after[x - <span class="number">1</span>][y + <span class="number">1</span>] == <span class="number">0</span>)  <span class="comment">//如果右上方的是通路，开始入栈</span></span><br><span class="line">            &#123;</span><br><span class="line">                i++; </span><br><span class="line">                s.Stack[i][<span class="number">0</span>] = x - <span class="number">1</span>;</span><br><span class="line">                s.Stack[i][<span class="number">1</span>] = y + <span class="number">1</span>;</span><br><span class="line">                x--;</span><br><span class="line">                y++;</span><br><span class="line">                maze[x - <span class="number">1</span>][y + <span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;    x=%d,y=%d进栈了\n&quot;</span>, x, y);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (maze_after[x][y + <span class="number">1</span>] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                i++;</span><br><span class="line">                s.Stack[i][<span class="number">0</span>] = x;</span><br><span class="line">                s.Stack[i][<span class="number">1</span>] = y + <span class="number">1</span>;</span><br><span class="line">                y++;</span><br><span class="line">                maze[x][y + <span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;    x=%d,y=%d进栈了\n&quot;</span>, x, y);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (maze_after[x + <span class="number">1</span>][y + <span class="number">1</span>] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                i++;</span><br><span class="line">                s.Stack[i][<span class="number">0</span>] = x + <span class="number">1</span>;</span><br><span class="line">                s.Stack[i][<span class="number">1</span>] = y + <span class="number">1</span>;</span><br><span class="line">                x++;</span><br><span class="line">                y++;</span><br><span class="line">                maze[x + <span class="number">1</span>][y + <span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;    x=%d,y=%d进栈了\n&quot;</span>, x, y);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (maze_after[x + <span class="number">1</span>][y] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                i++;</span><br><span class="line">                s.Stack[i][<span class="number">0</span>] = x + <span class="number">1</span>;</span><br><span class="line">                s.Stack[i][<span class="number">1</span>] = y;</span><br><span class="line">                x++;</span><br><span class="line">                maze[x + <span class="number">1</span>][y] = <span class="number">-1</span>;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;    x=%d,y=%d进栈了\n&quot;</span>, x, y);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (maze_after[x + <span class="number">1</span>][y - <span class="number">1</span>] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                i++;</span><br><span class="line">                s.Stack[i][<span class="number">0</span>] = x + <span class="number">1</span>;</span><br><span class="line">                s.Stack[i][<span class="number">1</span>] = y - <span class="number">1</span>;</span><br><span class="line">                x++;</span><br><span class="line">                y--;</span><br><span class="line">                maze[x + <span class="number">1</span>][y - <span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;    x=%d,y=%d进栈了\n&quot;</span>, x, y);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (maze_after[x][y - <span class="number">1</span>] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                i++;</span><br><span class="line">                s.Stack[i][<span class="number">0</span>] = x;</span><br><span class="line">                s.Stack[i][<span class="number">1</span>] = y - <span class="number">1</span>;</span><br><span class="line">                y--;</span><br><span class="line">                maze[x][y - <span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;    x=%d,y=%d进栈了\n&quot;</span>, x, y);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (maze_after[x - <span class="number">1</span>][y - <span class="number">1</span>] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                i++;</span><br><span class="line">                s.Stack[i][<span class="number">0</span>] = x - <span class="number">1</span>;</span><br><span class="line">                s.Stack[i][<span class="number">1</span>] = y - <span class="number">1</span>;</span><br><span class="line">                x--;</span><br><span class="line">                y--;</span><br><span class="line">                maze[x - <span class="number">1</span>][y - <span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;    x=%d,y=%d进栈了\n&quot;</span>, x, y);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;x=%d,y=%d退栈了\n&quot;</span>, x, y);   <span class="comment">//转了一圈没通路，把当前的给退栈</span></span><br><span class="line">                s.Stack[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">                s.Stack[i][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">                maze_after[x][y] = <span class="number">-1</span>;</span><br><span class="line">                i--;</span><br><span class="line">                x = s.Stack[i][<span class="number">0</span>];</span><br><span class="line">                y = s.Stack[i][<span class="number">1</span>];</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;退栈完成\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    maze_increase(maze, maze_after);</span><br><span class="line">    check(s, maze_after);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="表达式求值"><a href="#表达式求值" class="headerlink" title="表达式求值"></a>表达式求值</h4><p>设置两个栈，一个存储操作数，一个存储操作符</p><p>运算符栈底初始化为“#”，便于定位操作始末（实际上是把表达式始末设置为“#”）</p><p>遇到数字，入栈</p><p>遇到符号：</p><ol><li>new&gt;top,入栈</li><li>new&#x3D;top,去除一对括号，或者结束（只有  “（”  ， “）” 或者两个“#” 优先级一样）</li><li>new&lt;top,取出数字栈两个元素，和栈顶元素，进行运算得到一个新的数字存回数字栈</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义栈</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> *top_opera;</span><br><span class="line">    <span class="type">char</span> opera[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> opera_length;</span><br><span class="line">&#125;OPERA;</span><br><span class="line">OPERA opera;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="type">int</span>*top_num;</span><br><span class="line">        <span class="type">int</span> num[<span class="number">20</span>];</span><br><span class="line">        <span class="type">int</span> num_length;</span><br><span class="line">    &#125;NUM;</span><br><span class="line">NUM num;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    init_opera(&amp;opera);<span class="comment">//初始化别忘了加&amp;符号</span></span><br><span class="line">    init_num(&amp;num);</span><br><span class="line">    <span class="type">char</span> temp_c = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="type">char</span> c =<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="type">int</span> a =<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> b =<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> exps [<span class="number">50</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入一个表达式&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,exps);</span><br><span class="line">    <span class="type">int</span> length = <span class="built_in">strlen</span>(exps);</span><br><span class="line">    <span class="comment">//开始操作</span></span><br><span class="line">    opera.opera[<span class="number">0</span>]=<span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//if((((int)exps[i])&gt;=48)&amp;&amp;(((int)exps[i])&lt;=57))</span></span><br><span class="line">        <span class="keyword">if</span>((exps[i]&gt;=<span class="string">&#x27;0&#x27;</span>)&amp;&amp;(exps[i]&lt;=<span class="string">&#x27;9&#x27;</span>)) <span class="comment">//更易读</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//应使用push_num代替</span></span><br><span class="line">            *(num.top_num)=exps[i]-<span class="string">&#x27;0&#x27;</span>; <span class="comment">//存 //切记，先点号，再星号</span></span><br><span class="line">            num.top_num++;<span class="comment">//移</span></span><br><span class="line">            num.num_length++;<span class="comment">//加</span></span><br><span class="line">            <span class="keyword">if</span>(num.num_length&gt;=<span class="number">20</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//重新分配内存</span></span><br><span class="line">&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>((exps[i]==<span class="string">&#x27;+&#x27;</span>)||(exps[i]==<span class="string">&#x27;-&#x27;</span>)||(exps[i]==<span class="string">&#x27;*&#x27;</span>)||(exps[i]==<span class="string">&#x27;/&#x27;</span>)||(exps[i]==<span class="string">&#x27;(&#x27;</span>)||(exps[i]==<span class="string">&#x27;)&#x27;</span>)||(exps[i]==<span class="string">&#x27;#&#x27;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(exps[i]==<span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span>(GetTop(num));</span><br><span class="line">            <span class="comment">//使用自定义函数compare来比较符号优先级</span></span><br><span class="line"><span class="keyword">switch</span>(compare(GetTop(opera),exps[i]))</span><br><span class="line">            &#123;</span><br><span class="line">                    <span class="keyword">case</span><span class="number">&#x27;</span>&lt;<span class="string">&#x27;:push_opera(opera,exps[i]);</span></span><br><span class="line"><span class="string">                        break;</span></span><br><span class="line"><span class="string">                    case&#x27;</span>=<span class="string">&#x27;:pop_opera(opera,temp_c);</span></span><br><span class="line"><span class="string">                    pop_opera(opera,temp_c);</span></span><br><span class="line"><span class="string">                    break;</span></span><br><span class="line"><span class="string">                    case&#x27;</span>&gt;<span class="string">&#x27;:pop_num(num,a);</span></span><br><span class="line"><span class="string">                    pop_num(num,b);</span></span><br><span class="line"><span class="string">                    pop_oprea(opera,c);</span></span><br><span class="line"><span class="string">                    push(num,operate(a,c,b));</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        else</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">            printf(&quot;error input&quot;);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    return 0;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241008212735165.png" alt="image-20241008212735165"></p><p>特点：先进先出，只允许在队头删除，只允许在队尾插入</p><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241008212911946.png" alt="image-20241008212911946"></p><ul><li>分析：出队顺序就是入队顺序，即bdcfea，也是出栈顺序 ，入栈顺序是abcdef，后入先出</li><li>a入栈，b入栈，b出栈，c入栈，d入栈，d出栈，c出栈，e，f入栈，fe出栈，a出栈，最小栈容量至少为3</li></ul><h4 id="链队列实现"><a href="#链队列实现" class="headerlink" title="链队列实现"></a>链队列实现</h4><p>思考：链栈和链队列定义上的区别是什么？是什么造成了区别？</p><ul><li><p>在定义链栈的时候，把栈结点结构体定义为指针类型，同时上一个结点中包含指向新结点的指针，形成链，栈的名字 s，永远是指向栈顶元素的指针</p></li><li><p>在定义链队列的时候，也是把队列节点定义为指针类型，上一个节点包含指向下一个节点的指针，队列的名字Q无意义，而是要读取Q.front 和Q.rear 来判断队列头尾指针</p></li><li><p>造成区别的原因：</p><p><strong>栈只需要始终找栈顶元素即可，因此栈名就是指向栈顶元素的指针</strong>，而队列要有头有尾，头出尾进，因此新定义一个结构体来表示</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//栈队列结点类型定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Qnode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    QElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;QNode,*QueuePtr</span><br><span class="line">    </span><br><span class="line"><span class="comment">//栈队列实现</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    QueuePtr front; <span class="comment">//队头指针</span></span><br><span class="line">    QueuePtr rear; <span class="comment">//队尾指针</span></span><br><span class="line">&#125;LinkQueue;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20241008224155300.png" alt="image-20241008224155300"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//带头结点的队列始化</span></span><br><span class="line">LinkQueue Q;</span><br><span class="line">Q.front = <span class="literal">NULL</span>;</span><br><span class="line">Q.rear = <span class="literal">NULL</span>;</span><br><span class="line">Status <span class="title function_">InitQueue</span> <span class="params">(LinkQueue *Q)</span> <span class="comment">//传入要初始化的队列</span></span><br><span class="line">&#123;</span><br><span class="line">    QueuePtr q1; <span class="comment">//一个temp临时q1</span></span><br><span class="line">    <span class="keyword">if</span>(!(q1 = (QNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode)))) <span class="comment">//分配内存</span></span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">    q1-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    Q-&gt;front = q1;</span><br><span class="line">    Q-&gt;rear = q1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//带头结点的队列插入算法</span></span><br><span class="line">Status <span class="title function_">QueueInsert</span> <span class="params">(LinkQueue *Q,elemtype e)</span></span><br><span class="line">&#123;</span><br><span class="line">    QueuePtr q1;</span><br><span class="line">    <span class="keyword">if</span>(!(q1=(*QNode)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode))))</span><br><span class="line">        <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    q1-&gt;data = e;</span><br><span class="line">    </span><br><span class="line">    Q.rear-&gt;next =q1;</span><br><span class="line">    Q.rear=q1;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出队</span></span><br><span class="line">Status <span class="title function_">DelQueue</span><span class="params">(LinkQueue *Q,elemtype *e)</span></span><br><span class="line">&#123;</span><br><span class="line">    QueuePtr q1;</span><br><span class="line">    q1=Q.front-&gt;next;</span><br><span class="line">    *e = *(q1.data); <span class="comment">//哈哈</span></span><br><span class="line">    Q.front = q1-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(q1);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><h4 id="初始化循环队列"><a href="#初始化循环队列" class="headerlink" title="初始化循环队列"></a>初始化循环队列</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化循环队列</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    elemtype <span class="built_in">queue</span> [];<span class="comment">//QElemType *base;</span></span><br><span class="line">    <span class="type">int</span> front;</span><br><span class="line">    <span class="type">int</span> rear;</span><br><span class="line">    <span class="comment">// elemtype *front;   //误区：头尾指针，究其作用还是“指向”</span></span><br><span class="line">    <span class="comment">//elemtype *rear;  //不一定非要是指针类型，对于由数组实现的数据结构</span></span><br><span class="line">    <span class="comment">//整型数字的指向功能反而更好</span></span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">&#125;Queue;</span><br><span class="line"></span><br><span class="line">Queue Q;</span><br><span class="line"></span><br><span class="line">Status <span class="title function_">InitQueueCurl</span><span class="params">(Queue *q)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!((q-&gt;<span class="built_in">queue</span>)=(elemtype*)<span class="built_in">malloc</span>(MAXSIZE*<span class="keyword">sizeof</span>(elemtype))))</span><br><span class="line">        <span class="built_in">exit</span> (OVERFLOW);</span><br><span class="line">    (*q).front = <span class="number">0</span>;</span><br><span class="line">    (*q).rear = <span class="number">0</span>;</span><br><span class="line">    (*q).count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="循环队列-入队的两种思路"><a href="#循环队列-入队的两种思路" class="headerlink" title="循环队列 入队的两种思路"></a>循环队列 入队的两种思路</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//入循环队列</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//方法一：count法</span></span><br><span class="line">Status <span class="title function_">QueueInsert</span><span class="params">(Queue *q,elemtype e)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ((*q).count!=MAXSIZE)</span><br><span class="line">    &#123;</span><br><span class="line">        (*q).<span class="built_in">queue</span>[(*q).rear]=e;</span><br><span class="line"><span class="keyword">if</span>((*q).rear = MAXSIZE)  </span><br><span class="line">        &#123;</span><br><span class="line">            (*q).rear = <span class="number">0</span>;</span><br><span class="line">            (*q).count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            (*q).rear++;</span><br><span class="line">            (*q).count++;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//方法二：整除判断法</span></span><br><span class="line">Status <span class="title function_">QueneInsert</span><span class="params">(Queue *q,elemtype e)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>((((*q).rear)+<span class="number">1</span>)%MAXSIZE == (*q).front)</span><br><span class="line">        <span class="comment">//尾指针加1，取余最大长度，是否等于头指针</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    (*q).<span class="built_in">queue</span>[(*q).rear]=e;</span><br><span class="line">    (*q).rear = ((*q).rear+<span class="number">1</span>)%MAXSIZE;<span class="comment">//尾指针加一，取余最大长度（小于最大长度</span></span><br><span class="line">    <span class="comment">//就相当于没取余，大于最大长度了就相当于再来一轮）</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="循环队列长度求法"><a href="#循环队列长度求法" class="headerlink" title="循环队列长度求法"></a>循环队列长度求法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求循环队列长度的算法</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ququelenth</span><span class="params">(Queue q)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> answer = (q.rear-q.front+MAXSIZE)%MAXSIZE; <span class="comment">//  rear - fount 表示两者距离之差，加上maxsize一定为正数，再取余</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这里也提供了 环形结构 求两个元素之间的距离，加绝对值时候的一种算法思路，就是先减出一个符号不定的距离，然后加上最大长度，再取余最大长度</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="循环队列应用之回文数"><a href="#循环队列应用之回文数" class="headerlink" title="循环队列应用之回文数"></a>循环队列应用之回文数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数参数中有链表时，对&amp;符号的理解与讨论</title>
      <link href="/2024/09/22/%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E4%B8%AD%E6%9C%89%E9%93%BE%E8%A1%A8%E6%97%B6%EF%BC%8C%E5%AF%B9&amp;%E7%AC%A6%E5%8F%B7%E7%9A%84%E7%90%86%E8%A7%A3%E4%B8%8E%E8%AE%A8%E8%AE%BA/"/>
      <url>/2024/09/22/%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E4%B8%AD%E6%9C%89%E9%93%BE%E8%A1%A8%E6%97%B6%EF%BC%8C%E5%AF%B9&amp;%E7%AC%A6%E5%8F%B7%E7%9A%84%E7%90%86%E8%A7%A3%E4%B8%8E%E8%AE%A8%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="先说结论："><a href="#先说结论：" class="headerlink" title="先说结论："></a>先说结论：</h2><p>L和 副本L <strong>本身的地址是一个存储自身的地方，二者不同</strong>，但是这两个变量<strong>所储存的地址都是链表的头节点</strong>，</p><p>因此可以可以通过修改副本l-&gt;next来修改原l头节点的指向，</p><p>但是如果想要改变头节点自身的地址，如果不加&amp;符号，那就相当于修改了副本l所储存的地址，原l不受影响</p><p>关键点：不要错误的以为 函数中的l-&gt;next 是由副本l记录的，实际上这个是由头结点记录的，<strong>副本l指向的地址实际上是记录了头结点的地址</strong></p><h3 id="L-和副本-L-本身是存储地址的变量："><a href="#L-和副本-L-本身是存储地址的变量：" class="headerlink" title="L 和副本 L 本身是存储地址的变量："></a><strong><code>L</code> 和副本 <code>L</code> 本身是存储地址的变量</strong>：</h3><ul><li><code>L</code> 和它的副本 <code>L</code> 是两个不同的指针变量，<strong>它们本身（即 <code>L</code> 和副本 <code>L</code>）存在于不同的内存地址中</strong>。</li><li>但是，<strong>它们存储的值是相同的</strong>，都存储了链表头节点的地址（比如说地址 <code>3</code>）。也就是说，<strong>无论是 <code>L</code> 还是副本 <code>L</code>，它们指向的是同一个链表节点</strong>，这是链表头节点的地址。</li></ul><h3 id="2-L-next-是链表节点的成员："><a href="#2-L-next-是链表节点的成员：" class="headerlink" title="2. L-&gt;next 是链表节点的成员："></a>2. <strong><code>L-&gt;next</code> 是链表节点的成员</strong>：</h3><ul><li><code>L-&gt;next</code> 存储的是链表中下一个节点的地址。这个成员属于链表头节点，所以无论你是通过原始的 <code>L</code> 还是副本 <code>L</code> 来访问 <code>L-&gt;next</code>，你修改的都是同一个链表节点的 <code>next</code> 成员。</li></ul><h3 id="3-修改-L-next-会影响原始-L-："><a href="#3-修改-L-next-会影响原始-L-：" class="headerlink" title="3. **修改 L-&gt;next 会影响原始 L**："></a>3. **修改 <code>L-&gt;next</code> 会影响原始 <code>L</code>**：</h3><ul><li>因为 <code>L</code> 和副本 <code>L</code> 都指向同一个链表节点（同一个头节点），所以**修改 <code>L-&gt;next</code>（即修改头节点的 <code>next</code> 指向的地址）会同时影响原始 <code>L-&gt;next</code>**。</li><li>这就是为什么你通过副本修改 <code>L-&gt;next</code>，原始的 <code>L</code> 也会“感知”到这个变化的原因，因为它们指向的节点是同一个。</li></ul><h3 id="4-改变-L-本身（头节点的地址）需要-："><a href="#4-改变-L-本身（头节点的地址）需要-：" class="headerlink" title="4. **改变 L 本身（头节点的地址）需要 &amp;**："></a>4. **改变 <code>L</code> 本身（头节点的地址）需要 <code>&amp;</code>**：</h3><ul><li>如果你想要改变的是 <code>L</code> 本身（也就是想让 <code>L</code> 指向不同的地址，比如让 <code>L</code> 从指向头节点变成指向其他节点），那么<strong>不加 <code>&amp;</code> 是不行的</strong>。因为如果不加 <code>&amp;</code>，传递的只是 <code>L</code> 的副本，修改的是副本的值，不会影响原始的 <code>L</code>。</li><li><strong>加上 <code>&amp;</code> 的话</strong>，传递的就相当于 <code>L</code> 的地址（即指针的指针），这样在函数内修改 <code>L</code> 本身（让 <code>L</code> 指向新的节点）就能影响到原始的 <code>L</code>。</li></ul><h3 id="5-L-next-和-L-本身是不同的东西："><a href="#5-L-next-和-L-本身是不同的东西：" class="headerlink" title="5. L-&gt;next 和 L 本身是不同的东西："></a>5. <strong><code>L-&gt;next</code> 和 <code>L</code> 本身是不同的东西</strong>：</h3><ul><li><code>L</code> 或副本 <code>L</code> 存储的是链表头节点的地址，<strong>这个值是链表头节点的地址</strong>。</li><li><code>L-&gt;next</code> 存储的是链表头节点的 <code>next</code> 成员，这个值是链表中下一个节点的地址。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typrdef strucrt LNode</span><br><span class="line">&#123;</span><br><span class="line">ElemType data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;*LNode,LinkList;</span><br></pre></td></tr></table></figure><p>上面是一个用于链表的结构体指针类型定义</p><p>函数一：修改一个链表第i个元素（i）  在这个函数中，&#x2F;<em>要传入的链表L</em>&#x2F; 无需加&amp;符号，因为他不涉及对头指针的操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">ChangeElem</span><span class="params">(<span class="comment">/*要传入的链表L*/</span>,<span class="type">int</span> i,elemtype e)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> *<span class="title">LNode</span> <span class="title">point</span> =</span> L;</span><br><span class="line"><span class="type">int</span> j = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(j&lt;=i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!(point = point-&gt;next))</span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">point -&gt; data = e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数二：初始化一个带头节点的空链表  这个函数中，传入的参数就必须是&amp;L，因为它涉及对头指针的操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">LinkInit</span><span class="params">(<span class="comment">/*要传入的链表L*/</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">L = （LNode*）<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    <span class="comment">// *L = （LNode*）malloc(sizeof(LNode)); 如果使用指针的话</span></span><br><span class="line">L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注"><a href="#注" class="headerlink" title="注"></a>注</h3><p><strong>如果使用引用符号&amp;，则函数内部可以直接使用L，</strong></p><p><strong>但如果使用指针的话，要把所有L换成*L</strong></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> 细节辨析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性表</title>
      <link href="/2024/09/18/%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
      <url>/2024/09/18/%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h4 id="复习"><a href="#复习" class="headerlink" title="复习"></a>复习</h4><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/rrr.png" alt="rrr"></p><p>各个循环次数相乘，内层为n，外层为log2n，所以答案是nlog2n</p><h4 id="线性表的类型定义"><a href="#线性表的类型定义" class="headerlink" title="线性表的类型定义"></a>线性表的类型定义</h4><p>线性表是n个<strong>类型相同</strong>的数据元素的有限序列</p><p>存在唯一的第一元素&#x2F;最后元素，除第一元素外，其他元素均有唯一后继，除最后元素外，其他元素都有唯一前驱</p><ul><li><p><strong>小记 ：</strong> c++中引入了引用类型 &amp; ，用法是 b &#x3D; &amp;a ，代表b引用a，二者共用储存空间，在传入参数的时候，直接传入实参即可，不用加取地址符</p><p>如swap（a，b），但是函数在定义的时候，要把形参定义为引用类型 如 void swap（&amp;a，&amp;b），让传入的实参直接被形参引用</p></li></ul><h4 id="顺序线性表的插入操作算法"><a href="#顺序线性表的插入操作算法" class="headerlink" title="顺序线性表的插入操作算法"></a>顺序线性表的插入操作算法</h4><p>给三个参数，一个是sqlist类线性表地址&amp;L，一个整数i代表要插入的位置，一个类型e代表要插入的数据</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">ListInsert</span><span class="params">(sqlist &amp;L,<span class="type">int</span> i,elementtype e)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//首先要判断一下，空间够不够，当前额定容量是L.listsize，已用容量是L.lenth</span></span><br><span class="line"><span class="keyword">if</span>(L.lenth&gt;=L.listsize);</span><br><span class="line"><span class="comment">//分配一个新的空间，这个新空间连带着新基址一起分配,旧基址是L.elem</span></span><br><span class="line">newbase = (elemtype*)<span class="built_in">realloc</span>(L.elem,(L.listsize+LISTINCERASEMENT)*<span class="keyword">sizeof</span>(elemtype));</span><br><span class="line"><span class="comment">//判断一下成功了没</span></span><br><span class="line"><span class="keyword">if</span>(!newbase)</span><br><span class="line">L.elem = newbase;</span><br><span class="line">listsize +=LISTINCREASEMENT;</span><br><span class="line"></span><br><span class="line"><span class="comment">//现在容量够用了，往里面插入</span></span><br><span class="line"><span class="comment">//顺序表往里插入，就把后面的元素后移</span></span><br><span class="line"><span class="keyword">for</span>(j=L.lenth<span class="number">-1</span>; j&gt;=i<span class="number">-1</span>,--j)</span><br><span class="line">&#123;</span><br><span class="line">L.elem[j+<span class="number">1</span>]=L.elem[j]; <span class="comment">//后移</span></span><br><span class="line">&#125;</span><br><span class="line">L.elem[i<span class="number">-1</span>]=e;</span><br><span class="line">L.lenth++; <span class="comment">//别忘了加</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//指针实现：</span></span><br><span class="line">elemtype *q =&amp;L.elem[L.lenth<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = L.lenth<span class="number">-1</span>; j&gt;i<span class="number">-1</span> ;--j)</span><br><span class="line">&#123;</span><br><span class="line">*(q+<span class="number">1</span>) =*q;</span><br><span class="line">q--;</span><br><span class="line">&#125;<span class="comment">//这段for循环相当于定义一个临时变量，让他和指针q同时变化，实际上完全可以把指针q放在for循环语句的临时初始化里，让他自己变化即可</span></span><br><span class="line"> <span class="comment">//之所以用j来标志，一个原因是感觉指针难以比较，其实不然，因为要插入元素所以早晚要用到被插入元素所在的指针，不如提前初始化好，用它来做比较</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">//————————————————————————————————————————————————————</span></span><br><span class="line">elmtype *p = &amp;(L.elem[i<span class="number">-1</span>]); <span class="comment">//先把标志初始化好</span></span><br><span class="line"><span class="keyword">for</span>(elemtype *q =&amp;L.elem[L.lenth<span class="number">-1</span>]; q&gt;=p;--q) <span class="comment">//q和p作比较</span></span><br><span class="line">&#123;</span><br><span class="line">*(q+<span class="number">1</span>) =*q;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//————————————————————————————————————————————————————</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">elmtype *p = &amp;(L.elem[i<span class="number">-1</span>]);<span class="comment">//简化后没有这句</span></span><br><span class="line">*p =e;</span><br><span class="line">++ L.lenth;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">ElemType  data;  <span class="comment">//数据域</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>   //指针域</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&#125;<span class="title">LNode</span>,*<span class="title">LinkList</span> //<span class="title">LNode</span>是别名，*<span class="title">LinkList</span> 是指向该结构体的指针类型别名</span></span><br><span class="line"><span class="class">// <span class="title">LNode</span> <span class="title">L</span>和 *<span class="title">LinkList</span> <span class="title">L</span>不等价，<span class="title">LNode</span> *<span class="title">L</span>和 <span class="title">LinkList</span> <span class="title">L</span>等价 </span></span><br><span class="line"><span class="class">// <span class="title">typedf</span> 定义的是类型名，不要和变量混为一谈</span></span><br><span class="line"><span class="class"></span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20240918174751225.png" alt="image-20240918174751225"></p><ul><li>当然，L-&gt;data 也可以写为 (*L).data</li></ul><h5 id="构造一个空的带头结点的线性表L"><a href="#构造一个空的带头结点的线性表L" class="headerlink" title="构造一个空的带头结点的线性表L"></a>构造一个空的带头结点的线性表L</h5><p>（切记加L要加&amp;符号）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个结构体指针</span></span><br><span class="line">LinkList L；<span class="comment">//此时L就是一个指针类型，可以进行&amp;操作传参数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//编写函数</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">linkinit</span><span class="params">(LinkList &amp;L)</span><span class="comment">//这里之所以要加&amp;符号，是因为要传入指针的指针，才能修改原指针</span></span><br><span class="line">&#123;</span><br><span class="line">L = (Lnode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Lnode));  </span><br><span class="line">L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><h5 id="加-符号的理解"><a href="#加-符号的理解" class="headerlink" title="加&amp;符号的理解"></a>加&amp;符号的理解</h5></li></ul><p>先不考虑结构体相关的东西，而是考虑指针变量最简单的情况，在函数外定义一个int a，要想把int a传入给函数并且让函数能够改变他，就要传入&amp;a，这样函数内的指针变量就能跟就这个地址对他修改，这个过程中，加&amp;符号是为了让函数内部的指针变量读取到他的地址，从而对它进行修改 </p><p>对于linklist l，虽然它本身已经是一个结构体指针变量了，他已经表示一个地址，但是如果直接把他传进函数，实际上传入的是这个地址变量的副本，虽然形参和实参的具体值是一样的（即l所代表的地址），但是只有这个地址是没有办法进行操作的，因为对于一个结点来说，之所以使用结构体指针变量，目的是为了能让别的结构体指针变量的指针域能指向自己，从而对自己进行操作，而不是主要目的是为了去操作别的结点，因为指向别的节点使用它的指针域完成的，而不是结构体指针自身去指，因此如果不加&amp;符号，虽然指向的东西没有改变（但这就像刚才说的，他指向的东西没有意义，因为我们使用他内部的指针域来指向下一个节点，而不是用它自身），但是传入的实际上是一个指针的副本，他指向的东西不变，但在函数外别的东西就没法指向副本了，这是没有意义的，因此要加&amp;符号，传入指针的指针，让指针能指向结构体指针</p><p>简单来说， 之所以定义LinkList为指针类型，是为了能让他被赋值给其他结构体指针变量内部的 指针域 ，从而连起来</p><h5 id="判断是否为空"><a href="#判断是否为空" class="headerlink" title="判断是否为空"></a>判断是否为空</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">LinkEmpty</span><span class="params">(LinkList L)</span><span class="comment">//这个只是读取，不用修改，所制之传入原指针即可，无需加&amp;</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (L-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h5><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20240919170652246.png" alt="image-20240919170652246"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LinkList sForE = (Lnode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Lnode));</span><br><span class="line">sForE-&gt;data = e;</span><br><span class="line">sForE-&gt;next = pre-&gt;next;</span><br><span class="line">pre-next -&gt; sForE</span><br></pre></td></tr></table></figure><h5 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h5><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20240919171428791.png" alt="image-20240919171428791"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//必须知道a的地址</span></span><br><span class="line">delet = pre-&gt;next; <span class="comment">//先把要删除的标记一下，待会free；</span></span><br><span class="line">pre -&gt; next = delet -&gt;next;</span><br><span class="line"><span class="built_in">free</span> (delete);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="取得元素"><a href="#取得元素" class="headerlink" title="取得元素"></a>取得元素</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给三个参数，链表L ， 元素位置int i ，要取的元的地址elementtype &amp;e</span></span><br><span class="line">GetElem(linkList L; <span class="type">int</span> i; ElemType *e)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//设定一个指针，指向第一个元素的节点</span></span><br><span class="line">SearchPoint = L -&gt; next;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j&lt;=i; ++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(SearchPoint-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line">SearchPoint = SearchPoint -&gt; next;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(SearchPoint-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br><span class="line">*e = SearchPoint -&gt; data;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h4><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20240922113439208.png" alt="image-20240922113439208"></p><ul><li>单链表最后一个结点的指针域没有利用，如果使其指向头指针（头节点），则首尾构成一个链表，称作循环链表</li></ul><h4 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h4><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20240922114101755.png" alt="image-20240922114101755"></p><ul><li>一个链表的每个结点都有两个指针域，一个指针指向其前驱节点，另一个指针指向其后继节点</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typrdef <span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">elemtype data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span> *<span class="title">pre</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span> *<span class="title">next</span></span></span><br><span class="line"><span class="class">&#125;<span class="title">DuLNode</span>,*<span class="title">DuLinkList</span>;</span></span><br></pre></td></tr></table></figure><ul><li>p-&gt;pre-&gt;next  和 p-&gt;next-&gt;pre 都是p自身</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//双向链表在i位置前插入元素e</span></span><br><span class="line">Status <span class="title function_">LinkInsert_Dul</span><span class="params">(DuLinkList&amp;L,<span class="type">int</span> i elemtype e)</span></span><br><span class="line">&#123;</span><br><span class="line">    DuLinkList PointForE;</span><br><span class="line"><span class="keyword">if</span>(!(point=(GetElemPoint_dul(L，i)))) <span class="comment">// GetElemPoint 和 GetElem 不一样</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="keyword">if</span>(!(PointForE = (DulLinkList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DulNode))));</span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="comment">//下面开始插入</span></span><br><span class="line">    PointForE -&gt; next = point;</span><br><span class="line">    PointForE -&gt; pre = point -&gt; pre;</span><br><span class="line">    point -&gt; pre -&gt; next = PointForE;</span><br><span class="line">    point -&gt; pre = point;</span><br><span class="line">    PointForE -&gt; data = e;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//双向链表删除位置i的元素</span></span><br><span class="line">Status <span class="title function_">LinkDelete_Dul</span><span class="params">(DuLinkList&amp;L,<span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(!(p=(GetElemPoint_dul(L，i))))</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    p-&gt;pre-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next-&gt;pre = p-&gt;pre;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="一元多项式"><a href="#一元多项式" class="headerlink" title="一元多项式"></a>一元多项式</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//struct</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ploy</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">float</span> factor;</span><br><span class="line">    <span class="type">int</span> power;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ploy</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;ploy,*ployPoint;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化略，下面计算</span></span><br><span class="line">    Status <span class="title function_">PloyAdd</span> <span class="params">(ployPoint *a1, ployPoint *a2)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//计算过程：幂次从小到大，系数相加，如果得0则去掉这一项</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a1_Maxpower = getMaxPower(a1);</span><br><span class="line">    <span class="type">int</span> a2_Maxpower = getMaxPower(a2);   </span><br><span class="line">    <span class="type">int</span> a3_Power = Max(a1,a2);<span class="comment">//定义一个取大的值的函数</span></span><br><span class="line">    a1 = a1 -&gt;next;</span><br><span class="line">    a2 = a2 -&gt;next;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;=a3_power;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a2-&gt;power==a1-&gt;power)</span><br><span class="line">        &#123;</span><br><span class="line">            a3-&gt;power = a1 -&gt; power;</span><br><span class="line">            a3-&gt;factor = a1-&gt;factor + a2-&gt;factor;</span><br><span class="line">            a1 = a1-&gt;next;</span><br><span class="line">            a2 = a2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a2-&gt;power&lt;a1-&gt;power)</span><br><span class="line">        &#123;</span><br><span class="line">            a3-&gt;power = a2 -&gt; power;</span><br><span class="line">            a3-&gt;factor = a2 -&gt; power;</span><br><span class="line">            a2 = a2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            a3 -&gt; power = a1 -&gt; power;</span><br><span class="line">            a3 -&gt; factor = a1 -&gt; factor;</span><br><span class="line">            a1 = a1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        a3 = a3-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树和二叉树</title>
      <link href="/2024/09/18/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2024/09/18/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h3 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h3><ul><li><p><strong>n &#x3D; n0 + n1 +n2</strong></p></li><li><p><strong>n0 &#x3D; n2 +1</strong></p></li><li><p><strong>n-1 &#x3D; n1 + 2*n2</strong>（总度数为n-1）</p></li><li><p>满二叉树： 满的</p></li><li><p>完全二叉树：现有的节点编号和满二叉树的一致</p><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20240923141022960.png" alt="image-20240923141022960"></p></li><li><p>具有n个结点的完全二叉树的深度为<img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20240923141344836.png" alt="image-20240923141344836"></p></li><li><p>已知编号i,求双亲的编号？（完全二叉树）</p></li></ul><p>​<strong>i&#x2F;2 向下取整</strong></p><ul><li><p>已知编号i，左孩子的节点是2i，右孩子是2i+1</p><h3 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h3><h4 id="顺序存储结构"><a href="#顺序存储结构" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h4><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog_imgimage-20241126200632995.png" alt="image-20241126200632995"></p><h4 id="链式存储结构"><a href="#链式存储结构" class="headerlink" title="链式存储结构"></a>链式存储结构</h4><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog_imgimage-20241126200733448.png" alt="image-20241126200733448"></p><h6 id="n个结点的二叉树链式存储中，共有n-1个空指针域"><a href="#n个结点的二叉树链式存储中，共有n-1个空指针域" class="headerlink" title="n个结点的二叉树链式存储中，共有n+1个空指针域"></a><strong>n个结点的二叉树链式存储中，共有n+1个空指针域</strong></h6><p>证明：n个结点的二叉树，除了根节点以外，其余的结点都有上一个双亲结点指来的指针，因此一共有n-1个指针域被利用，所以剩下了n+1个指针域为空</p><h6 id="二叉链表缺点：很难找到双亲结点"><a href="#二叉链表缺点：很难找到双亲结点" class="headerlink" title="二叉链表缺点：很难找到双亲结点"></a>二叉链表缺点：很难找到双亲结点</h6><h5 id="带双亲指针的二叉链表（三叉链表）"><a href="#带双亲指针的二叉链表（三叉链表）" class="headerlink" title="带双亲指针的二叉链表（三叉链表）"></a>带双亲指针的二叉链表（三叉链表）</h5><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog_imgimage-20241126202059907.png" alt="image-20241126202059907"></p><h3 id="遍历二叉树"><a href="#遍历二叉树" class="headerlink" title="遍历二叉树"></a>遍历二叉树</h3><h4 id="遍历的递归算法"><a href="#遍历的递归算法" class="headerlink" title="遍历的递归算法"></a>遍历的递归算法</h4><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog_imgimage-20241126203450680.png" alt="image-20241126203450680"></p><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog_imgimage-20241126203459533.png" alt="image-20241126203459533"></p><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog_imgimage-20241126203509644.png" alt="image-20241126203509644"></p><h4 id="遍历的非递归算法"><a href="#遍历的非递归算法" class="headerlink" title="遍历的非递归算法"></a>遍历的非递归算法</h4><h5 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h5><p>先序遍历：相当于第一次遇到元素就直接遍历</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PreOrder</span><span class="params">(BiTNode *root)</span></span><br><span class="line">&#123;</span><br><span class="line">    BiTNode *p,*node[MAX]; <span class="comment">//p用来更新当前指向的结点  node[]用来当栈</span></span><br><span class="line"><span class="type">int</span> top = <span class="number">0</span>;</span><br><span class="line">    p = root;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">NULL</span>) <span class="comment">//一直滑到最左边</span></span><br><span class="line">        &#123;</span><br><span class="line">            visit(p-&gt;data);<span class="comment">//直接开始遍历</span></span><br><span class="line">            node[top] = p; <span class="comment">//入栈</span></span><br><span class="line">            top ++;</span><br><span class="line">            p = p-&gt;lch;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(top&gt;<span class="number">0</span>) <span class="comment">//既然滑到了最左边，那说明之前滑过去的已经遍历完了，直接回退最后一次的null，然后指向最左边节点的右孩子</span></span><br><span class="line">        &#123;</span><br><span class="line">            top --;</span><br><span class="line">            p = node[top];</span><br><span class="line">            p = p-&gt;rch;</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;<span class="keyword">while</span>(!(top == <span class="number">0</span> &amp;&amp; p==<span class="literal">NULL</span>)) <span class="comment">//只有当栈为空，且p指向null的时候，才标志着遍历结束</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h5><p>中序遍历：相当于第二次遇到元素的时候执行操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">MidOrder</span><span class="params">(BiTNode *root)</span></span><br><span class="line">&#123;</span><br><span class="line">BiTNode *p,*node[MAX]; <span class="comment">//p用来更新当前指向的结点  node[]用来当栈 </span></span><br><span class="line"><span class="type">int</span> top = <span class="number">0</span>;</span><br><span class="line">    p = root;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            node[top] = p;</span><br><span class="line">            top++;</span><br><span class="line">            p = p-&gt;lch;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(top&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            top--;</span><br><span class="line">            p = node[top];</span><br><span class="line">            visit(p-&gt;data);</span><br><span class="line">            p = node[top]-&gt;rch;</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;<span class="keyword">while</span>(!(top==<span class="number">0</span> &amp;&amp; p==<span class="literal">NULL</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h5><p>后序遍历：相当于第三次碰到元素的时候进行操作</p></li></ul><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><h4 id="1-计算节点个数"><a href="#1-计算节点个数" class="headerlink" title="1.计算节点个数"></a>1.计算节点个数</h4><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog_imgimage-20241127003226931.png" alt="image-20241127003226931"></p><ul><li>二叉树nb的地方，就在于它的结构，容易实现递归</li><li>因此，可直接设置递归：</li><li>如果f(b) &#x3D;&#x3D; NULL,那f(b) &#x3D; 0;(递归终止条件)</li><li>如果f(b)!&#x3D;NULL,那f(b) &#x3D; f(b-&gt;lch)+f(b-&gt;rch)</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">compute_node</span><span class="params">(BitTree *node)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(node-&gt;data == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> count = compute_node(node-&gt;lch)+compute_node(node-&gt;rch);</span><br><span class="line"><span class="keyword">return</span> count +<span class="number">1</span>;<span class="comment">//别忘了把自己加上</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-计算叶子节点个数"><a href="#2-计算叶子节点个数" class="headerlink" title="2.计算叶子节点个数"></a>2.计算叶子节点个数</h4><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog_imgimage-20241127003904677.png" alt="image-20241127003904677"></p><ul><li>同上一题一样，只不过是改改返回时的条件</li><li>只有当一个节点没有左节点和右节点的时候，再把它算数</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">compute_yezi</span><span class="params">(BiTree *node)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">NULL</span>) <span class="comment">//放在最前面判断，防止空指针产生错误</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(node-&gt;lch || node-&gt;rch)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> (compute_yezi(node-&gt;lch) + compute_yezi(node-&gt;rch));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-复制二叉树"><a href="#3-复制二叉树" class="headerlink" title="3.复制二叉树"></a>3.复制二叉树</h4><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog_imgimage-20241127004644915.png" alt="image-20241127004644915"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">copy_tree</span><span class="params">(BiTree *backup,BiTree *copy)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(backup == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        copy == <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        copy = (BTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BTNode)); <span class="comment">//分配内存空间</span></span><br><span class="line">        copy-&gt;data = back_up-&gt;data;</span><br><span class="line">        copy_tree(backup-&gt;lch,copy-&gt;lch);</span><br><span class="line">        copy_tree(backup-&gt;rch,copy-&gt;rch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-交换左右子树"><a href="#4-交换左右子树" class="headerlink" title="4.交换左右子树"></a>4.交换左右子树</h4><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog_imgimage-20241127082721170.png" alt="image-20241127082721170"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">change</span><span class="params">(BiTree *backup,BiTree *change)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        change = (BTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BTNode));</span><br><span class="line">        change-&gt;data = back_up-&gt;data;</span><br><span class="line">        <span class="comment">//======下面的与复制不同，是反的====</span></span><br><span class="line">        change(backup-&gt;lch,change-&gt;rch);</span><br><span class="line">        change(backup-&gt;rch,change-&gt;lch);</span><br><span class="line"><span class="comment">//==============================</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-构建二叉树"><a href="#5-构建二叉树" class="headerlink" title="5.构建二叉树"></a>5.构建二叉树</h4><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog_imgimage-20241127084354935.png" alt="image-20241127084354935"></p><ul><li>非递归求解的话，就要用到栈</li><li>递归求解比较简洁</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">creat_tree</span><span class="params">(BiTree *node,<span class="type">char</span>*s)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;<span class="built_in">strlen</span>(s))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            node = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            node = (BiTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">            node-&gt;data = s[i];</span><br><span class="line">            creat_tree(node-&gt;lch);</span><br><span class="line">            creat_tree(node-&gt;rch);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-求二叉树高度"><a href="#6-求二叉树高度" class="headerlink" title="6.求二叉树高度"></a>6.求二叉树高度</h4><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog_imgimage-20241127090727823.png" alt="image-20241127090727823"></p><ul><li><p>别什么都想扯到遍历上，要有递归的“分治思想”</p></li><li><p>二叉树的高度，就是左子树和右子树中，更高的那一支的高度加一，可以用递归求解</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">height</span><span class="params">(BiTree t)</span> <span class="comment">//因为不需要做修改，所以直接传参即可</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(t == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="type">int</span> h1 = height(t.lch);</span><br><span class="line">    <span class="type">int</span> h2 = height(t.rch); </span><br><span class="line">        <span class="keyword">return</span> max(h1,h2);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-删除二叉树"><a href="#7-删除二叉树" class="headerlink" title="7.删除二叉树"></a>7.删除二叉树</h4><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog_imgimage-20241127091633041.png" alt="image-20241127091633041"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">destory</span><span class="params">(BitTree *t)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(t != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">destory(t-&gt;lch);</span><br><span class="line">destory(t-&gt;rch);</span><br><span class="line"><span class="built_in">free</span>(t);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>只能使用类后序遍历的方法，因为节点信息必须最后删除，不然信息会丢失</li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组广义表</title>
      <link href="/2024/09/18/%E6%95%B0%E7%BB%84%E5%B9%BF%E4%B9%89%E8%A1%A8/"/>
      <url>/2024/09/18/%E6%95%B0%E7%BB%84%E5%B9%BF%E4%B9%89%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//二维数组A[b1][b2]中元素Aij的起始地址为：</span><br><span class="line">LOC[i,j]=LOC[0,0]+(b2*i+j)  L</span><br><span class="line">//三维数组A[b1][b2][b3]中数据元素A[i][j][k]的起始地</span><br><span class="line">址为：</span><br><span class="line">LOC[i,j,k]=LOC[0,0,0]+(b2*b3*i+b3*j+k)*L</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="矩阵的压缩存储"><a href="#矩阵的压缩存储" class="headerlink" title="矩阵的压缩存储"></a>矩阵的压缩存储</h2><h3 id="特殊矩阵"><a href="#特殊矩阵" class="headerlink" title="特殊矩阵"></a>特殊矩阵</h3><p><strong>上下三角矩阵：利用矩阵的特殊结构进行降维存储</strong><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog_imgimage-20241125200614453.png" alt="image-20241125200614453"></p><p><strong>对称矩阵：存在降维的下三角矩阵里，然后对称映射</strong></p><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog_imgimage-20241125201459375.png" alt="image-20241125201459375"></p><h3 id="稀疏矩阵"><a href="#稀疏矩阵" class="headerlink" title="稀疏矩阵"></a>稀疏矩阵</h3><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog_imgimage-20241125202133776.png" alt="image-20241125202133776"></p><p>三元组表示：只存储非零元素的 <strong>行 列 值</strong></p><p>代码实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 12500</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> i,j; <span class="comment">//row and column</span></span><br><span class="line">    ElementType e; <span class="comment">//value</span></span><br><span class="line">&#125;Triple_node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Tripe_node [MAXSIZE+<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> mu ,nu ,tu;</span><br><span class="line">&#125;TSMatrix;</span><br><span class="line"></span><br><span class="line">TSMartix M;</span><br></pre></td></tr></table></figure><h3 id="矩阵的压缩存储-1"><a href="#矩阵的压缩存储-1" class="headerlink" title="矩阵的压缩存储"></a>矩阵的压缩存储</h3><h3 id="三元组的转置"><a href="#三元组的转置" class="headerlink" title="三元组的转置"></a>三元组的转置</h3><p>普通方法：最后一列代表元素的值，不变——&gt;前两列转过来——&gt;进行排序，以行为基准</p><p><strong>一步实现：直接对第二列进行扫描，从小到大进行转置并放到新的三元组</strong></p><p>​高复杂度：每次都对第二列进行扫描，选出当前数值最小的（时间复杂度 nu*tu）</p><p>​<strong>低复杂度：只扫描一遍第二列，记录转置之后每一行有几个元素，然后计算出转置之后每行开始存的的首地址</strong></p><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20240918102538589.png" alt="image-20240918102538589"></p><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20240918104202569.png"></p><h2 id="广义表"><a href="#广义表" class="headerlink" title="广义表"></a>广义表</h2><p>表头：第一个元素</p><p>表尾：除了表头以外其他元素组成的表</p><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog_imgimage-20241126173845577.png" alt="image-20241126173845577"></p><p>因此，gethead 取出的是元素（使用后最外一层括号已经去掉），gettail 取出的是广义表（使用后括号层数不变）</p><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog-img/image-20240918105333031.png" alt="v"></p><h3 id="广义表的特点"><a href="#广义表的特点" class="headerlink" title="广义表的特点"></a>广义表的特点</h3><p>① 广义表中的元素可以是原子也可以是子表，广义表是一个多层次结构</p><p>② 广义表是可以共享的。如广义表B是D的子表</p><p>③ 广义表允许递归，如广义表E是一个递归表 </p><p>④ 广义表的元素间存在次序关系和层次关系，广义表展开后包含的 括号层数称为广义表的深度。如C的深度为2，E的深度为 infinity</p><h3 id="广义表的存储结构"><a href="#广义表的存储结构" class="headerlink" title="广义表的存储结构"></a>广义表的存储结构</h3><ol><li>头尾指针结点结构</li></ol><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog_imgimage-20241126174218547.png" alt="image-20241126174218547"></p><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog_imgimage-20241126191603999.png" alt="image-20241126191603999"></p><p>2. </p><p>扩展头尾指针结点结构</p><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog_imgimage-20241126191817080.png" alt="image-20241126191817080"></p><p><img src="https://raw.githubusercontent.com/TheRiddler-EdwardNygma/imgupload/main/blog_imgimage-20241126191826122.png" alt="image-20241126191826122"></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
